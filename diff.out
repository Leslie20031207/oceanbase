diff --git a/src/sql/resolver/expr/ob_raw_expr_util.cpp b/src/sql/resolver/expr/ob_raw_expr_util.cpp
index 3107c6c..dcdb57a 100644
--- a/src/sql/resolver/expr/ob_raw_expr_util.cpp
+++ b/src/sql/resolver/expr/ob_raw_expr_util.cpp
@@ -5339,37 +5339,6 @@ int ObRawExprUtils::build_nvl_expr(ObRawExprFactory &expr_factory, const ColumnI
   return ret;
 }
 
-int ObRawExprUtils::build_nvl_expr(ObRawExprFactory &expr_factory, 
-                                   ObRawExpr *param_expr1, 
-                                   ObRawExpr *param_expr2,
-                                   ObRawExpr *&expr)
-{
-  int ret = OB_SUCCESS;
-  ObSysFunRawExpr *nvl_func_expr = NULL;
-  if (OB_ISNULL(param_expr1) || OB_ISNULL(param_expr2)) {
-    ret = OB_INVALID_ARGUMENT;
-    LOG_WARN("fail to build length expr", K(param_expr1), K(param_expr2), K(ret));
-  } else if (OB_FAIL(expr_factory.create_raw_expr(T_FUN_SYS_NVL, nvl_func_expr))) {
-    LOG_WARN("fail to create raw expr", K(ret));
-  } else if (OB_ISNULL(nvl_func_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("func expr is null", K(nvl_func_expr), K(ret));
-  } else {
-    nvl_func_expr->set_expr_type(T_FUN_SYS_NVL);
-    nvl_func_expr->set_func_name(ObString::make_string(N_NVL));
-  }
-  if (OB_SUCC(ret)) {
-    if (OB_FAIL(nvl_func_expr->add_param_expr(param_expr1))) {
-      LOG_WARN("fail to add param expr", K(ret));
-    } else if (OB_FAIL(nvl_func_expr->add_param_expr(param_expr2))) {
-      LOG_WARN("fail to add param expr", K(ret));
-    } else {
-      expr = nvl_func_expr;
-    }
-  }
-  return ret;
-}
-
 int ObRawExprUtils::build_lnnvl_expr(ObRawExprFactory &expr_factory,
                                      ObRawExpr *param_expr,
                                      ObRawExpr *&expr)
diff --git a/src/sql/resolver/expr/ob_raw_expr_util.h b/src/sql/resolver/expr/ob_raw_expr_util.h
index 6a2b25c..9ab6de8 100644
--- a/src/sql/resolver/expr/ob_raw_expr_util.h
+++ b/src/sql/resolver/expr/ob_raw_expr_util.h
@@ -682,7 +682,6 @@ public:
   static int build_null_expr(ObRawExprFactory &expr_factory, ObRawExpr *&expr);
   static int build_nvl_expr(ObRawExprFactory &expr_factory, const ColumnItem *column_item, ObRawExpr *&expr);
   static int build_nvl_expr(ObRawExprFactory &expr_factory, const ColumnItem *column_item, ObRawExpr *&expr1, ObRawExpr *&expr2);
-  static int build_nvl_expr(ObRawExprFactory &expr_factory, ObRawExpr *param_expr1, ObRawExpr *param_expr2, ObRawExpr *&expr);
   static int build_lnnvl_expr(ObRawExprFactory &expr_factory,
                               ObRawExpr *param_expr,
                               ObRawExpr *&lnnvl_expr);
diff --git a/src/sql/rewrite/ob_transform_const_propagate.cpp b/src/sql/rewrite/ob_transform_const_propagate.cpp
index af029cf..7e13f7c 100644
--- a/src/sql/rewrite/ob_transform_const_propagate.cpp
+++ b/src/sql/rewrite/ob_transform_const_propagate.cpp
@@ -109,7 +109,6 @@ int ObTransformConstPropagate::ExprConstInfo::merge_complex(ExprConstInfo &other
   return ret;
 }
 
-
 int ObTransformConstPropagate::ConstInfoContext::add_const_infos(ObIArray<ExprConstInfo> &const_infos)
 {
   int ret = OB_SUCCESS;
@@ -127,7 +126,7 @@ int ObTransformConstPropagate::ConstInfoContext::add_const_info(ExprConstInfo &c
   bool found = false;
   for (int64_t i = 0; OB_SUCC(ret) && !found && i < active_const_infos_.count(); ++i) {
     ExprConstInfo &cur_info = active_const_infos_.at(i);
-    if (const_info.column_expr_ == cur_info.column_expr_) { /* bugfix(fhkong) */
+    if (const_info.column_expr_ == cur_info.const_expr_) {
       found = true;
       if (const_info.is_used_) {
         if (OB_FAIL(expired_const_infos_.push_back(const_info))) {
@@ -144,29 +143,6 @@ int ObTransformConstPropagate::ConstInfoContext::add_const_info(ExprConstInfo &c
   return ret;
 }
 
-int ObTransformConstPropagate::ConstInfoContext::add_expr_info(ExprInfo &expr_info)
-{
-  int ret = OB_SUCCESS;
-  bool found = false;
-  for (int64_t i = 0; OB_SUCC(ret) && !found && i < active_expr_infos_.count(); ++i) {
-    ExprInfo &cur_info = active_expr_infos_.at(i);
-    if (expr_info.expr_ == cur_info.expr_) { /* bugfix(fhkong) */
-      found = true;
-      if (expr_info.is_used_) {
-        if (OB_FAIL(expired_expr_infos_.push_back(expr_info))) {
-          LOG_WARN("failed to push back", K(ret));
-        }
-      }
-    }
-  }
-  if (OB_SUCC(ret) && !found) {
-    if (OB_FAIL(active_expr_infos_.push_back(expr_info))) {
-      LOG_WARN("failed to push back", K(ret));
-    }
-  }
-  return ret;
-}
-
 int ObTransformConstPropagate::ConstInfoContext::merge_expired_const_infos(ConstInfoContext &other,
                                                                            bool is_null_side)
 {
@@ -183,21 +159,11 @@ int ObTransformConstPropagate::ConstInfoContext::merge_expired_const_infos(Const
       LOG_WARN("failed to push back", K(ret));
     }
   }
-
-  for (int64_t i = 0; OB_SUCC(ret) && i < other.active_expr_infos_.count(); ++i) {
-    if (!other.active_const_infos_.at(i).is_used_) {
-      // do nothing
-    } else if (OB_FAIL(expired_expr_infos_.push_back(other.active_expr_infos_.at(i)))) {
-      LOG_WARN("failed to push back", K(ret));
+  if (OB_SUCC(ret)) {
+    if (OB_FAIL(append(expired_const_infos_, other.expired_const_infos_))) {
+      LOG_WARN("failed to append expired const infos", K(ret));
     }
   }
-
-  if (OB_FAIL(ret)) {
-  } else if (OB_FAIL(append(expired_const_infos_, other.expired_const_infos_))) {
-    LOG_WARN("failed to append expired const infos", K(ret));
-  } else if (OB_FAIL(append(expired_expr_infos_, other.expired_expr_infos_))) {
-    LOG_WARN("failed to append expired const infos", K(ret));
-  }
   return ret;
 }
 
@@ -227,27 +193,13 @@ int ObTransformConstPropagate::ConstInfoContext::expire_const_infos()
       LOG_WARN("failed to push back", K(ret));
     }
   }
-
-  for (int64_t i = 0; OB_SUCC(ret) && i < active_expr_infos_.count(); ++i) {
-    if (!active_expr_infos_.at(i).is_used_) {
-      // do nothing
-    } else if (OB_FAIL(expired_expr_infos_.push_back(active_expr_infos_.at(i)))) {
-      LOG_WARN("failed to push back", K(ret));
-    }
-  }
-
   if (OB_SUCC(ret)) {
-    active_expr_infos_.reuse();
     active_const_infos_.reuse();
     extra_excluded_exprs_.reuse();
   }
   return ret;
 }
 
-bool ObTransformConstPropagate::ConstInfoContext::active_empty() {
-  return active_expr_infos_.empty() && active_const_infos_.empty();
-}
-
 int ObTransformConstPropagate::check_hint_status(const ObDMLStmt &stmt, bool &need_trans)
 {
   int ret = OB_SUCCESS;
@@ -331,9 +283,8 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
       }
     }
 
-    if (OB_SUCC(ret) && !const_ctx.active_empty()) {
-      if (OB_FAIL(replace_common_exprs(stmt,
-                                       stmt->get_condition_exprs(),
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty()) {
+      if (OB_FAIL(replace_common_exprs(stmt->get_condition_exprs(),
                                        const_ctx,
                                        is_happened))) {
         LOG_WARN("failed to replace condition exprs", K(ret));
@@ -343,7 +294,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
       }
     }
 
-    if (OB_SUCC(ret) && !const_ctx.active_empty() &&
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty() &&
         (stmt->is_insert_stmt() || stmt->is_merge_stmt())) {
       is_happened = false;
       ObDelUpdStmt *insert = static_cast<ObDelUpdStmt *>(stmt);
@@ -358,11 +309,10 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
       }
     }
 
-    if (OB_SUCC(ret) && !const_ctx.active_empty() &&
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty() &&
         (stmt->is_insert_stmt() || stmt->is_merge_stmt())) {
       ObDelUpdStmt *insert = static_cast<ObDelUpdStmt *>(stmt);
-      if (OB_FAIL(replace_common_exprs(stmt,
-                                       insert->get_sharding_conditions(),
+      if (OB_FAIL(replace_common_exprs(insert->get_sharding_conditions(),
                                        const_ctx,
                                        is_happened))) {
         LOG_WARN("failed to repalce condition exprs", K(ret));
@@ -372,7 +322,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
       }
     }
 
-    if (OB_SUCC(ret) && !const_ctx.active_empty()) {
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty()) {
       is_happened = false;
       if (OB_FAIL(replace_semi_conditions(stmt,
                                           const_ctx,
@@ -390,9 +340,9 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
       has_rollup_or_groupingsets = true;
     }
 
-    if (OB_SUCC(ret) && !const_ctx.active_empty() && stmt->is_select_stmt() && !has_rollup_or_groupingsets) {
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty() && stmt->is_select_stmt() && !has_rollup_or_groupingsets) {
       is_happened = false;
-      if (OB_FAIL(replace_group_exprs(stmt,
+      if (OB_FAIL(replace_group_exprs(static_cast<ObSelectStmt*>(stmt),
                                       const_ctx,
                                       ignore_all_select_exprs,
                                       is_happened))) {
@@ -412,9 +362,8 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
 
 
     if (OB_SUCC(ret) && stmt->is_select_stmt()) {
-      if (!const_ctx.active_empty()
-          && !ignore_all_select_exprs && static_cast<ObSelectStmt*>(stmt)->get_aggr_item_size() > 0) {
-        if (OB_FAIL(replace_select_exprs(stmt,
+      if (!const_ctx.active_const_infos_.empty() && !ignore_all_select_exprs && static_cast<ObSelectStmt*>(stmt)->get_aggr_item_size() > 0) {
+        if (OB_FAIL(replace_select_exprs(static_cast<ObSelectStmt*>(stmt),
                                         const_ctx,
                                         is_happened))) {
           LOG_WARN("failed to replace select exprs", K(ret));
@@ -439,8 +388,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
     }
 
     if (OB_SUCC(ret) && stmt->is_select_stmt()) {
-      if (OB_FAIL(replace_common_exprs(stmt,
-                                       static_cast<ObSelectStmt*>(stmt)->get_having_exprs(),
+      if (OB_FAIL(replace_common_exprs(static_cast<ObSelectStmt*>(stmt)->get_having_exprs(),
                                        const_ctx,
                                        is_happened))) {
         LOG_WARN("failed to replace having exprs", K(ret));
@@ -450,10 +398,9 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
       }
     }
 
-    if (OB_SUCC(ret) && !const_ctx.active_empty()) {
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty()) {
       is_happened = false;
-      if (OB_FAIL(replace_orderby_exprs(stmt,
-                                        stmt->get_order_items(),
+      if (OB_FAIL(replace_orderby_exprs(stmt->get_order_items(),
                                         const_ctx,
                                         is_happened))) {
         LOG_WARN("failed to replace orderby exprs", K(ret));
@@ -464,7 +411,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
     }
 
     // replace select exprs using common const info and post-gby const info
-    if (OB_SUCC(ret) && !const_ctx.active_empty() && stmt->is_select_stmt() && !ignore_all_select_exprs) {
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty() && stmt->is_select_stmt() && !ignore_all_select_exprs) {
       is_happened = false;
       if (static_cast<ObSelectStmt*>(stmt)->get_aggr_item_size() > 0) {
         if (OB_FAIL(replace_select_exprs_skip_agg(static_cast<ObSelectStmt*>(stmt),
@@ -475,7 +422,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
           trans_happened |= is_happened;
           LOG_TRACE("succeed to do const propagation for select expr", K(is_happened));
         }
-      } else if (OB_FAIL(replace_select_exprs(stmt,
+      } else if (OB_FAIL(replace_select_exprs(static_cast<ObSelectStmt*>(stmt),
                                        const_ctx,
                                        is_happened))) {
         LOG_WARN("failed to replace select exprs", K(ret));
@@ -486,7 +433,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
     }
 
     // replace update assignment list
-    if (OB_SUCC(ret) && !const_ctx.active_empty() && stmt->is_update_stmt()) {
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty() && stmt->is_update_stmt()) {
       is_happened = false;
       ObUpdateStmt *upd_stmt = static_cast<ObUpdateStmt *>(stmt);
        for (int64_t i = 0; OB_SUCC(ret) && i < upd_stmt->get_update_table_info().count(); ++i) {
@@ -494,8 +441,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
         if (OB_ISNULL(table_info)) {
           ret = OB_ERR_UNEXPECTED;
           LOG_WARN("get null table info", K(ret));
-        } else if (OB_FAIL(replace_assignment_exprs(stmt,
-                                                    table_info->assignments_,
+        } else if (OB_FAIL(replace_assignment_exprs(table_info->assignments_,
                                                     const_ctx,
                                                     is_happened))) {
           LOG_WARN("failed to replace assignment exprs", K(ret));
@@ -507,7 +453,7 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
     }
 
     // replace condition exprs from check constraint exprs.
-    if (OB_SUCC(ret) && !const_ctx.active_empty()) {
+    if (OB_SUCC(ret) && !const_ctx.active_const_infos_.empty()) {
       is_happened = false;
       if (OB_FAIL(replace_check_constraint_exprs(stmt,
                                                  const_ctx,
@@ -524,10 +470,6 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
         LOG_WARN("failed to append active equal params constraints", K(ret));
       } else if (OB_FAIL(collect_equal_param_constraints(const_ctx.expired_const_infos_))) {
         LOG_WARN("failed to append expired equal params constraints", K(ret));
-      } else if (OB_FAIL(collect_equal_param_constraints(const_ctx.active_expr_infos_))) {
-        LOG_WARN("failed to append expired equal params constraints", K(ret));
-      } else if (OB_FAIL(collect_equal_param_constraints(const_ctx.expired_expr_infos_))) {
-        LOG_WARN("failed to append expired equal params constraints", K(ret));
       } else if (OB_FAIL(remove_const_exec_param(stmt))) {
         LOG_WARN("failed to remove const exec param", K(ret));
       } else if (OB_FAIL(stmt->formalize_stmt(ctx_->session_info_))) {
@@ -544,27 +486,6 @@ int ObTransformConstPropagate::do_transform(ObDMLStmt *stmt,
   return ret;
 }
 
-/** replace expr with const_true_expr */
-int ObTransformConstPropagate::replace_with_true_expr(ObRawExpr *&expr, ConstInfoContext &const_ctx) {
-  int ret = OB_SUCCESS;
-  if (OB_LIKELY(NULL == const_ctx.true_expr_)) {
-    if (OB_ISNULL(ctx_)) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected param is NULL", K(ret));
-    } else if (OB_FAIL(ObRawExprUtils::build_const_bool_expr(ctx_->expr_factory_, 
-                                                        expr, true))) {
-      LOG_WARN("failed to build bool expr");
-    } else if (OB_ISNULL(expr)) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected param is NULL", K(ret));
-    }
-  }
-  if (OB_SUCC(ret)) {
-    expr = const_ctx.true_expr_;
-  }
-  return ret;
-}
-
 int ObTransformConstPropagate::exclude_redundancy_join_cond(ObIArray<ObRawExpr*> &condition_exprs,
                                                             ObIArray<ExprConstInfo> &expr_const_infos,
                                                             ObIArray<ObRawExpr*> &excluded_exprs)
@@ -748,8 +669,7 @@ int ObTransformConstPropagate::recursive_collect_const_info_from_table(ObDMLStmt
       }
       if (OB_SUCC(ret)) {
         bool is_happened = false;
-        if (OB_FAIL(SMART_CALL(recursive_replace_join_conditions(stmt,
-                                                                 joined_table,
+        if (OB_FAIL(SMART_CALL(recursive_replace_join_conditions(joined_table,
                                                                  tmp_ctx,
                                                                  is_happened)))) {
           LOG_WARN("failed to replace exprs in joined table", K(ret));
@@ -882,26 +802,20 @@ int ObTransformConstPropagate::collect_equal_pair_from_pullup(ObDMLStmt *stmt,
   return ret;
 }
 
-int ObTransformConstPropagate::replace_common_exprs(ObDMLStmt *stmt,
-                                                    ObIArray<ObRawExpr *> &exprs,
+int ObTransformConstPropagate::replace_common_exprs(ObIArray<ObRawExpr *> &exprs,
                                                     ConstInfoContext &const_ctx,
                                                     bool &trans_happened,
                                                     bool used_in_compare)
 {
   int ret = OB_SUCCESS;
   trans_happened = false;
-  if (OB_ISNULL(stmt)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL", K(ret));
-  }
   for (int64_t i = 0; OB_SUCC(ret) && i < exprs.count(); ++i) {
     ObRawExpr *&cur_expr = exprs.at(i);
     bool internal_trans_happened = false;
     if (OB_ISNULL(cur_expr)) {
       ret = OB_ERR_UNEXPECTED;
       LOG_WARN("invalid parameter", K(ret));
-    } else if (OB_FAIL(replace_expr_internal(stmt,
-                                             cur_expr,
+    } else if (OB_FAIL(replace_expr_internal(cur_expr,
                                              const_ctx,
                                              internal_trans_happened,
                                              used_in_compare))) {
@@ -913,49 +827,42 @@ int ObTransformConstPropagate::replace_common_exprs(ObDMLStmt *stmt,
   return ret;
 }
 
-int ObTransformConstPropagate::replace_group_exprs(ObDMLStmt *stmt,
+int ObTransformConstPropagate::replace_group_exprs(ObSelectStmt *stmt,
                                                    ConstInfoContext &const_ctx,
                                                    bool ignore_all_select_exprs,
                                                    bool &trans_happened)
 {
   int ret = OB_SUCCESS;
   trans_happened = false;
-  ObSelectStmt *select_stmt = NULL;
   if (OB_ISNULL(stmt)) {
     ret = OB_ERR_UNEXPECTED;
     LOG_WARN("invalid parameter", K(ret));
-  } else if (!stmt->is_select_stmt()) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected stmt type error", K(ret));
-  } else {
-    select_stmt = static_cast<ObSelectStmt*>(stmt);
-    for (int64_t i = 0; OB_SUCC(ret) && i < select_stmt->get_group_expr_size(); ++i) {
-      ObRawExpr *group_expr = select_stmt->get_group_exprs().at(i);
-      bool can_replace = true;
-      bool internal_trans_happened = false;
-      if (OB_ISNULL(group_expr)) {
-        ret = OB_ERR_UNEXPECTED;
-        LOG_WARN("invalid parameter", K(ret));
-      } else if (OB_FAIL(check_can_replace_in_select(select_stmt, group_expr, ignore_all_select_exprs,
-                                                    can_replace))) {
-        LOG_WARN("failed to check can replace in select", K(ret));
-      } else if (!can_replace) {
-        // group expr can not be transfromed when the corresponding select item can not be transfromed
-      } else if (OB_FAIL(replace_expr_internal(stmt,
-                                              select_stmt->get_group_exprs().at(i),
-                                              const_ctx,
-                                              internal_trans_happened,
-                                              false))) {
-        LOG_WARN("failed to replace select exprs based on equal_pair", K(ret));
-      } else {
-        trans_happened |= internal_trans_happened;
-      }
+  }
+  for (int64_t i = 0; OB_SUCC(ret) && i < stmt->get_group_expr_size(); ++i) {
+    ObRawExpr *group_expr = stmt->get_group_exprs().at(i);
+    bool can_replace = true;
+    bool internal_trans_happened = false;
+    if (OB_ISNULL(group_expr)) {
+      ret = OB_ERR_UNEXPECTED;
+      LOG_WARN("invalid parameter", K(ret));
+    } else if (OB_FAIL(check_can_replace_in_select(stmt, group_expr, ignore_all_select_exprs,
+                                                   can_replace))) {
+      LOG_WARN("failed to check can replace in select", K(ret));
+    } else if (!can_replace) {
+      // group expr can not be transfromed when the corresponding select item can not be transfromed
+    } else if (OB_FAIL(replace_expr_internal(stmt->get_group_exprs().at(i),
+                                             const_ctx,
+                                             internal_trans_happened,
+                                             false))) {
+      LOG_WARN("failed to replace select exprs based on equal_pair", K(ret));
+    } else {
+      trans_happened |= internal_trans_happened;
     }
   }
   return ret;
 }
 
-int ObTransformConstPropagate::replace_select_exprs(ObDMLStmt *stmt,
+int ObTransformConstPropagate::replace_select_exprs(ObSelectStmt *stmt,
                                                     ConstInfoContext &const_ctx,
                                                     bool &trans_happened)
 {
@@ -964,35 +871,30 @@ int ObTransformConstPropagate::replace_select_exprs(ObDMLStmt *stmt,
   if (OB_ISNULL(stmt)) {
     ret = OB_ERR_UNEXPECTED;
     LOG_WARN("invalid parameter", K(ret));
-  } else if (!stmt->is_select_stmt()) {
-  } else {
-    ObSelectStmt *select_stmt = static_cast<ObSelectStmt*>(stmt);
-    for (int64_t i = 0; OB_SUCC(ret) && i < select_stmt->get_select_items().count(); ++i) {
-      ObRawExpr *&cur_expr = select_stmt->get_select_items().at(i).expr_;
-      bool internal_trans_happened = false;
-      if (OB_ISNULL(cur_expr)) {
-        ret = OB_ERR_UNEXPECTED;
-        LOG_WARN("invalid parameter", K(ret));
-      } else if (cur_expr->is_column_ref_expr()) {
-        if (OB_FAIL(generate_pullup_const_info(select_stmt, cur_expr, const_ctx))) {
-          LOG_WARN("failed to generate pullup const info", K(ret));
-        }
-      } else if (OB_FAIL(replace_expr_internal(stmt,
-                                              cur_expr,
-                                              const_ctx,
-                                              internal_trans_happened,
-                                              false))) {
-        LOG_WARN("failed to replace select exprs based on equal_pair", K(ret));
-      } else {
-        trans_happened |= internal_trans_happened;
+  }
+  for (int64_t i = 0; OB_SUCC(ret) && i < stmt->get_select_items().count(); ++i) {
+    ObRawExpr *&cur_expr = stmt->get_select_items().at(i).expr_;
+    bool internal_trans_happened = false;
+    if (OB_ISNULL(cur_expr)) {
+      ret = OB_ERR_UNEXPECTED;
+      LOG_WARN("invalid parameter", K(ret));
+    } else if (cur_expr->is_column_ref_expr()) {
+      if (OB_FAIL(generate_pullup_const_info(stmt, cur_expr, const_ctx))) {
+        LOG_WARN("failed to generate pullup const info", K(ret));
       }
+    } else if (OB_FAIL(replace_expr_internal(cur_expr,
+                                             const_ctx,
+                                             internal_trans_happened,
+                                             false))) {
+      LOG_WARN("failed to replace select exprs based on equal_pair", K(ret));
+    } else {
+      trans_happened |= internal_trans_happened;
     }
   }
   return ret;
 }
 
-int ObTransformConstPropagate::replace_orderby_exprs(ObDMLStmt *stmt,
-                                                     ObIArray<OrderItem> &order_items,
+int ObTransformConstPropagate::replace_orderby_exprs(ObIArray<OrderItem> &order_items,
                                                      ConstInfoContext &const_ctx,
                                                      bool &trans_happened)
 {
@@ -1004,8 +906,7 @@ int ObTransformConstPropagate::replace_orderby_exprs(ObDMLStmt *stmt,
     if (OB_ISNULL(cur_expr)) {
       ret = OB_ERR_UNEXPECTED;
       LOG_WARN("invalid parameter", K(ret));
-    } else if (OB_FAIL(replace_expr_internal(stmt,
-                                             cur_expr,
+    } else if (OB_FAIL(replace_expr_internal(cur_expr,
                                              const_ctx,
                                              internal_trans_happened))) {
       LOG_WARN("failed to replace order by exprs based on equal_pair", K(ret));
@@ -1016,9 +917,7 @@ int ObTransformConstPropagate::replace_orderby_exprs(ObDMLStmt *stmt,
   return ret;
 }
 
-int ObTransformConstPropagate::replace_assignment_exprs(
-                                                        ObDMLStmt *stmt,
-                                                        ObIArray<ObAssignment> &assignments,
+int ObTransformConstPropagate::replace_assignment_exprs(ObIArray<ObAssignment> &assignments,
                                                         ConstInfoContext &const_ctx,
                                                         bool &trans_happened)
 {
@@ -1030,8 +929,7 @@ int ObTransformConstPropagate::replace_assignment_exprs(
     if (OB_ISNULL(assign.expr_)) {
       ret = OB_ERR_UNEXPECTED;
       LOG_WARN("assgin expr is null", K(ret));
-    } else if (OB_FAIL(replace_expr_internal(stmt,
-                                             assign.expr_,
+    } else if (OB_FAIL(replace_expr_internal(assign.expr_,
                                              const_ctx,
                                              internal_trans_happened,
                                              false))) {
@@ -1059,10 +957,7 @@ int ObTransformConstPropagate::replace_join_conditions(ObDMLStmt *stmt,
     if (OB_ISNULL(table)) {
       ret = OB_ERR_UNEXPECTED;
       LOG_WARN("invalid parameter", K(ret));
-    } else if (OB_FAIL(recursive_replace_join_conditions(stmt, 
-                                                         table, 
-                                                         const_ctx, 
-                                                         is_happened))) {
+    } else if (OB_FAIL(recursive_replace_join_conditions(table, const_ctx, is_happened))) {
       LOG_WARN("failed to replace exprs in joined table", K(ret));
     } else {
       trans_happened |= is_happened;
@@ -1095,8 +990,7 @@ int ObTransformConstPropagate::replace_semi_conditions(ObDMLStmt *stmt,
                                                     const_ctx.active_const_infos_,
                                                     const_ctx.extra_excluded_exprs_))) {
       LOG_WARN("failed to exclude redundancy join cond", K(ret));
-    } else if (OB_FAIL(replace_common_exprs(stmt,
-                                            semi_info->semi_conditions_,
+    } else if (OB_FAIL(replace_common_exprs(semi_info->semi_conditions_,
                                             const_ctx,
                                             is_happened))) {
       LOG_WARN("failed to replace semi condition exprs", K(ret));
@@ -1110,11 +1004,9 @@ int ObTransformConstPropagate::replace_semi_conditions(ObDMLStmt *stmt,
   return ret;
 }
 
-int ObTransformConstPropagate::recursive_replace_join_conditions(
-                                                    ObDMLStmt *stmt,
-                                                    TableItem *table_item,
-                                                    ConstInfoContext &const_ctx,
-                                                    bool &trans_happened)
+int ObTransformConstPropagate::recursive_replace_join_conditions(TableItem *table_item,
+                                                                 ConstInfoContext &const_ctx,
+                                                                 bool &trans_happened)
 {
   int ret = OB_SUCCESS;
   if (OB_ISNULL(table_item)) {
@@ -1126,8 +1018,7 @@ int ObTransformConstPropagate::recursive_replace_join_conditions(
     JoinedTable *joined_table = static_cast<JoinedTable *>(table_item);
     bool is_happened = false;
     if (OB_SUCC(ret) && (joined_table->is_right_join() || joined_table->is_inner_join())) {
-      if (OB_FAIL(SMART_CALL(recursive_replace_join_conditions(stmt,
-                                                               joined_table->left_table_,
+      if (OB_FAIL(SMART_CALL(recursive_replace_join_conditions(joined_table->left_table_,
                                                                const_ctx,
                                                                is_happened)))) {
         LOG_WARN("failed to replace exprs in joined table", K(ret));
@@ -1136,8 +1027,7 @@ int ObTransformConstPropagate::recursive_replace_join_conditions(
       }
     }
     if (OB_SUCC(ret) && (joined_table->is_left_join() || joined_table->is_inner_join())) {
-      if (OB_FAIL(SMART_CALL(recursive_replace_join_conditions(stmt,
-                                                               joined_table->right_table_,
+      if (OB_FAIL(SMART_CALL(recursive_replace_join_conditions(joined_table->right_table_,
                                                                const_ctx,
                                                                is_happened)))) {
         LOG_WARN("failed to replace exprs in joined table", K(ret));
@@ -1146,8 +1036,7 @@ int ObTransformConstPropagate::recursive_replace_join_conditions(
       }
     }
     if (OB_SUCC(ret)) {
-      if (OB_FAIL(SMART_CALL(replace_common_exprs(stmt,
-                                                  joined_table->get_join_conditions(),
+      if (OB_FAIL(SMART_CALL(replace_common_exprs(joined_table->get_join_conditions(),
                                                   const_ctx,
                                                   is_happened)))) {
         LOG_WARN("failed to replace join condition exprs", K(ret));
@@ -1159,30 +1048,20 @@ int ObTransformConstPropagate::recursive_replace_join_conditions(
   return ret;
 }
 
-int ObTransformConstPropagate::replace_expr_internal(ObDMLStmt *stmt,
-                                                     ObRawExpr *&cur_expr,
+int ObTransformConstPropagate::replace_expr_internal(ObRawExpr *&cur_expr,
                                                      ConstInfoContext &const_ctx,
                                                      bool &trans_happened,
                                                      bool used_in_compare)
 {
   int ret = OB_SUCCESS;
-  bool const_trans_happended = false;
-  bool expr_trans_happended = false;
   if (const_ctx.hint_allowed_trans_) {
     ObSEArray<ObRawExpr *, 8> parent_exprs;
     if (OB_FAIL(recursive_replace_expr(cur_expr,
                                       parent_exprs,
                                       const_ctx,
                                       used_in_compare,
-                                      const_trans_happended))) {
-      LOG_WARN("failed to recursive replace const equal expr", K(ret));
-    } else if (OB_FAIL(recursive_replace_case_when_expr(stmt,
-                                                        cur_expr, 
-                                                        const_ctx, 
-                                                        expr_trans_happended))) {
-      LOG_WARN("failed to recursive replace case when expr", K(ret));
-    } else {
-      trans_happened |= const_trans_happended || expr_trans_happended;
+                                      trans_happened))) {
+      LOG_WARN("failed to recursive");
     }
   }
   return ret;
@@ -1242,166 +1121,6 @@ int ObTransformConstPropagate::recursive_replace_expr(ObRawExpr *&cur_expr,
   return ret;
 }
 
-int ObTransformConstPropagate::recursive_replace_case_when_expr(
-                                          ObDMLStmt *stmt,
-                                          ObRawExpr *&cur_expr, 
-                                          ConstInfoContext &const_ctx, 
-                                          bool &trans_happended) {
-  int ret = OB_SUCCESS;
-  trans_happended = false;
-  bool is_shared = false;
-  bool is_happended = false;
-  if (OB_ISNULL(cur_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("invalid parameter", K(ret));
-  } else if (OB_FAIL(const_ctx.shared_expr_checker_.is_shared_expr(cur_expr, is_shared))) {
-    LOG_WARN("failed to check is shared expr", K(ret));
-  } else if (is_shared) {
-    /* do nothing */
-  } else if (OB_FAIL(replace_case_when_internal(
-                                        stmt,
-                                        cur_expr,
-                                        const_ctx,
-                                        is_happended))) {
-    LOG_WARN("failed to replace case when expr internal", K(ret));
-  } else if (!is_happended && cur_expr->get_param_count() > 0) {
-    int64_t N = cur_expr->get_param_count();
-    for (int64_t i = 0; OB_SUCC(ret) && i < N; ++i) {
-      bool param_trans_happended = false;
-      ObRawExpr *&child_expr = cur_expr->get_param_expr(i);
-      if (OB_FAIL(SMART_CALL(recursive_replace_case_when_expr(
-                                                      stmt,
-                                                      child_expr,
-                                                      const_ctx,
-                                                      param_trans_happended)))) {
-        LOG_WARN("replace reference column failed", K(ret));
-      } else {
-        trans_happended |= param_trans_happended;
-      }
-    }
-  }
-  return ret;
-}
-
-int ObTransformConstPropagate::replace_case_when_internal(
-                                                ObDMLStmt *stmt,
-                                                ObRawExpr *&cur_expr,
-                                                ConstInfoContext &const_ctx,
-                                                bool &trans_happended)
-{
-  int ret = OB_SUCCESS;
-  trans_happended = false;
-  ObCaseOpRawExpr *case_expr = NULL;
-  if (OB_ISNULL(cur_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("invalid param", K(ret));
-  } else if (T_OP_CASE != cur_expr->get_expr_type()) {
-  } else if (OB_FALSE_IT(case_expr = static_cast<ObCaseOpRawExpr*>(cur_expr))) {
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() != case_expr->get_then_expr_size())) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect param in case expr", K(ret), 
-                      K(case_expr->get_when_expr_size()),
-                      K(case_expr->get_then_expr_size()));
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() <= 0)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect param in case expr", K(ret));
-  } else {
-    for (int64_t i = 0; OB_SUCC(ret) && i < case_expr->get_when_expr_size(); ++i) {
-      bool is_happended = false;
-      if (OB_FAIL(recursive_replace_when_expr_internal(
-                                                stmt,
-                                                case_expr->get_when_param_expr(i), 
-                                                const_ctx, 
-                                                is_happended))) {
-        LOG_WARN("failed to replace case when expr", K(ret));
-      } else {
-        trans_happended |= is_happended;
-      }
-    } 
-  }
-  return ret;
-}
-
-
-int ObTransformConstPropagate::recursive_replace_when_expr_internal(
-                                                ObDMLStmt *stmt,
-                                                ObRawExpr *&when_expr, 
-                                                ConstInfoContext &const_ctx, 
-                                                bool &trans_happended) {
-  int ret = OB_SUCCESS;
-  trans_happended = false; 
-  bool is_happended = false;
-  if (OB_ISNULL(when_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("invalid parameter", K(ret));
-  } else if (OB_FAIL(replace_when_expr_internal(stmt, 
-                                                when_expr, 
-                                                const_ctx, 
-                                                is_happended))) {
-    LOG_WARN("failed to replace when expr internal", K(ret));
-  } else if (!is_happended) {
-    bool is_shared = false; // if this is shared_expr, we shouldn't replace its children exprs
-    if (OB_FAIL(const_ctx.shared_expr_checker_.is_shared_expr(when_expr, is_shared))) {
-      LOG_WARN("failed to check is shared expr", K(ret)); 
-    } else if (is_shared) {
-      /* do nothing */
-    } else if (when_expr->get_param_count() > 0) {
-      int64_t N = when_expr->get_param_count();
-      for (int64_t i = 0; OB_SUCC(ret) && i < N; ++i) {
-        bool param_trans_happended = false;
-        if (OB_FAIL(SMART_CALL(recursive_replace_when_expr_internal(
-                                                          stmt,
-                                                          when_expr->get_param_expr(i),
-                                                          const_ctx,
-                                                          param_trans_happended)))) {
-
-          LOG_WARN("failed to recusive replace when expr", K(ret));
-        } else {
-          trans_happended |= param_trans_happended;
-        }
-      }
-    }
-  } else {
-    trans_happended |= is_happended;
-  }
-  return ret;
-}
-
-int ObTransformConstPropagate::replace_when_expr_internal(
-                                          ObDMLStmt *stmt, 
-                                          ObRawExpr *&when_expr, 
-                                          ConstInfoContext &const_ctx, 
-                                          bool &trans_happended) 
-{
-  int ret = OB_SUCCESS;
-  trans_happended = false;
-  ObStmtCompareContext equal_ctx; 
-  if (OB_ISNULL(when_expr) || OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL", K(ret));
-  }
-  equal_ctx.init(&stmt->get_query_ctx()->calculable_items_);
-  ObIArray<ExprInfo> &expr_infos = const_ctx.active_expr_infos_;
-  for (int64_t i = 0; OB_SUCC(ret) && i < expr_infos.count(); ++i) {
-    ObRawExpr *expr = expr_infos.at(i).expr_;
-    if (OB_ISNULL(expr)) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected param is NULL", K(ret));
-    } else if (!when_expr->same_as(*expr, &equal_ctx)) {
-      /* do nothing */
-    } else if (OB_FAIL(replace_with_true_expr(when_expr, const_ctx))) {
-      LOG_WARN("failed to replace with true expr", K(ret));
-    } else if (OB_FAIL(append(ctx_->equal_param_constraints_, equal_ctx.equal_param_info_))) {
-      LOG_WARN("failed to append equal param info", K(ret));
-    } else {
-      trans_happended = true;
-      expr_infos.at(i).is_used_ = true;
-      LOG_TRACE("succeed to replace when_expr with true", KPC(when_expr));
-    }
-  }
-  return ret;
-}
-
 int ObTransformConstPropagate::replace_internal(ObRawExpr *&cur_expr,
                                                 ObIArray<ObRawExpr *> &parent_exprs,
                                                 ObIArray<ExprConstInfo> &expr_const_infos,
@@ -2024,24 +1743,6 @@ int ObTransformConstPropagate::is_parent_null_side(ObDMLStmt *&parent_stmt,
   return ret;
 }
 
-int ObTransformConstPropagate::collect_equal_param_constraints(ObIArray<ExprInfo> &expr_infos)
-{
-  int ret = OB_SUCCESS;
-  if (OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("invalid stmt", K(ret));
-  }
-  for (int64_t i = 0; OB_SUCC(ret) && i < expr_infos.count(); ++i) {
-    if (!expr_infos.at(i).is_used_) {
-      // do nothing
-    } else if (OB_FAIL(append(ctx_->equal_param_constraints_,
-                              expr_infos.at(i).equal_infos_))) {
-      LOG_WARN("failed to append equal param constraint", K(ret));
-    }
-  }
-  return ret;
-}
-
 int ObTransformConstPropagate::collect_equal_param_constraints(ObIArray<ExprConstInfo> &expr_const_infos)
 {
   int ret = OB_SUCCESS;
@@ -2093,13 +1794,9 @@ int ObTransformConstPropagate::recursive_collect_equal_pair_from_condition(ObDML
                                                                            bool &trans_happened)
 {
   int ret = OB_SUCCESS;
-  ExprInfo expr_info;
   if (OB_ISNULL(stmt) || OB_ISNULL(expr)) {
     ret = OB_ERR_UNEXPECTED;
     LOG_WARN("get unexpected null", K(ret), K(stmt), K(expr));
-  } else if (OB_FALSE_IT(expr_info.expr_ = expr)) {
-  } else if (OB_FAIL(const_ctx.add_expr_info(expr_info))) {
-    LOG_WARN("failed to push back active expr infos", K(ret));
   } else if (T_OP_EQ == expr->get_expr_type()) {
     // todo: support general expr const info instead of column expr
     ObRawExpr *param_1 = expr->get_param_expr(0);
@@ -2144,7 +1841,7 @@ int ObTransformConstPropagate::recursive_collect_equal_pair_from_condition(ObDML
       if (OB_FAIL(SMART_CALL(recursive_collect_equal_pair_from_condition(stmt,
                                                                          expr->get_param_expr(i),
                                                                          const_ctx,
-                                                                         is_happened)))) { /* bugfix(fhkong) */
+                                                                         trans_happened)))) {
         LOG_WARN("failed to recursive collect const info from condition", K(ret));
       } else {
         trans_happened |= is_happened;
@@ -2200,8 +1897,7 @@ int ObTransformConstPropagate::recursive_collect_equal_pair_from_condition(ObDML
                                                                          tmp_ctx,
                                                                          child_happened)))) {
         LOG_WARN("failed to recursive collect const info from condition", K(ret));
-      } else if (OB_FAIL(replace_expr_internal(stmt,
-                                               expr->get_param_expr(i),
+      } else if (OB_FAIL(replace_expr_internal(expr->get_param_expr(i),
                                                tmp_ctx,
                                                current_happened))) {
         LOG_WARN("failed to replace expr", K(ret));
@@ -2809,7 +2505,7 @@ int ObTransformConstPropagate::collect_from_pullup_const_infos(ObDMLStmt *stmt,
   return ret;
 }
 
-int ObTransformConstPropagate::replace_select_exprs_skip_agg(ObDMLStmt *stmt,
+int ObTransformConstPropagate::replace_select_exprs_skip_agg(ObSelectStmt *stmt,
                                                     ConstInfoContext &const_ctx,
                                                     bool &trans_happened)
 {
@@ -2819,27 +2515,24 @@ int ObTransformConstPropagate::replace_select_exprs_skip_agg(ObDMLStmt *stmt,
   if (OB_ISNULL(stmt)) {
     ret = OB_ERR_UNEXPECTED;
     LOG_WARN("invalid parameter", K(ret));
-  } else if (!stmt->is_select_stmt()) {
-  } else {
-    ObSelectStmt *select_stmt = static_cast<ObSelectStmt *>(stmt);
-    for (int64_t i = 0; OB_SUCC(ret) && i < select_stmt->get_select_items().count(); ++i) {
-      ObRawExpr *&cur_expr = select_stmt->get_select_items().at(i).expr_;
-      parent_exprs.reuse();
-      bool internal_trans_happened = false;
-      if (OB_ISNULL(cur_expr)) {
-        ret = OB_ERR_UNEXPECTED;
-        LOG_WARN("invalid parameter", K(ret));
-      } else if (cur_expr->is_column_ref_expr()) {
-        //do nothing, const infos have been pulluped befored collect having const infos
-      } else if (OB_FAIL(replace_select_exprs_skip_agg_internal(cur_expr,
-                                                            const_ctx,
-                                                            parent_exprs,
-                                                            internal_trans_happened,
-                                                            false))) {
-        LOG_WARN("failed to replace select exprs based on equal_pair", K(ret));
-      } else {
-        trans_happened |= internal_trans_happened;
-      }
+  }
+  for (int64_t i = 0; OB_SUCC(ret) && i < stmt->get_select_items().count(); ++i) {
+    ObRawExpr *&cur_expr = stmt->get_select_items().at(i).expr_;
+    parent_exprs.reuse();
+    bool internal_trans_happened = false;
+    if (OB_ISNULL(cur_expr)) {
+      ret = OB_ERR_UNEXPECTED;
+      LOG_WARN("invalid parameter", K(ret));
+    } else if (cur_expr->is_column_ref_expr()) {
+      //do nothing, const infos have been pulluped befored collect having const infos
+    } else if (OB_FAIL(replace_select_exprs_skip_agg_internal(cur_expr,
+                                                          const_ctx,
+                                                          parent_exprs,
+                                                          internal_trans_happened,
+                                                          false))) {
+      LOG_WARN("failed to replace select exprs based on equal_pair", K(ret));
+    } else {
+      trans_happened |= internal_trans_happened;
     }
   }
   return ret;
diff --git a/src/sql/rewrite/ob_transform_const_propagate.h b/src/sql/rewrite/ob_transform_const_propagate.h
index 806f762..947361b 100644
--- a/src/sql/rewrite/ob_transform_const_propagate.h
+++ b/src/sql/rewrite/ob_transform_const_propagate.h
@@ -89,33 +89,11 @@ private:
                  K_(multi_need_add_constraints));
   };
 
-  /* add(fhkong): record expr in expression propagation */
-  struct ExprInfo {
-    ExprInfo() :
-      expr_(NULL),
-      is_used_(false),
-      equal_infos_()
-      { }
-
-    virtual ~ExprInfo() { }
-
-    ObRawExpr* expr_;
-    bool is_used_;
-    common::ObSEArray<ObPCParamEqualInfo, 2> equal_infos_;
-
-    TO_STRING_KV(K_(expr),
-                 K_(equal_infos),
-                 K_(is_used));
-  };
-
   struct ConstInfoContext {
     ConstInfoContext(const ObSharedExprChecker &shared_expr_checker,
                      bool hint_allowed_trans) : active_const_infos_(),
                          expired_const_infos_(),
                          extra_excluded_exprs_(),
-                         active_expr_infos_(),
-                         expired_expr_infos_(),
-                         true_expr_(NULL),
                          hint_allowed_trans_(hint_allowed_trans),
                          shared_expr_checker_(shared_expr_checker)
     {
@@ -124,28 +102,19 @@ private:
 
     int add_const_infos(ObIArray<ExprConstInfo> &const_infos);
     int add_const_info(ExprConstInfo &const_info);
-    int add_expr_info(ExprInfo &expr_info);
     int merge_expired_const_infos(ConstInfoContext &other, bool is_null_side);
     int find_exclude_expr(const ObRawExpr *expr, bool &found);
     int expire_const_infos();
-    bool active_empty();
 
     common::ObSEArray<ExprConstInfo, 4> active_const_infos_;
     common::ObSEArray<ExprConstInfo, 4> expired_const_infos_;
     common::ObSEArray<ObRawExpr *, 4> extra_excluded_exprs_;
-    /* add(fhkong): collect expr infos */
-    common::ObSEArray<ExprInfo, 4> active_expr_infos_;
-    common::ObSEArray<ExprInfo, 4> expired_expr_infos_;
-    ObRawExpr *true_expr_;
-
     bool hint_allowed_trans_;
     const ObSharedExprChecker &shared_expr_checker_;
 
     TO_STRING_KV(K_(active_const_infos),
                  K_(expired_const_infos),
                  K_(extra_excluded_exprs),
-                 K_(active_expr_infos),
-                 K_(expired_expr_infos),
                  K_(hint_allowed_trans));
   };
 
@@ -170,34 +139,30 @@ private:
                  K_(need_add_constraint));
   };
 
-  int replace_with_true_expr(ObRawExpr *&expr, ConstInfoContext &const_ctx);
-
   int recursive_collect_const_info_from_table(ObDMLStmt *stmt,
                                               TableItem *table_item,
                                               ConstInfoContext &const_ctx,
                                               bool is_null_side,
                                               bool &trans_happened);
 
-  int replace_common_exprs(ObDMLStmt *stmt,
-                           ObIArray<ObRawExpr *> &exprs,
+  int replace_common_exprs(ObIArray<ObRawExpr *> &exprs,
                            ConstInfoContext &const_ctx,
                            bool &trans_happened,
                            bool used_in_compare = true);
 
-  int replace_group_exprs(ObDMLStmt *stmt,
+  int replace_group_exprs(ObSelectStmt *stmt,
                           ConstInfoContext &const_ctx,
                           bool ignore_all_select_exprs,
                           bool &trans_happened);
 
-  int replace_orderby_exprs(ObDMLStmt *stmt,
-                            ObIArray<OrderItem> &order_items,
+  int replace_orderby_exprs(ObIArray<OrderItem> &order_items,
                             ConstInfoContext &const_ctx,
                             bool &trans_happened);
 
-  int replace_select_exprs(ObDMLStmt *stmt,
+  int replace_select_exprs(ObSelectStmt *stmt,
                            ConstInfoContext &const_ctx,
                            bool &trans_happened);
-  int replace_select_exprs_skip_agg(ObDMLStmt *stmt,
+  int replace_select_exprs_skip_agg(ObSelectStmt *stmt,
                                   ConstInfoContext &const_ctx,
                                   bool &trans_happened);
   int replace_select_exprs_skip_agg_internal(ObRawExpr *&cur_expr,
@@ -206,8 +171,7 @@ private:
                                           bool &trans_happened,
                                           bool used_in_compare);
 
-  int replace_assignment_exprs(ObDMLStmt *stmt,
-                               ObIArray<ObAssignment> &assignments,
+  int replace_assignment_exprs(ObIArray<ObAssignment> &assignments,
                                ConstInfoContext &const_ctx,
                                bool &trans_happened);
 
@@ -278,13 +242,11 @@ private:
                           const ObExprResType &dst_type,
                           bool &is_safe);
 
-  int recursive_replace_join_conditions(ObDMLStmt *stmt,
-                                        TableItem *table_item,
+  int recursive_replace_join_conditions(TableItem *table_item,
                                         ConstInfoContext &const_ctx,
                                         bool &trans_happened);
 
-  int replace_expr_internal(ObDMLStmt *stmt,
-                            ObRawExpr *&cur_expr,
+  int replace_expr_internal(ObRawExpr *&cur_expr,
                             ConstInfoContext &const_ctx,
                             bool &trans_happened,
                             bool used_in_compare = true);
@@ -301,24 +263,6 @@ private:
                        bool used_in_compare,
                        bool &trans_happened);
 
-  int recursive_replace_case_when_expr(ObDMLStmt *stmt,
-                                       ObRawExpr *&cur_expr, 
-                                       ConstInfoContext &const_ctx, 
-                                       bool &trans_happened);
-
-  int replace_case_when_internal(ObDMLStmt *stmt,
-                                 ObRawExpr *&cur_expr,
-                                 ConstInfoContext &const_ctx,
-                                 bool &trans_happened);
-
-  int recursive_replace_when_expr_internal(
-                                 ObDMLStmt *stmt,
-                                 ObRawExpr *&when_expr, 
-                                 ConstInfoContext &const_ctx, 
-                                 bool &trans_happened);
-
-  int replace_when_expr_internal(ObDMLStmt *stmt, ObRawExpr *&expr, ConstInfoContext &const_ctx, bool &trans_happended);
-
   int prepare_new_expr(ExprConstInfo &const_info);
 
   int check_set_op_expr_const(ObSelectStmt *stmt,
@@ -346,7 +290,6 @@ private:
   int check_is_in_or_notin_param(ObIArray<ObRawExpr *> &parent_exprs, bool &is_right_param);
 
   int collect_equal_param_constraints(ObIArray<ExprConstInfo> &expr_const_infos);
-  int collect_equal_param_constraints(ObIArray<ExprInfo> &expr_const_infos);
 
   int recursive_collect_equal_pair_from_condition(ObDMLStmt *stmt,
                                                   ObRawExpr *expr,
@@ -364,7 +307,7 @@ private:
                                      ConstInfoContext &const_ctx,
                                      bool &trans_happened);
 
-int check_constraint_expr_validity(ObRawExpr *check_constraint_expr,
+  int check_constraint_expr_validity(ObRawExpr *check_constraint_expr,
                                      const ObIArray<ObDMLStmt::PartExprItem> &part_items,
                                      ObIArray<ExprConstInfo> &expr_const_infos,
                                      ObRawExpr *&part_column_expr,
diff --git a/src/sql/rewrite/ob_transform_simplify_expr.cpp b/src/sql/rewrite/ob_transform_simplify_expr.cpp
index c4555da..a386691 100644
--- a/src/sql/rewrite/ob_transform_simplify_expr.cpp
+++ b/src/sql/rewrite/ob_transform_simplify_expr.cpp
@@ -112,15 +112,6 @@ int ObTransformSimplifyExpr::transform_one_stmt(common::ObIArray<ObParentDMLStmt
       LOG_TRACE("succeed to remove subquery when filter is false", K(is_happened));
     }
   }
-  if (OB_SUCC(ret)) {
-    if (OB_FAIL(convert_case_when_predicate(stmt, is_happened))) {
-      LOG_WARN("failed to convert case when predicate", K(ret));
-    } else {
-      trans_happened |= is_happened;
-      OPT_TRACE("convert case when predicate", is_happened);
-      LOG_TRACE("succeed to convert case when predicate", K(is_happened));
-    }
-  }
   if (OB_SUCC(ret) && trans_happened) {
     if (OB_FAIL(add_transform_hint(*stmt))) {
       LOG_WARN("failed to add transform hint", K(ret));
@@ -2527,653 +2518,4 @@ int ObTransformSimplifyExpr::try_remove_ora_decode(ObRawExpr *&expr,
     }
   }
   return ret;
-}
-
-/***
- * EXPLANATION:
- * Rewrite case_when predicate recursively for all relation exprs
- * Focus on two transformer format:
- *
- * 1. According to when exprs (Priori false/null exprs can be removed)
-    expr = case when 2 > 3 then c1
-                when 2 > 1 then c2
-                else c3
-           end > 1;
-    ==> expr = c2 > 1
- * 2. According to then exprs (at most one true/null/uncalc then expr)
-    expr = case when c1 > 1 then 1
-                when c2 > 1 then 2
-                else c3
-           end > 2;
-    ==> 
-    expr = lnnvl(c1 > 1) and lnnvl(c2 > 1) and c3 > 2
- **/
-int ObTransformSimplifyExpr::convert_case_when_predicate(ObDMLStmt *stmt, 
-                                                         bool &trans_happened) {
-  int ret = OB_SUCCESS;
-  trans_happened = false;
-  bool is_happened = false;
-  bool is_scala_group_by = false;
-  if (OB_ISNULL(stmt)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("stmt is NULL", K(ret));
-  } else {
-    ObStmtExprGetter visitor;
-    visitor.set_relation_scope();
-    ObSEArray<ObRawExprPointer, 8> relation_exprs;
-    is_scala_group_by = stmt->is_select_stmt() && static_cast<ObSelectStmt *>(stmt)->is_scala_group_by(); 
-    if (OB_FAIL(stmt->get_relation_exprs(relation_exprs, visitor))) {
-      LOG_WARN("failed to get relation exprs", K(ret));
-    } else {
-      for (int64_t i = 0; OB_SUCC(ret) && i < relation_exprs.count(); ++i) {
-        ObRawExpr *expr = NULL;
-        if (OB_FAIL(relation_exprs.at(i).get(expr))) {
-          LOG_WARN("failed to get expr",K(ret));
-        } else if (OB_FAIL(convert_case_when_predicate_by_then_expr(expr, is_scala_group_by, is_happened))) {
-          LOG_WARN("failed to convert case when predicate", K(ret));
-        } else if (OB_FAIL(convert_case_when_predicate_by_when_expr(expr, is_scala_group_by, is_happened))) {
-          LOG_WARN("failed to convert case when predicate", K(ret));
-        } else if (OB_FAIL(relation_exprs.at(i).set(expr))) {
-          LOG_WARN("failed to set expr", K(ret));
-        } else {
-          trans_happened |= is_happened;
-        }
-      }
-    }
-  }
-  return ret;
-}
-
-
-/**
- * @brief convert case when predicate according to then exprs at the parent expr
-       OR convert case when predicate according to when exprs at the case expr
- * @param[in][out] expr: current expr 
- * @param[in] is_sacla_group_by: this stmt is scala group by or not
- * @param[in][out] trans_happened: whether rewrite is happened
- */
-int ObTransformSimplifyExpr::convert_case_when_predicate_by_when_expr(
-                                    ObRawExpr *&expr,
-                                    const bool is_scala_group_by,
-                                    bool &trans_happened) 
-{
-  int ret = OB_SUCCESS;
-  trans_happened = false;
-  bool is_happened = false;
-  if (OB_ISNULL(expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected null", K(expr), K(ret));
-  } else if (T_OP_CASE == expr->get_expr_type()) {
-    if (is_scala_group_by && expr->has_flag(CNT_AGG)) {
-      /* do nothing for scala group by */
-    } else if (OB_FAIL(inner_convert_case_when_predicate_by_when_expr(expr, is_happened))) {
-      LOG_WARN("failed to inner convert case when expr", K(ret));
-    } else {
-      trans_happened |= is_happened;
-    }
-  } else { /* do nothing */}
-
-  for (int64_t i = 0; OB_SUCC(ret) && i < expr->get_param_count(); ++i) {
-    if (OB_FAIL(SMART_CALL(convert_case_when_predicate_by_when_expr(expr->get_param_expr(i), 
-                                                       is_scala_group_by, 
-                                                       is_happened)))) {
-      LOG_WARN("failed to call convert func recursively", K(ret));
-    } else {
-      trans_happened |= is_happened;
-    }
-  }
-  return ret;
-}
-
-/**
- * @brief inner convert the case when predicate of expr
- * @param[in][out] expr: case when expr
- * @param[in][out] trans_happened: whether convert is happened
- * @discription: according to the results of when exprs
- *  1. cond1 ... cond(k-1) is FALSE/NULL
- *  2. condk is TRUE/UNCALCULABLE
- *    2.1 if condk is TRUE, then rewrite case_expr to exprk
- *    2.2 if condk is UNCALCULABLE, then remove cond1...cond(k-1)
- *    2.3 if k > when_cnt, then rewrite case_expr to default_expr
- */
-int ObTransformSimplifyExpr::inner_convert_case_when_predicate_by_when_expr(
-                                                      ObRawExpr *&expr, 
-                                                      bool &trans_happened) {
-  int ret = OB_SUCCESS;
-
-  trans_happened = false;
-  ObCaseOpRawExpr *case_expr = NULL;
-
-  bool has_null = false; // check cond1 to cond(k-1) has null expr or not
-  int64_t first_true_non_calc_idx = -1; // record the index of first true or non_calc expr
-  ObSEArray<ObRawExpr*, 2> false_null_exprs; // used to add constraints
-
-  if (OB_ISNULL(expr) || OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("param is NULL", K(ret));
-  } else if (T_OP_CASE != expr->get_expr_type()) {
-  } else if (OB_FALSE_IT(case_expr = static_cast<ObCaseOpRawExpr *>(expr))) {
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() != case_expr->get_then_expr_size())) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect case when params", K(ret));
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() < 1)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("case when size is less than 1", K(ret));
-  } else {
-    int64_t idx = 0; // first non false idx
-    bool is_blocked = false;
-    ObRawExpr *rewrite_expr = NULL;
-    const int64_t when_cnt = case_expr->get_when_expr_size();
-
-    for (idx = 0; OB_SUCC(ret) && idx < when_cnt; ++idx) {
-      if (OB_FAIL(check_when_expr_validity(case_expr, idx, rewrite_expr, is_blocked))) {
-        LOG_WARN("failed to check when exprs", K(ret));
-      } else if (is_blocked) {
-        break;
-      }
-    }
-    if (OB_FAIL(ret)) {
-    } else if (OB_UNLIKELY(idx < 0 || idx > when_cnt)) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("index is out of range", K(ret), K(ret), K(when_cnt));
-    } else if (idx == when_cnt && 
-               OB_ISNULL(rewrite_expr = case_expr->get_default_param_expr())) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected default expr is NULL", K(ret));
-    } else if (OB_ISNULL(rewrite_expr)) {
-      if (OB_LIKELY(idx == 0)) {
-      } else if (OB_FAIL(assign_array_at_idx(case_expr->get_when_param_exprs(), idx))) {
-        LOG_WARN("failed to assign when exprs from idx", K(ret), K(idx));
-      } else if (OB_FAIL(assign_array_at_idx(case_expr->get_then_param_exprs(), idx))) {
-        LOG_WARN("failed to assign then exprs from idx", K(ret), K(idx));
-      } else if (OB_FAIL(case_expr->formalize(ctx_->session_info_))) {
-        LOG_WARN("failed to formalize expr", K(ret), KPC(case_expr));
-      } else {
-        trans_happened = true;
-      }
-    } else {
-      expr = rewrite_expr;
-      trans_happened = true;
-    }
-  }
-  return ret;
-}
-
-int ObTransformSimplifyExpr::check_when_expr_validity(
-                                      ObCaseOpRawExpr *case_expr,
-                                      const int64_t idx,
-                                      ObRawExpr *&rewrite_expr,
-                                      bool &is_blocked) {
-  int ret = OB_SUCCESS;
-  rewrite_expr = NULL;
-  is_blocked = false;
-  ObRawExpr *when_expr = NULL;
-  if (OB_ISNULL(case_expr) || OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL", K(ret));
-  } else if (OB_UNLIKELY(idx < 0 || idx > case_expr->get_when_expr_size())) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("index is out of range", K(ret), K(idx));
-  } else if (OB_ISNULL(when_expr = case_expr->get_when_param_expr(idx))) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL", K(ret));
-  } else if (when_expr->is_static_scalar_const_expr()) {
-    ObObj result;
-    bool got_result = false;
-    if (OB_FAIL(ObSQLUtils::calc_const_or_calculable_expr(ctx_->exec_ctx_,
-                                                          when_expr,
-                                                          result,
-                                                          got_result,
-                                                          *ctx_->allocator_))) {
-      LOG_WARN("failed to calc const or calculable expr", K(ret), K(*when_expr));
-    } else if (got_result && (result.is_true() || result.is_false() || result.is_null())) {
-      if (result.is_true()) {
-        if (OB_ISNULL(rewrite_expr = case_expr->get_then_param_expr(idx))) {
-          ret = OB_ERR_UNEXPECTED;
-          LOG_WARN("unexpected then expr is NULL", K(ret));
-        } else {
-          ObExprConstraint true_cons{when_expr, PreCalcExprExpectResult::PRE_CALC_RESULT_TRUE};
-          if (OB_FAIL(ctx_->expr_constraints_.push_back(true_cons))) {
-            LOG_WARN("failed to push back expr constraints", K(ret));
-          }
-        }
-        is_blocked = true;
-      } else {
-        ObRawExpr *nvl_false_expr = NULL;
-        if (OB_FAIL(build_nvl_bool_expr(when_expr, false, nvl_false_expr))) {
-          LOG_WARN("failed to build nvl bool expr", K(ret));
-        } else if (OB_ISNULL(nvl_false_expr)) {
-          ret = OB_ERR_UNEXPECTED;
-          LOG_WARN("unexpected nvl_false_expr is NULL", K(ret));
-        } else {
-          ObExprConstraint false_cons {nvl_false_expr, PreCalcExprExpectResult::PRE_CALC_RESULT_FALSE};
-          if (OB_FAIL(ctx_->expr_constraints_.push_back(false_cons))) {
-            LOG_WARN("failed to push back expr constraints", K(ret));
-          } 
-        }
-      }
-    } else {
-      LOG_TRACE("The result of when_expr is not in {true, false, null}");
-      is_blocked = true;
-    }
-  } else {
-    is_blocked = true;
-  }
-  return ret;
-}
-
-
-int ObTransformSimplifyExpr::convert_case_when_predicate_by_then_expr(
-                                    ObRawExpr *&expr,
-                                    const bool is_scala_group_by,
-                                    bool &trans_happened) 
-{
-  int ret = OB_SUCCESS;
-  trans_happened = false;
-  bool is_happened = false;
-  if (OB_ISNULL(expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected null", K(expr), K(ret));
-  } else if (IS_COMMON_COMPARISON_OP(expr->get_expr_type())) {
-    ObRawExpr *child_0 = NULL;
-    ObRawExpr *child_1 = NULL;
-    ObOpRawExpr *op_expr = static_cast<ObOpRawExpr*>(expr);
-    if (OB_UNLIKELY(2 != op_expr->get_param_count())) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected param count", K(op_expr->get_param_count()), K(ret));
-    } else if (OB_ISNULL(child_0 = op_expr->get_param_expr(0)) 
-            || OB_ISNULL(child_1 = op_expr->get_param_expr(1))) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected null expr", K(ret));
-    } else {
-      bool is_case_at_left = false;
-      bool is_case_cmp_const = false;
-      ObRawExpr *case_expr = NULL;
-      ObRawExpr *sibling_expr = NULL;
-      if ((T_OP_CASE == child_0->get_expr_type()) 
-          && child_1->is_static_const_expr()) {
-        is_case_at_left = true;
-        is_case_cmp_const = true;
-        case_expr = child_0;
-        sibling_expr = child_1;
-      } else if ((T_OP_CASE == child_1->get_expr_type())
-                && child_0->is_static_const_expr()) {
-        is_case_at_left = false;
-        is_case_cmp_const = true;
-        case_expr = child_1;
-        sibling_expr = child_0;
-      } else { /* do nothing */}
-
-      if (OB_SUCC(ret) && is_case_cmp_const) {
-        if (is_scala_group_by && case_expr->has_flag(CNT_AGG)) {
-          /* do nothing for scala group by */
-        } else if (OB_FAIL(do_convert_case_when_predicate_by_then_expr(
-                                                expr,
-                                                case_expr,
-                                                sibling_expr,
-                                                is_case_at_left,
-                                                is_happened))) {
-          LOG_WARN("failed to convert case when predicate", K(ret));
-        } else {
-          trans_happened |= is_happened;
-        }
-      }
-    }
-  } else { /* do nothing */}
-
-  return ret;
-}
-
-
-// IF case_at_left is true, parent_expr := case_when_expr op sibling_expr 
-// IF case_at_left is false, parent_expr := sibling_expr op case_when_expr
-int ObTransformSimplifyExpr::do_convert_case_when_predicate_by_then_expr(
-                                   ObRawExpr *&parent_expr,
-                                   ObRawExpr *&case_when_expr,
-                                   ObRawExpr *&sibling_expr,
-                                   const bool case_at_left,
-                                   bool &trans_happened) 
-{
-  int ret = OB_SUCCESS;
-  trans_happened = false;
-  ObCaseOpRawExpr *case_expr = NULL;
-  ObRawExpr *rewrite_expr = NULL;
-  if (OB_ISNULL(parent_expr) || OB_ISNULL(case_when_expr) || 
-      OB_ISNULL(sibling_expr) || OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param null", K(ret));
-  } else if (OB_UNLIKELY(T_OP_CASE != case_when_expr->get_expr_type())) {
-    /* do nothing */
-  } else if (OB_FALSE_IT(case_expr = static_cast<ObCaseOpRawExpr *>(case_when_expr))) {
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() != case_expr->get_then_expr_size())) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect param of case when", K(ret), K(case_expr->get_when_expr_size()), 
-                                                     K(case_expr->get_then_expr_size()));
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() < 1)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect param of case when", K(ret), K(case_expr->get_when_expr_size()));
-  } else {
-    bool is_valid = false; // Only at most one {true, uncalc} is allowed.
-    bool is_true = false; // Check expr is true or not
-    int64_t true_uncalc_idx = -1;  // The index of non-false expr
-    ObRawExpr* true_uncalc_expr = NULL; // The expr of non-false expr
-    ObSEArray<ObRawExpr*, 4> false_null_exprs;  
-    if (OB_FAIL(check_then_exprs_validity(
-                                        parent_expr, case_expr, 
-                                        sibling_expr, case_at_left, 
-                                        is_true,
-                                        true_uncalc_idx, 
-                                        true_uncalc_expr, 
-                                        false_null_exprs, 
-                                        is_valid))) {
-      LOG_WARN("failed to check convert case when validity", K(ret));
-    } else if (!is_valid) {
-      /* do nothing */
-    } else if (OB_FAIL(add_constraint_for_convert_case_when(
-                                                      false_null_exprs,
-                                                      is_true,
-                                                      true_uncalc_expr))) {
-      LOG_WARN("failed to add false and true constraint", K(ret));
-    } else if (OB_FAIL(build_rewrite_expr(
-                                  case_expr,
-                                  true_uncalc_idx,
-                                  true_uncalc_expr,
-                                  rewrite_expr))) { 
-      LOG_WARN("failed to build rewrite_expr", K(ret));
-    } else {
-      parent_expr = rewrite_expr;
-      trans_happened = true;
-    }
-  }
-  return ret;
-}
-
-/***
- * check one case when can be rewrite or not 
- * Rewrite Condition:
- *  1. Let enum_exprs = then_exprs + default_expr
- *  2. At most one of enum_exprs is in {true, null, non_static}, others are all false (cmp sibling_expr)
- *    2.1 The result of them cmp sibling_expr are all false, ==> false
- *    2.2 Only one of them is {true, null, non_static}, record its index
- *  3. Otherwise, is_valid = false
-*/ 
-int ObTransformSimplifyExpr::check_then_exprs_validity(
-                                      ObRawExpr *&parent_expr,
-                                      ObCaseOpRawExpr *&case_expr,
-                                      ObRawExpr *&sibling_expr,
-                                      const bool case_at_left,
-                                      bool &is_true,
-                                      int64_t &true_uncalc_idx,
-                                      ObRawExpr *&true_uncalc_expr,
-                                      ObIArray<ObRawExpr*> &false_null_exprs,
-                                      bool &is_valid) {
-  int ret = OB_SUCCESS;
-
-  is_true = false;
-  true_uncalc_idx = -1;
-  true_uncalc_expr = NULL;
-  false_null_exprs.reset();
-  is_valid = false;
-  if (OB_ISNULL(parent_expr) || OB_ISNULL(case_expr) || OB_ISNULL(sibling_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL", K(ret));
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() != case_expr->get_then_expr_size())) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect params of case expr", K(ret));
-  } else if (OB_UNLIKELY(case_expr->get_when_expr_size() < 1)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("incorrect params of case expr", K(ret));
-  } else {
-    const int64_t when_cnt = case_expr->get_when_expr_size();
-    ObSEArray<ObRawExpr*, 4> enum_exprs; // includes then_exprs and default_expr
-    if (OB_FAIL(enum_exprs.assign(case_expr->get_then_param_exprs()))) {
-      LOG_WARN("failed to assign enum exprs", K(ret));
-    } else if (OB_FAIL(enum_exprs.push_back(case_expr->get_default_param_expr()))) {
-      LOG_WARN("failed to push back enum exprs", K(ret));
-    } else {
-    // check enum_exprs cmp sibling_expr is valid or not
-      int64_t static_const_cnt = 0;
-      int64_t uncalc_idx = -1;
-      // do pre check 
-      for (int64_t i = 0; OB_SUCC(ret) && i < enum_exprs.count(); ++i) {
-        ObRawExpr * expr = NULL;
-        if (OB_ISNULL(expr = enum_exprs.at(i))) { 
-          ret = OB_ERR_UNEXPECTED;
-          LOG_WARN("expr is NULL", K(ret), K(expr));
-        } else if (expr->is_static_const_expr()) { // static const expr, i.e. "abc", 1, 2, NULL
-          static_const_cnt += 1;
-        } else {
-          uncalc_idx = i;
-        }
-      }
-      // only one non-static-const expr is allowed. 
-      if (OB_SUCC(ret) && static_const_cnt + 1 >= enum_exprs.count()) {
-        int64_t false_null_expr_cnt = 0;
-        int64_t other_expr_cnt = 0; // The types of {true, null, non_static}
-        for (int64_t i = 0; OB_SUCC(ret) && other_expr_cnt < 2 && i < enum_exprs.count(); ++i) {
-          ObRawExpr *expr = NULL;
-          ObRawExpr *new_expr = NULL;
-          if (OB_ISNULL(expr = enum_exprs.at(i))) {
-            ret = OB_ERR_UNEXPECTED;
-            LOG_WARN("expr is NULL", K(ret), K(expr));
-          } else if (OB_FAIL(ObRawExprUtils::create_double_op_expr(
-                                              *(ctx_->expr_factory_), 
-                                              ctx_->session_info_,
-                                              parent_expr->get_expr_type(),
-                                              new_expr,
-                                              case_at_left ? expr : sibling_expr,
-                                              case_at_left ? sibling_expr : expr))) {
-              LOG_WARN("failed to build cmp expr", K(ret));
-          } else if (new_expr->is_static_const_expr()) {
-            bool got_result = false;
-            ObObj result;
-            if (OB_FAIL(ObSQLUtils::calc_const_or_calculable_expr(
-                                                    ctx_->exec_ctx_,
-                                                    new_expr,
-                                                    result,
-                                                    got_result,
-                                                    *ctx_->allocator_))) {
-              LOG_WARN("failed to calc cosnt or calculable expr", K(ret));
-            } else if (got_result && (result.is_true() || result.is_false() 
-                                                       || result.is_null())) {
-              if (result.is_false() || result.is_null()) {
-                false_null_expr_cnt += 1;
-                if (OB_FAIL(false_null_exprs.push_back(new_expr))) {
-                  LOG_WARN("failed to push back to false exprs", K(ret));
-                }
-              } else {
-                other_expr_cnt += 1;
-                is_true = true;
-                true_uncalc_idx = i;
-                true_uncalc_expr = new_expr;
-              }
-            } else { break; }
-          } else { // non-static-const expr
-            other_expr_cnt += 1;
-            true_uncalc_idx = i;
-            true_uncalc_expr = new_expr;
-          }
-        }
-        if (OB_SUCC(ret)) {
-          is_valid |= false_null_expr_cnt == when_cnt && 1 == other_expr_cnt;
-          is_valid |= false_null_expr_cnt == when_cnt + 1 && 0 == other_expr_cnt;
-        }
-      } /* endif collect false_exprs */
-    } /* endif check enum_exprs */
-  } /* endif check validity */
-  return ret;
-}
-
-int ObTransformSimplifyExpr::build_rewrite_expr(
-                    ObCaseOpRawExpr *case_expr,
-                    const int64_t true_uncalc_idx,
-                    ObRawExpr *true_uncalc_expr,
-                    ObRawExpr *&rewrite_expr) {
-  int ret = OB_SUCCESS;
-  rewrite_expr = NULL;
-  if (OB_ISNULL(case_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected case_expr is NULL", K(ret));
-  } else if (-1 == true_uncalc_idx) {
-    // build rewrite_expr to false
-    if (OB_FAIL(ObRawExprUtils::build_const_bool_expr(ctx_->expr_factory_, 
-                                                        rewrite_expr, false))) {
-      LOG_WARN("failed to build const bool expr", K(ret));
-    }
-  } else {
-    // rewrite case_when_expr with lnnvl(...)
-    if (OB_UNLIKELY(true_uncalc_idx > case_expr->get_then_expr_size() ||
-                        OB_ISNULL(true_uncalc_expr))) {
-      ret = OB_ERR_UNEXPECTED;
-      LOG_WARN("unexpected params", K(ret));
-    } else {
-      ObSEArray<ObRawExpr*, 4> build_exprs;
-      for (int64_t i = 0; OB_SUCC(ret) && i < true_uncalc_idx; ++i) {
-        ObRawExpr *when_expr = NULL;
-        ObRawExpr *lnnvl_when_expr = NULL;
-        if (OB_ISNULL(when_expr = case_expr->get_when_param_expr(i))) {
-          ret = OB_ERR_UNEXPECTED;
-          LOG_WARN("unexpected when is NULL", K(ret));
-        } else if (OB_FAIL(ObRawExprUtils::build_lnnvl_expr(*(ctx_->expr_factory_), 
-                                                            when_expr,
-                                                            lnnvl_when_expr))) {
-          LOG_WARN("failed to build lnnvl expr", K(ret));
-        } else if (OB_FAIL(build_exprs.push_back(lnnvl_when_expr))) {
-          LOG_WARN("failed to push back build_exprs", K(ret));
-        }
-      }
-      // push back condk, if k != n
-      if (OB_SUCC(ret) && true_uncalc_idx < case_expr->get_then_expr_size()) {
-        ObRawExpr *when_expr = NULL;
-        if (OB_ISNULL(when_expr = case_expr->get_when_param_expr(true_uncalc_idx))) {
-          ret = OB_ERR_UNEXPECTED;
-          LOG_WARN("unexpected when is NULL", K(ret));
-        } else if (OB_FAIL(build_exprs.push_back(when_expr))) {
-          LOG_WARN("failed to push back build_exprs", K(ret));
-        }
-      }
-      // push back true_null_non_static expr
-      // build rewrite_expr to lnnvl(cond1) and ... and lnnvl(condk-1) and condk and exprk
-      if (OB_FAIL(ret)) {
-      } else if (OB_FAIL(build_exprs.push_back(true_uncalc_expr))) {
-        LOG_WARN("failed to push back build_exprs", K(ret));
-      } else if (OB_FAIL(ObRawExprUtils::build_and_expr(*ctx_->expr_factory_, 
-                                                        build_exprs, rewrite_expr))) {
-        LOG_WARN("failed to build and exprs", K(ret));
-      } else if (OB_ISNULL(rewrite_expr)) {
-        ret = OB_ERR_UNEXPECTED;
-        LOG_WARN("unexpected param is NULL", K(ret));
-      } else if (OB_FAIL(rewrite_expr->formalize(ctx_->session_info_))) {
-        LOG_WARN("failed to formalize expr", K(ret));
-      }
-    }
-  } /* endif build rewrite_expr */
-  return ret;
-}
-
-// add false and true constraint for convert case when expr, if it is needed.
-// 1. false_exprs.count() > 0
-// 2. true_expr != NULL 
-int ObTransformSimplifyExpr::add_constraint_for_convert_case_when(
-                              ObIArray<ObRawExpr *> &false_null_exprs,
-                              const bool need_add_true_cons,
-                              ObRawExpr *true_expr) {
-  int ret = OB_SUCCESS;
-  ObRawExpr *false_cons_expr = NULL;
-  if (OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL",K(ret));
-  } else if (need_add_true_cons && OB_ISNULL(true_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL",K(ret));
-  } else if (OB_FAIL(build_nvl_bool_exprs(false_null_exprs, false))) {
-    LOG_WARN("failed to build nvl bool exprs",K(ret));
-  } else if (OB_FAIL(ObRawExprUtils::build_or_exprs(
-                                          *ctx_->expr_factory_, 
-                                          false_null_exprs, 
-                                          false_cons_expr))) {
-    LOG_WARN("failed to build or expr", K(ret));
-  } else if (OB_ISNULL(false_cons_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected null expr", K(ret));
-  } else if (OB_FAIL(false_cons_expr->formalize(ctx_->session_info_))) {
-    LOG_WARN("failed to formalize expr", K(ret), K(false_cons_expr));
-  } else {
-    ObExprConstraint false_cons{false_cons_expr, PreCalcExprExpectResult::PRE_CALC_RESULT_FALSE};
-    if (OB_FAIL(ctx_->expr_constraints_.push_back(false_cons))) {
-      LOG_WARN("failed to push back constraints");
-    }
-  }
-  if (OB_FAIL(ret)) {
-  } else if (OB_LIKELY(!need_add_true_cons)) {
-  } else {
-    ObExprConstraint true_cons {true_expr, PreCalcExprExpectResult::PRE_CALC_RESULT_TRUE};
-    if (OB_FAIL(ctx_->expr_constraints_.push_back(true_cons))) {
-      LOG_WARN("failed to push back expr constraints", K(ret));
-    }
-  }
-  return ret;
-}
-
-int ObTransformSimplifyExpr::assign_array_at_idx(ObIArray<ObRawExpr *> &exprs, 
-                                                 const int64_t idx) {
-  int ret = OB_SUCCESS;
-  ObSEArray<ObRawExpr *, 2> arr;
-  for (int64_t i = idx; OB_SUCC(ret) && i < exprs.count(); ++i) {
-    if (OB_FAIL(arr.push_back(exprs.at(i)))) {
-      LOG_WARN("failed to push back expr", K(ret));
-    }
-  }
-  if (OB_FAIL(ret)) {
-  } else if (OB_FAIL(exprs.assign(arr))) {
-    LOG_WARN("failed to assign exprs", K(ret));
-  }
-  return ret;
-}
-
-int ObTransformSimplifyExpr::build_nvl_bool_exprs(ObIArray<ObRawExpr*> &exprs, 
-                                            const bool boolean) {
-  int ret = OB_SUCCESS;
-  ObRawExpr *nvl_bool_expr = NULL;
-  ObSEArray<ObRawExpr *, 4> tmp_exprs;
-  for (int64_t i = 0; OB_SUCC(ret) && i < exprs.count(); ++i) {
-    if (OB_FAIL(build_nvl_bool_expr(exprs.at(i), boolean, nvl_bool_expr))) {
-      LOG_WARN("failed to build nvl bool expr", K(ret));
-    } else if (OB_FAIL(tmp_exprs.push_back(nvl_bool_expr))) {
-      LOG_WARN("failed to push back nvl bool expr", K(ret));
-    }
-  }
-  if (OB_FAIL(ret)) {
-  } else if (OB_FAIL(exprs.assign(tmp_exprs))) {
-    LOG_WARN("failed to assign exprs", K(ret));
-  }
-  return ret;
-}
-// IF is_true nvl_expr = nvl(expr, TRUE)
-// ELSE       nvl_expr = nvl(expr, FALSE)
-int ObTransformSimplifyExpr::build_nvl_bool_expr(ObRawExpr *expr, 
-                                            const bool is_true,
-                                            ObRawExpr *&nvl_expr) {
-  int ret = OB_SUCCESS;
-  ObRawExpr *true_false_expr = NULL;
-  nvl_expr = NULL;
-  if (OB_ISNULL(expr) || OB_ISNULL(ctx_)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected param is NULL", K(ret));
-  } else if (OB_FAIL(ObRawExprUtils::build_const_bool_expr(
-                                    ctx_->expr_factory_, 
-                                    true_false_expr, is_true))) {
-    LOG_WARN("failed to build const bool expr", K(ret));
-  } else if (OB_FAIL(ObRawExprUtils::build_nvl_expr(*ctx_->expr_factory_,
-                                                    expr, 
-                                                    true_false_expr,
-                                                    nvl_expr))) {
-    LOG_WARN("failed to build nvl expr", K(ret));
-  } else if (OB_ISNULL(nvl_expr)) {
-    ret = OB_ERR_UNEXPECTED;
-    LOG_WARN("unexpected nvl expr is NULL", K(ret));
-  } else if (OB_FAIL(nvl_expr->formalize(ctx_->session_info_))) {
-    LOG_WARN("failed to formalize nvl expr", K(ret));
-  }
-  return ret;
-}
+}
\ No newline at end of file
diff --git a/src/sql/rewrite/ob_transform_simplify_expr.h b/src/sql/rewrite/ob_transform_simplify_expr.h
index 103cff9..08155d2 100644
--- a/src/sql/rewrite/ob_transform_simplify_expr.h
+++ b/src/sql/rewrite/ob_transform_simplify_expr.h
@@ -164,52 +164,8 @@ private:
                               ObIArray<ObRawExpr *> &new_exprs);
   int check_remove_ora_decode_valid(ObRawExpr *&expr, int64_t &result_idx, bool &is_valid);
   int try_remove_ora_decode(ObRawExpr *&expr, ObRawExpr *&new_expr);
-
-  int convert_case_when_predicate(ObDMLStmt *stmt, bool &trans_happened);
-  int convert_case_when_predicate_by_when_expr(ObRawExpr *&expr, 
-                                  const bool is_scala_group_by,
-                                  bool &trans_happened);
-  int inner_convert_case_when_predicate_by_when_expr(
-                                      ObRawExpr *&expr, 
-                                      bool &trans_happened);
-  int check_when_expr_validity(
-                  ObCaseOpRawExpr *case_expr,
-                  const int64_t idx,
-                  ObRawExpr *&rewrite_expr,
-                  bool &is_blocked);
-
-  int convert_case_when_predicate_by_then_expr(ObRawExpr *&expr, 
-                                  const bool is_scala_group_by,
-                                  bool &trans_happened);
-  int do_convert_case_when_predicate_by_then_expr(
-                                      ObRawExpr *&parent_expr,
-                                      ObRawExpr *&case_expr,
-                                      ObRawExpr *&sibling_expr,
-                                      const bool case_at_left,
-                                      bool &trans_happened);
-  int check_then_exprs_validity(
-                            ObRawExpr *&parent_expr,
-                            ObCaseOpRawExpr *&case_expr,
-                            ObRawExpr *&sibling_expr,
-                            const bool case_at_left,
-                            bool &is_uncalculable,
-                            int64_t &true_null_uncalc_idx,
-                            ObRawExpr *&true_null_uncalc_expr,
-                            ObIArray<ObRawExpr*> &false_exprs,
-                            bool &is_valid);
-  int build_rewrite_expr(ObCaseOpRawExpr *case_expr,
-                         const int64_t true_null_uncalc_idx,
-                         ObRawExpr *true_null_uncalc_expr,
-                         ObRawExpr *&rewrite_expr);
-  int add_constraint_for_convert_case_when(
-                                ObIArray<ObRawExpr *> &false_null_exprs,
-                                const bool need_add_true_cons,
-                                ObRawExpr *true_expr);
-  
-  int assign_array_at_idx(ObIArray<ObRawExpr *> &exprs, const int64_t idx);
-  int build_nvl_bool_exprs(ObIArray<ObRawExpr *> &exprs, const bool boolean);
-  int build_nvl_bool_expr(ObRawExpr *expr, const bool boolean, ObRawExpr *&nvl_expr);
 };
+
 }
 }
 
diff --git a/tools/deploy/mysql_test/test_suite/transformer/r/mysql/transformer_convert_case_when_predicate.result b/tools/deploy/mysql_test/test_suite/transformer/r/mysql/transformer_convert_case_when_predicate.result
deleted file mode 100644
index 3eaa1d6..0000000
--- a/tools/deploy/mysql_test/test_suite/transformer/r/mysql/transformer_convert_case_when_predicate.result
+++ /dev/null
@@ -1,3647 +0,0 @@
-result_format: 4
-explain_protocol: 2
-DROP DATABASE IF EXISTS DB_CONVERT_CASE_WHEN;
-CREATE DATABASE DB_CONVERT_CASE_WHEN;
-USE DB_CONVERT_CASE_WHEN;
-
-drop table if exists t1, t2, t3;
-create table t1(c1 int, c2 int, c3 int, c4 int, c5 int, c6 int);
-create table t2(c1 int, c2 int, c3 int);
-create table t3(c1 int, c2 varchar(64), c3 varchar(64));
-
-insert/*trace*/ into t1 values(1,1,1,1,1,1), (2,2,2,2,2,2), (3,3,3,3,3,3), (4,4,4,4,4,4), (5,5,5,5,5,5);
-insert/*trace*/ into t2 values(NULL, NULL, NULL);
-insert/*trace*/ into t3 values(1, "aaa", "is_aaa"), (2, "bbb", "is_bbb"), (3, "ccc", "is_ccc"), (4, "ddd", "is_ddd");
-
-drop table if exists is_c1;
-create table is_c1(c1 int);
-
-set ob_enable_plan_cache = 0;
-
-**************************** basic test **************************** 
-
-== case 1
-EXPLAIN select /*+no_rewrite*/* from (select /*+no_rewrite*/* from t2 where case when 1 is NULL then c1 else c2 end > 1);
-Query Plan
-============================================================
-|ID|OPERATOR         |NAME           |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
-|0 |SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
-|1 |??TABLE FULL SCAN|t2             |1       |4           |
-============================================================
-Outputs & filters:
--------------------------------------
-  0 - output([.c1], [.c2], [.c3]), filter(nil), rowset=256
-      access([.c1], [.c2], [.c3])
-  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN 1 IS NULL THEN t2.c1 ELSE t2.c2 END > 1]), rowset=256
-      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/* from (select /*+no_rewrite*/* from t2 where case when 1 is NULL then c1 else c2 end > 1);
-+------+------+------+
-| c1   | c2   | c3   |
-+------+------+------+
-+------+------+------+
-EXPLAIN select * from (select * from t2 where case when 1 is NULL then c1 else c2 end > 1);
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t2  |1       |4           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 1]), rowset=256
-      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
-select * from (select * from t2 where case when 1 is NULL then c1 else c2 end > 1);
-+------+------+------+
-| c1   | c2   | c3   |
-+------+------+------+
-+------+------+------+
-
-
-== case 2
-EXPLAIN select /*+no_rewrite*/* from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa";
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t3  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([CASE WHEN t3.c1 > 0 THEN 'aaa' ELSE 'bbb' END = 'aaa']), rowset=256
-      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/* from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa";
-+------+------+--------+
-| c1   | c2   | c3     |
-+------+------+--------+
-|    1 | aaa  | is_aaa |
-|    2 | bbb  | is_bbb |
-|    3 | ccc  | is_ccc |
-|    4 | ddd  | is_ddd |
-+------+------+--------+
-EXPLAIN select * from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa";
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t3  |1       |4           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 > 0 AND 'aaa' = 'aaa']), rowset=256
-      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-select * from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa";
-+------+------+--------+
-| c1   | c2   | c3     |
-+------+------+--------+
-|    1 | aaa  | is_aaa |
-|    2 | bbb  | is_bbb |
-|    3 | ccc  | is_ccc |
-|    4 | ddd  | is_ddd |
-+------+------+--------+
-
-
-== case 3
-EXPLAIN select /*+no_rewrite*/* from t3 where case when c1 > 0 then "aaa" else "bbb" end = "ccc";
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t3  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([CASE WHEN t3.c1 > 0 THEN 'aaa' ELSE 'bbb' END = 'ccc']), rowset=256
-      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/* from t3 where case when c1 > 0 then "aaa" else "bbb" end = "ccc";
-+------+------+------+
-| c1   | c2   | c3   |
-+------+------+------+
-+------+------+------+
-EXPLAIN select * from t3 where case when c1 > 0 then "aaa" else "bbb" end = "ccc";
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t3  |4       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), startup_filter([0]), rowset=256
-      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-select * from t3 where case when c1 > 0 then "aaa" else "bbb" end = "ccc";
-+------+------+------+
-| c1   | c2   | c3   |
-+------+------+------+
-+------+------+------+
-
-
-== case 4 set union
-EXPLAIN select /*+no_rewrite*/ * from ((select /*+no_rewrite*/ c1 from t1 where case when 1 > 2 then c1 else c2 end > 1) 
-                         union (select /*+no_rewrite*/ c1 from t3 where case when c1 > 0 then 1 else 2 end > 1)) as tmp;
-Query Plan
-=====================================================
-|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------
-|0 |SUBPLAN SCAN         |tmp |3       |9           |
-|1 |??HASH UNION DISTINCT|    |3       |9           |
-|2 |  ??TABLE FULL SCAN  |t1  |2       |5           |
-|3 |  ??TABLE FULL SCAN  |t3  |2       |4           |
-=====================================================
-Outputs & filters:
--------------------------------------
-  0 - output([tmp.c1]), filter(nil), rowset=256
-      access([tmp.c1])
-  1 - output([UNION([1])]), filter(nil), rowset=256
-  2 - output([t1.c1]), filter([CASE WHEN 1 > 2 THEN t1.c1 ELSE t1.c2 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  3 - output([t3.c1]), filter([CASE WHEN t3.c1 > 0 THEN 1 ELSE 2 END > 1]), rowset=256
-      access([t3.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from ((select /*+no_rewrite*/ c1 from t1 where case when 1 > 2 then c1 else c2 end > 1) 
-                         union (select /*+no_rewrite*/ c1 from t3 where case when c1 > 0 then 1 else 2 end > 1)) as tmp;
-+------+
-| c1   |
-+------+
-|    2 |
-|    3 |
-|    4 |
-|    5 |
-+------+
-EXPLAIN select * from ((select c1 from t1 where case when 1 > 2 then c1 else c2 end > 1) 
-         union (select c1 from t3 where case when c1 > 0 then 1 else 2 end > 1)) as tmp;
-Query Plan
-===================================================
-|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
-|0 |HASH UNION DISTINCT|    |3       |9           |
-|1 |??TABLE FULL SCAN  |t1  |1       |5           |
-|2 |??TABLE FULL SCAN  |t3  |2       |4           |
-===================================================
-Outputs & filters:
--------------------------------------
-  0 - output([UNION([1])]), filter(nil), rowset=256
-  1 - output([t1.c1]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  2 - output([t3.c1]), filter([lnnvl(cast(t3.c1 > 0, TINYINT(-1, 0)))]), rowset=256
-      access([t3.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-select * from ((select c1 from t1 where case when 1 > 2 then c1 else c2 end > 1) 
-         union (select c1 from t3 where case when c1 > 0 then 1 else 2 end > 1)) as tmp;
-+------+
-| c1   |
-+------+
-|    2 |
-|    3 |
-|    4 |
-|    5 |
-+------+
-
-**************************** convert when exprs test **************************** 
-
-== case 1
-EXPLAIN select /*+no_rewrite*/ * from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 > 0], [CASE WHEN 2 > 1 THEN t1.c1 ELSE t1.c2 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 > 0], [t1.c1 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-
-== case 2
-EXPLAIN select /*+no_rewrite*/ case when 2 > 1 then c1 else c2 end from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([CASE WHEN 2 > 1 THEN t1.c1 ELSE t1.c2 END]), filter([t1.c1 > 0], [CASE WHEN 2 > 1 THEN t1.c1 ELSE t1.c2 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ case when 2 > 1 then c1 else c2 end from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-+-------------------------------------+
-| case when 2 > 1 then c1 else c2 end |
-+-------------------------------------+
-|                                   2 |
-|                                   3 |
-|                                   4 |
-|                                   5 |
-+-------------------------------------+
-EXPLAIN select case when 2 > 1 then c1 else c2 end from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1]), filter([t1.c1 > 0], [t1.c1 > 1]), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select case when 2 > 1 then c1 else c2 end from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-+-------------------------------------+
-| case when 2 > 1 then c1 else c2 end |
-+-------------------------------------+
-|                                   2 |
-|                                   3 |
-|                                   4 |
-|                                   5 |
-+-------------------------------------+
-
-
-== case 3
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when c1 > c2 then c1 else c2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN t1.c1 > t1.c2 THEN t1.c1 ELSE t1.c2 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when c1 > c2 then c1 else c2 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when c1 > c2 then c1 else c2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN t1.c1 > t1.c2 THEN t1.c1 ELSE t1.c2 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when c1 > c2 then c1 else c2 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 4
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when 2 > 2 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 2 > 2 THEN t1.c1 WHEN 1 > 2 THEN 2 WHEN 2 < 3 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when 2 > 2 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when 2 > 2 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when 2 > 2 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 5
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when 2 > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 2 > 1 THEN t1.c1 WHEN 1 > 2 THEN 2 WHEN 2 < 3 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when 2 > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when 2 > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c1 > 1]), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when 2 > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-== case 6
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when NULL > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN NULL > 1 THEN t1.c1 WHEN 1 > 2 THEN 2 WHEN 2 < 3 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when NULL > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when NULL > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when NULL > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 7
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when c1 > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN t1.c1 > 1 THEN t1.c1 WHEN 1 > 2 THEN 2 WHEN 2 < 3 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when c1 > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when c1 > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN t1.c1 > 1 THEN t1.c1 WHEN 1 > 2 THEN 2 WHEN 2 < 3 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when c1 > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 8
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when 1 > 1 then c1 
-                                            else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 1 THEN t1.c1 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when 1 > 1 then c1 
-                                            else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when 1 > 1 then c1 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c3 > 1]), rowset=256
-      access([t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when 1 > 1 then c1 else c3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 9
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when 1 < 2 then 1 
-                            when 2 > 3 then 2 
-                            when 3 > 2 then c1
-                            when c2 > 0 then c2
-                            else c3
-                        end > 2;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN 1 < 2 THEN 1 WHEN 2 > 3 THEN 2 WHEN 3 > 2 THEN t1.c1 WHEN t1.c2 > 
-      0 THEN t1.c2 ELSE t1.c3 END > 2]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when 1 < 2 then 1 
-                            when 2 > 3 then 2 
-                            when 3 > 2 then c1
-                            when c2 > 0 then c2
-                            else c3
-                        end > 2;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when 1 < 2 then 1 
-                            when 2 > 3 then 2 
-                            when 3 > 2 then c1
-                            when c2 > 0 then c2
-                            else c3
-                        end > 2;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 < 2 then 1 
-                            when 2 > 3 then 2 
-                            when 3 > 2 then c1
-                            when c2 > 0 then c2
-                            else c3
-                        end > 2;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-
-== case 10: with scala group by
-EXPLAIN select /*+no_rewrite*/ 1 from t1 having case when 1 > 1 then count(*) 
-                                             else 3 end > 1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |4           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) ELSE 3 END > 1]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access(nil), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 having case when 1 > 1 then count(*) 
-                                             else 3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-+---+
-EXPLAIN select 1 from t1 having case when 1 > 1 then count(*) 
-                        else 3 end > 1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |4           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) ELSE 3 END > 1]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access(nil), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 having case when 1 > 1 then count(*) 
-                        else 3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-+---+
-
-
-== case 11: with scala group by
-EXPLAIN select /*+no_rewrite*/ case when 1 then 2 else count(*) end from t1 
-                        where c1 > 0 and case when 1 >= 1 then c1 else c2 end > 0
-                        having case when 1 > 1 then count(*) else 3 end > 1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([CASE WHEN 1 THEN 2 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END]), filter([CASE WHEN 1 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) ELSE 3 END > 1]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter([t1.c1 > 0], [CASE WHEN 1 >= 1 THEN t1.c1 ELSE t1.c2 END > 0]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ case when 1 then 2 else count(*) end from t1 
-                        where c1 > 0 and case when 1 >= 1 then c1 else c2 end > 0
-                        having case when 1 > 1 then count(*) else 3 end > 1;
-+--------------------------------------+
-| case when 1 then 2 else count(*) end |
-+--------------------------------------+
-|                                    2 |
-+--------------------------------------+
-EXPLAIN select case when 1 then 2 else count(*) end from t1 
-                        where c1 > 0 and case when 1 >= 1 then c1 else c2 end > 0
-                        having case when 1 > 1 then count(*) else 3 end > 1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([CASE WHEN 1 THEN 2 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END]), filter([CASE WHEN 1 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) ELSE 3 END > 1]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter([t1.c1 > 0]), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select case when 1 then 2 else count(*) end from t1 
-                        where c1 > 0 and case when 1 >= 1 then c1 else c2 end > 0
-                        having case when 1 > 1 then count(*) else 3 end > 1;
-+--------------------------------------+
-| case when 1 then 2 else count(*) end |
-+--------------------------------------+
-|                                    2 |
-+--------------------------------------+
-
-
-== case 12: with scala group by
-EXPLAIN select /*+no_rewrite*/ 1 from t1 having case when 1 > 1 then count(*) 
-                                             when 2 > 1 then 2
-                                             else 3 end > 1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |4           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) WHEN 2 > 1 THEN 2 ELSE 3 END > 1]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access(nil), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 having case when 1 > 1 then count(*) 
-                                             when 2 > 1 then 2
-                                             else 3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-+---+
-EXPLAIN select 1 from t1 having case when 1 > 1 then count(*) 
-                                             when 2 > 1 then 2
-                                             else 3 end > 1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |4           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) WHEN 2 > 1 THEN 2 ELSE 3 END > 1]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access(nil), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 having case when 1 > 1 then count(*) 
-                                             when 2 > 1 then 2
-                                             else 3 end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-+---+
-
-
-== case 13: with shared expr 
-EXPLAIN select /*+no_rewrite*/ case when 2 > 1 then c1 else c2 end from t1 where 
-                                    case when 2 > 1 then c1 
-                                         else c2 
-                                    end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([CASE WHEN 2 > 1 THEN t1.c1 ELSE t1.c2 END]), filter([CASE WHEN 2 > 1 THEN t1.c1 ELSE t1.c2 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ case when 2 > 1 then c1 else c2 end from t1 where 
-                                    case when 2 > 1 then c1 
-                                         else c2 
-                                    end > 1;
-+-------------------------------------+
-| case when 2 > 1 then c1 else c2 end |
-+-------------------------------------+
-|                                   2 |
-|                                   3 |
-|                                   4 |
-|                                   5 |
-+-------------------------------------+
-EXPLAIN select case when 2 > 1 then c1 else c2 end from t1 where 
-                                    case when 2 > 1 then c1 
-                                         else c2 
-                                    end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1]), filter([t1.c1 > 1]), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select case when 2 > 1 then c1 else c2 end from t1 where 
-                                    case when 2 > 1 then c1 
-                                         else c2 
-                                    end > 1;
-+-------------------------------------+
-| case when 2 > 1 then c1 else c2 end |
-+-------------------------------------+
-|                                   2 |
-|                                   3 |
-|                                   4 |
-|                                   5 |
-+-------------------------------------+
-
-
-== case 14: with subquery 
-EXPLAIN select /*+no_rewrite*/1 from t1 where c1 > 0 and c2 in (
-    select /*+no_rewrite*/c2 from t2 where 
-    case when 0 > 1 then c1
-         when 1 > 2 then c2
-         else c3
-    end > 0
-) and c3 > 0;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SUBPLAN FILTER   |    |1       |9           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-|2 |??TABLE FULL SCAN|t2  |1       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c2 = ANY(subquery(1))]), rowset=256
-      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
-  1 - output([t1.c2]), filter([t1.c1 > 0], [t1.c3 > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  2 - output([t2.c2]), filter([CASE WHEN 0 > 1 THEN t2.c1 WHEN 1 > 2 THEN t2.c2 ELSE t2.c3 END > 0]), rowset=256
-      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/1 from t1 where c1 > 0 and c2 in (
-    select /*+no_rewrite*/c2 from t2 where 
-    case when 0 > 1 then c1
-         when 1 > 2 then c2
-         else c3
-    end > 0
-) and c3 > 0;
-+---+
-| 1 |
-+---+
-+---+
-
-EXPLAIN select 1 from t1 where c1 > 0 and c2 in (
-    select c2 from t2 where 
-    case when 0 > 1 then c1
-         when 1 > 2 then c2
-         else c3
-    end > 0
-) and c3 > 0;
-Query Plan
-====================================================
-|ID|OPERATOR           |NAME |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
-|0 |HASH SEMI JOIN     |     |1       |8           |
-|1 |??TABLE FULL SCAN  |t1   |1       |5           |
-|2 |??SUBPLAN SCAN     |VIEW1|1       |4           |
-|3 |  ??TABLE FULL SCAN|t2   |1       |4           |
-====================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter(nil), rowset=256
-      equal_conds([t1.c2 = VIEW1.c2]), other_conds(nil)
-  1 - output([t1.c2]), filter([t1.c1 > 0], [t1.c3 > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  2 - output([VIEW1.c2]), filter(nil), rowset=256
-      access([VIEW1.c2])
-  3 - output([t2.c2]), filter([t2.c3 > 0]), rowset=256
-      access([t2.c2], [t2.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where c1 > 0 and c2 in (
-    select c2 from t2 where 
-    case when 0 > 1 then c1
-         when 1 > 2 then c2
-         else c3
-    end > 0
-) and c3 > 0;
-+---+
-| 1 |
-+---+
-+---+
-
-
-== case 15: with subquery with scala group by
-EXPLAIN select /*+no_rewrite*/1 from t1 where c1 > 0 and c2 in (
-    select /*+no_rewrite*/c2 from t2 having 
-    case when 0 > 1 then count(*) 
-         when 1 > 2 then 2
-         else 2 
-    end > 0
-) and c3 > 0;
-Query Plan
-===================================================
-|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
-|0 |SUBPLAN FILTER     |    |1       |8           |
-|1 |??TABLE FULL SCAN  |t1  |1       |5           |
-|2 |??SCALAR GROUP BY  |    |1       |4           |
-|3 |  ??TABLE FULL SCAN|t2  |1       |4           |
-===================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c2 = ANY(subquery(1))]), rowset=256
-      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
-  1 - output([t1.c2]), filter([t1.c1 > 0], [t1.c3 > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  2 - output([t2.c2]), filter([CASE WHEN 0 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) WHEN 1 > 2 THEN 2 ELSE 2 END > 0]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  3 - output([t2.c2], [T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access([t2.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/1 from t1 where c1 > 0 and c2 in (
-    select /*+no_rewrite*/c2 from t2 having 
-    case when 0 > 1 then count(*) 
-         when 1 > 2 then 2
-         else 2 
-    end > 0
-) and c3 > 0;
-+---+
-| 1 |
-+---+
-+---+
-
-EXPLAIN select 1 from t1 where c1 > 0 and c2 in (
-    select c2 from t2 having 
-    case when 0 > 1 then count(*) 
-         when 1 > 2 then 2
-         else 2 
-    end > 0
-) and c3 > 0;
-Query Plan
-======================================================
-|ID|OPERATOR             |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
-|0 |NESTED-LOOP JOIN     |     |1       |5           |
-|1 |??SUBPLAN SCAN       |VIEW1|1       |4           |
-|2 |? ??SCALAR GROUP BY  |     |1       |4           |
-|3 |?   ??TABLE FULL SCAN|t2   |1       |4           |
-|4 |??TABLE FULL SCAN    |t1   |1       |5           |
-======================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter(nil), rowset=256
-      conds([t1.c2 = VIEW1.c2]), nl_params_(nil), use_batch=false
-  1 - output([VIEW1.c2]), filter(nil), rowset=256
-      access([VIEW1.c2])
-  2 - output([t2.c2]), filter([CASE WHEN 0 > 1 THEN T_FUN_COUNT_SUM(T_FUN_COUNT(*)) WHEN 1 > 2 THEN 2 ELSE 2 END > 0]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  3 - output([t2.c2], [T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access([t2.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
-  4 - output([t1.c2]), filter([t1.c1 > 0], [t1.c3 > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where c1 > 0 and c2 in (
-    select c2 from t2 having 
-    case when 0 > 1 then count(*) 
-         when 1 > 2 then 2
-         else 2 
-    end > 0
-) and c3 > 0;
-+---+
-| 1 |
-+---+
-+---+
-
-
-== case 16: with scalar static const expr 
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when 1 > 2 then c1
-                            when 2 in (1,2,3) then c2
-                            when c1 > 2 then c3 
-                            else c4 
-                        end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 2 THEN t1.c1 WHEN 2 IN (1, 2, 3) THEN t1.c2 WHEN t1.c1 > 2 THEN t1.c3 ELSE t1.c4 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when 1 > 2 then c1
-                            when 2 in (1,2,3) then c2
-                            when c1 > 2 then c3 
-                            else c4 
-                        end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when 1 > 2 then c1
-                            when 2 in (1,2,3) then c2
-                            when c1 > 2 then c3 
-                            else c4 
-                        end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when 1 > 2 then c1
-                            when 2 in (1,2,3) then c2
-                            when c1 > 2 then c3 
-                            else c4 
-                        end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 17: debug  
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where case when 1 > 2 then c1
-                            when 2 > 3 then c2
-                            when c1 > 2 then c3 
-                            when c2 > 2 then c4
-                            when c3 > 2 then c4
-                            else c4 
-                        end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 > 2 THEN t1.c1 WHEN 2 > 3 THEN t1.c2 WHEN t1.c1 > 2 THEN t1.c3 WHEN t1.c2 > 2 THEN t1.c4 WHEN t1.c3 > 2 THEN t1.c4 
-      ELSE t1.c4 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where case when 1 > 2 then c1
-                            when 2 > 3 then c2
-                            when c1 > 2 then c3 
-                            when c2 > 2 then c4
-                            when c3 > 2 then c4
-                            else c4 
-                        end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where case when 1 > 2 then c1
-                            when 2 > 3 then c2
-                            when c1 > 2 then c3 
-                            when c2 > 2 then c4
-                            when c3 > 2 then c4
-                            else c4 
-                        end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN t1.c1 > 2 THEN t1.c3 WHEN t1.c2 > 2 THEN t1.c4 WHEN t1.c3 > 2 THEN t1.c4 ELSE t1.c4 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where case when 1 > 2 then c1
-                            when 2 > 3 then c2
-                            when c1 > 2 then c3 
-                            when c2 > 2 then c4
-                            when c3 > 2 then c4
-                            else c4 
-                        end > 1;
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-set autocommit = 0;
-set autocommit = 0;
-
-== case 18: insert SQL 
-EXPLAIN insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when 2 > 2 then c1
-                                               when 2 > 1 then c2
-                                               else c3
-                                          end > 1;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |2       |22          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|2       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |2       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([CASE WHEN 2 > 2 THEN t1.c1 WHEN 2 > 1 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when 2 > 2 then c1
-                                               when 2 > 1 then c2
-                                               else c3
-                                          end > 1;
-EXPLAIN insert into is_c1 select c1 from t1 where case when 2 > 2 then c1
-                                               when 2 > 1 then c2
-                                               else c3
-                                          end > 1;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |1       |14          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |1       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select c1 from t1 where case when 2 > 2 then c1
-                                               when 2 > 1 then c2
-                                               else c3
-                                          end > 1;
-EXPLAIN select * from is_c1;
-Query Plan
-================================================
-|ID|OPERATOR       |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------
-|0 |TABLE FULL SCAN|is_c1|8       |5           |
-================================================
-Outputs & filters:
--------------------------------------
-  0 - output([is_c1.c1]), filter(nil), rowset=256
-      access([is_c1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([is_c1.__pk_increment]), range(MIN ; MAX)always true
-select * from is_c1;
-+------+
-| c1   |
-+------+
-|    2 |
-|    3 |
-|    4 |
-|    5 |
-|    2 |
-|    3 |
-|    4 |
-|    5 |
-+------+
-rollback;
-
-
-== case 19: insert SQL 
-EXPLAIN insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when 1 > NULL then c1
-                                               when 2 > 2 then c2
-                                               else c3
-                                          end > 1;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |2       |22          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|2       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |2       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([CASE WHEN 1 > NULL THEN t1.c1 WHEN 2 > 2 THEN t1.c2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when 1 > NULL then c1
-                                               when 2 > 2 then c2
-                                               else c3
-                                          end > 1;
-EXPLAIN insert into is_c1 select c1 from t1 where case when 1 > NULL then c1
-                                               when 2 > 2 then c2
-                                               else c3
-                                          end > 1;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |1       |14          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |1       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([t1.c3 > 1]), rowset=256
-      access([t1.c1], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select c1 from t1 where case when 1 > NULL then c1
-                                               when 2 > 2 then c2
-                                               else c3
-                                          end > 1;
-EXPLAIN select * from is_c1;
-Query Plan
-================================================
-|ID|OPERATOR       |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------
-|0 |TABLE FULL SCAN|is_c1|8       |5           |
-================================================
-Outputs & filters:
--------------------------------------
-  0 - output([is_c1.c1]), filter(nil), rowset=256
-      access([is_c1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([is_c1.__pk_increment]), range(MIN ; MAX)always true
-select * from is_c1;
-+------+
-| c1   |
-+------+
-|    2 |
-|    3 |
-|    4 |
-|    5 |
-|    2 |
-|    3 |
-|    4 |
-|    5 |
-+------+
-rollback;
-
-
-== case 20: insert SQL 
-EXPLAIN insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                               else 3
-                                          end > 2;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |2       |22          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|2       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |2       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE 3 END > 2]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                               else 3
-                                          end > 2;
-EXPLAIN insert into is_c1 select c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                               else 3
-                                          end > 2;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |2       |19          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|2       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |2       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), lnnvl(cast(t1.c2 > 2, TINYINT(-1, 0))), 3 > 2)]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                               else 3
-                                          end > 2;
-EXPLAIN select * from is_c1;
-Query Plan
-================================================
-|ID|OPERATOR       |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------
-|0 |TABLE FULL SCAN|is_c1|2       |4           |
-================================================
-Outputs & filters:
--------------------------------------
-  0 - output([is_c1.c1]), filter(nil), rowset=256
-      access([is_c1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([is_c1.__pk_increment]), range(MIN ; MAX)always true
-select * from is_c1;
-+------+
-| c1   |
-+------+
-|    1 |
-|    1 |
-+------+
-rollback;
-
-
-== case 21: insert SQL 
-EXPLAIN insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                          end > 2;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |2       |22          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|2       |5           |
-|2 |  ??TABLE FULL SCAN|t1             |2       |5           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE NULL END > 2]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                          end > 2;
-EXPLAIN insert into is_c1 select c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                          end > 2;
-Query Plan
-==============================================================
-|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
-|0 |INSERT             |               |5       |43          |
-|1 |??SUBPLAN SCAN     |ANONYMOUS_VIEW1|5       |4           |
-|2 |  ??TABLE FULL SCAN|t1             |5       |4           |
-==============================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0), 
-      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)])
-  1 - output([ANONYMOUS_VIEW1.c1]), filter(nil), startup_filter([0]), rowset=256
-      access([ANONYMOUS_VIEW1.c1])
-  2 - output([t1.c1]), filter(nil), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-insert into is_c1 select c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                          end > 2;
-EXPLAIN select * from is_c1;
-Query Plan
-================================================
-|ID|OPERATOR       |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------
-|0 |TABLE FULL SCAN|is_c1|1       |4           |
-================================================
-Outputs & filters:
--------------------------------------
-  0 - output([is_c1.c1]), filter(nil), rowset=256
-      access([is_c1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([is_c1.__pk_increment]), range(MIN ; MAX)always true
-select * from is_c1;
-+------+
-| c1   |
-+------+
-+------+
-rollback;
-
-
-== case 22: update SQL 
-EXPLAIN update /*+no_rewrite*/ t1 set t1.c1 = t1.c1 + 1 where case when c1 > 1 then 1
-                                                           when c2 > 2 then 2
-                                                      end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |UPDATE           |    |2       |41          |
-|1 |??TABLE FULL SCAN|t1  |2       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6)})}]),
-      update([t1.c1=column_conv(INT,PS:(11,0),NULL,cast(t1.c1 + 1, INT(-1, 0)))])
-  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE NULL 
-      END > 2]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-update /*+no_rewrite*/ t1 set t1.c1 = t1.c1 + 1 where case when c1 > 1 then 1
-                                                           when c2 > 2 then 2
-                                                      end > 2;
-EXPLAIN update t1 set t1.c1 = t1.c1 + 1 where case when c1 > 1 then 1
-                                           when c2 > 2 then 2
-                                      end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |UPDATE           |    |5       |67          |
-|1 |??TABLE FULL SCAN|t1  |5       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6)})}]),
-      update([t1.c1=column_conv(INT,PS:(11,0),NULL,cast(t1.c1 + 1, INT(-1, 0)))])
-  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-update t1 set t1.c1 = t1.c1 + 1 where case when c1 > 1 then 1
-                                           when c2 > 2 then 2
-                                      end > 2;
-EXPLAIN select * from t1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-rollback;
-
-
-== case 23: update SQL 
-EXPLAIN update /*+no_rewrite*/ t1 set t1.c1 = t1.c1 + 1 where case when 1 > 1 then c1
-                                                           when 2 > 2 then c2
-                                                           else c3
-                                                      end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |UPDATE           |    |2       |42          |
-|1 |??TABLE FULL SCAN|t1  |2       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6)})}]),
-      update([t1.c1=column_conv(INT,PS:(11,0),NULL,cast(t1.c1 + 1, INT(-1, 0)))])
-  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN 1 > 1 THEN t1.c1 WHEN 2 > 2 THEN t1.c2 ELSE t1.c3 
-      END > 2]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-update /*+no_rewrite*/ t1 set t1.c1 = t1.c1 + 1 where case when 1 > 1 then c1
-                                                           when 2 > 2 then c2
-                                                           else c3
-                                                      end > 2;
-EXPLAIN update t1 set t1.c1 = t1.c1 + 1 where case when 1 > 1 then c1
-                                           when 2 > 2 then c2
-                                           else c3
-                                      end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |UPDATE           |    |1       |32          |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6)})}]),
-      update([t1.c1=column_conv(INT,PS:(11,0),NULL,cast(t1.c1 + 1, INT(-1, 0)))])
-  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c3 > 2]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-update t1 set t1.c1 = t1.c1 + 1 where case when 1 > 1 then c1
-                                           when 2 > 2 then c2
-                                           else c3
-                                      end > 2;
-EXPLAIN select * from t1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    5 |    3 |    3 |    3 |    3 |    3 |
-|    6 |    4 |    4 |    4 |    4 |    4 |
-|    7 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-rollback;
-
-EXPLAIN delete from t1 where c1 = (select /*+no_rewrite*/ c1 from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa" limit 1);
-Query Plan
-===================================================
-|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
-|0 |DELETE             |    |1       |20          |
-|1 |??SUBPLAN FILTER   |    |1       |9           |
-|2 |  ??TABLE FULL SCAN|t1  |1       |5           |
-|3 |  ??TABLE FULL SCAN|t3  |1       |5           |
-===================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6)})}])
-  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), rowset=256
-      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
-  2 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 = :0]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  3 - output([t3.c1]), filter([CASE WHEN t3.c1 > 0 THEN 'aaa' ELSE 'bbb' END = 'aaa']), rowset=256
-      access([t3.c1]), partitions(p0)
-      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-delete from t1 where c1 = (select /*+no_rewrite*/ c1 from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa" limit 1);
-EXPLAIN delete from t1 where c1 = (select c1 from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa" limit 1);
-Query Plan
-===================================================
-|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
-|0 |DELETE             |    |1       |20          |
-|1 |??SUBPLAN FILTER   |    |1       |9           |
-|2 |  ??TABLE FULL SCAN|t1  |1       |5           |
-|3 |  ??TABLE FULL SCAN|t3  |1       |4           |
-===================================================
-Outputs & filters:
--------------------------------------
-  0 - output(nil), filter(nil)
-      table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6)})}])
-  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), rowset=256
-      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
-  2 - output([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 = :0]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-  3 - output([t3.c1]), filter([t3.c1 > 0 AND 'aaa' = 'aaa']), rowset=256
-      access([t3.c1]), partitions(p0)
-      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
-delete from t1 where c1 = (select c1 from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa" limit 1);
-EXPLAIN select * from t1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-rollback;
-
-set autocommit = 1;
-
-**************************** convert then exprs test **************************** 
-
-== case 1
-EXPLAIN select /*+no_rewrite*/* from t1 where case when c1 > 0 then 0 else 1 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 0 ELSE 1 END > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/* from t1 where case when c1 > 0 then 0 else 1 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then 0 else 1 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |3       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([lnnvl(cast(t1.c1 > 0, TINYINT(-1, 0))) AND 1 > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 0 else 1 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-
-== case 2
-EXPLAIN select /*+no_rewrite*/* from t1 where case when c1 > 0 then 0 else 1 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 0 ELSE 1 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/* from t1 where case when c1 > 0 then 0 else 1 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then 0 else 1 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 0 else 1 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-
-== case 3
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 0 
-							when c2 > 0 then 0 
-							else 1 
-					   end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 0 WHEN t1.c2 > 0 THEN 0 ELSE 1 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 0 
-							when c2 > 0 then 0 
-							else 1 
-					   end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then 0 
-							when c2 > 0 then 0 
-							else 1 
-					   end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 0 
-							when c2 > 0 then 0 
-							else 1 
-					   end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-
-== case 4
-EXPLAIN select /*+no_rewrite*/ * from t1 where c1 > 0 and c2 > 0 and 
-                            case when c1 > 0 then 1 
-                                 when c2 > 0 then 2
-                                 else 0 
-                            end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 > 0], [t1.c2 > 0], [CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 ELSE 
-      0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where c1 > 0 and c2 > 0 and 
-                            case when c1 > 0 then 1 
-                                 when c2 > 0 then 2
-                                 else 0 
-                            end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where c1 > 0 and c2 > 0 and 
-                            case when c1 > 0 then 1 
-                                 when c2 > 0 then 2
-                                 else 0 
-                            end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 0, TINYINT(-1, 0))), t1.c2 > 0, 2 > 1)], [t1.c1 
-      > 0], [t1.c2 > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where c1 > 0 and c2 > 0 and 
-                            case when c1 > 0 then 1 
-                                 when c2 > 0 then 2
-                                 else 0 
-                            end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-
-== case 5
-EXPLAIN select /*+no_rewrite*/ * from t1 where c1 > 0 or (c2 > 0 and 
-                                case when c1 > 0 then 1 
-                                    when c2 > 0 then 2
-                                    else 0 
-                                end > 1);
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 > 0 OR t1.c2 > 0 AND CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 
-      ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where c1 > 0 or (c2 > 0 and 
-                                case when c1 > 0 then 1 
-                                    when c2 > 0 then 2
-                                    else 0 
-                                end > 1);
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where c1 > 0 or (c2 > 0 and 
-                                case when c1 > 0 then 1 
-                                    when c2 > 0 then 2
-                                    else 0 
-                                end > 1);
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c1 > 0 OR t1.c2 > 0 AND CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 
-      ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where c1 > 0 or (c2 > 0 and 
-                                case when c1 > 0 then 1 
-                                    when c2 > 0 then 2
-                                    else 0 
-                                end > 1);
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-
-== case 6: test with scala group by
-EXPLAIN select /*+no_rewrite*/ case when c1 > 0 then 1 else count(*) end > 2 from t1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([CASE WHEN t1.c1 > 0 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), filter(nil), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([t1.c1], [T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ case when c1 > 0 then 1 else count(*) end > 2 from t1;
-+-----------------------------------------------+
-| case when c1 > 0 then 1 else count(*) end > 2 |
-+-----------------------------------------------+
-|                                             0 |
-+-----------------------------------------------+
-EXPLAIN select case when c1 > 0 then 1 else count(*) end > 2 from t1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([CASE WHEN t1.c1 > 0 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), filter(nil), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([t1.c1], [T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access([t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select case when c1 > 0 then 1 else count(*) end > 2 from t1;
-+-----------------------------------------------+
-| case when c1 > 0 then 1 else count(*) end > 2 |
-+-----------------------------------------------+
-|                                             0 |
-+-----------------------------------------------+
-
-
-== case 7: test with scala group by
-EXPLAIN select /*+no_rewrite*/ c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 from t1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |5       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c2 > 0 AND CASE WHEN t1.c1 > 0 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), filter(nil), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([t1.c2], [t1.c1], [T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access([t1.c2], [t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 from t1;
-+----------------------------------------------------------+
-| c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 |
-+----------------------------------------------------------+
-|                                                        0 |
-+----------------------------------------------------------+
-EXPLAIN select c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 from t1;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |5       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c2 > 0 AND CASE WHEN t1.c1 > 0 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), filter(nil), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([t1.c2], [t1.c1], [T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access([t1.c2], [t1.c1]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 from t1;
-+----------------------------------------------------------+
-| c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 |
-+----------------------------------------------------------+
-|                                                        0 |
-+----------------------------------------------------------+
-
-
-== case 8: test with scala group by
-EXPLAIN select /*+no_rewrite*/ 1 from t1 having case when 1 then 1 else count(*) end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |4           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access(nil), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 having case when 1 then 1 else count(*) end > 2;
-+---+
-| 1 |
-+---+
-+---+
-EXPLAIN select 1 from t1 having case when 1 then 1 else count(*) end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |4           |
-|1 |??TABLE FULL SCAN|t1  |5       |4           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
-      access(nil), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 having case when 1 then 1 else count(*) end > 2;
-+---+
-| 1 |
-+---+
-+---+
-
-
-== case 9: test with scala group by
-EXPLAIN select 1 from t1 where c1 > 0 or (c2 > 0 and 
-                                    case when c1 > 0 then 1 
-                                        when c2 > 0 then 2
-                                        else 0 
-                                    end > 1)
-                    having case when 1 then 1 else count(*) end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter([t1.c1 > 0 OR t1.c2 > 0 AND CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where c1 > 0 or (c2 > 0 and 
-                                    case when c1 > 0 then 1 
-                                        when c2 > 0 then 2
-                                        else 0 
-                                    end > 1)
-                    having case when 1 then 1 else count(*) end > 2;
-+---+
-| 1 |
-+---+
-+---+
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where c1 > 0 or (c2 > 0 and 
-                                    case when c1 > 0 then 1 
-                                        when c2 > 0 then 2
-                                        else 0 
-                                    end > 1)
-                    having case when 1 then 1 else count(*) end > 2;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |SCALAR GROUP BY  |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN 1 THEN 1 ELSE T_FUN_COUNT_SUM(T_FUN_COUNT(*)) END > 2]), rowset=256
-      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
-  1 - output([T_FUN_COUNT(*)]), filter([t1.c1 > 0 OR t1.c2 > 0 AND CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where c1 > 0 or (c2 > 0 and 
-                                    case when c1 > 0 then 1 
-                                        when c2 > 0 then 2
-                                        else 0 
-                                    end > 1)
-                    having case when 1 then 1 else count(*) end > 2;
-+---+
-| 1 |
-+---+
-+---+
-
-
-== case 10: can't be rewrite 
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1 else 2 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 1 ELSE 2 END > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1 else 2 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then 1 else 2 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 1 ELSE 2 END > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 1 else 2 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-
-== case 11: can't be rewrite 
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1 
-                          	when c2 > 0 then 2
-                      	    when c3 > 0 then 3
-                          	else 4
-                       end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 WHEN t1.c3 > 0 THEN 3 ELSE 
-      4 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1 
-                          	when c2 > 0 then 2
-                      	    when c3 > 0 then 3
-                          	else 4
-                       end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then 1 
-                          	when c2 > 0 then 2
-                      	    when c3 > 0 then 3
-                          	else 4
-                       end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 WHEN t1.c3 > 0 THEN 3 ELSE 
-      4 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 1 
-                          	when c2 > 0 then 2
-                      	    when c3 > 0 then 3
-                          	else 4
-                       end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-== case 12: can't be rewrite 
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then c1 else c2 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN t1.c1 ELSE t1.c2 END > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then c1 else c2 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then c1 else c2 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN t1.c1 ELSE t1.c2 END > 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then c1 else c2 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-== case 13: can't be rewrite 
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then c1 
-                                when c2 > 0 then c2
-                                when c3 > 0 then 0
-                                else 0
-                            end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN t1.c1 WHEN t1.c2 > 0 THEN t1.c2 WHEN t1.c3 > 0 THEN 
-      0 ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then c1 
-                                when c2 > 0 then c2
-                                when c3 > 0 then 0
-                                else 0
-                            end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-EXPLAIN select * from t1 where case when c1 > 0 then c1 
-                          	when c2 > 0 then c2
-                      	    when c3 > 0 then 0
-                          	else 0
-                       end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN t1.c1 WHEN t1.c2 > 0 THEN t1.c2 WHEN t1.c3 > 0 THEN 
-      0 ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then c1 
-                          	when c2 > 0 then c2
-                      	    when c3 > 0 then 0
-                          	else 0
-                       end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-
-== case 13: can't be rewrite with NULL
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then null else 0 end = 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |4           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN NULL ELSE 0 END = 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then null else 0 end = 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then null else 0 end = 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |3       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([lnnvl(cast(t1.c1 > 0, TINYINT(-1, 0))) AND 0 = 0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then null else 0 end = 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-
-== case 13: can't be rewrite with NULL
-EXPLAIN select * from t1 where case when c1 > 0 then 1
-                            when c2 > 0 then 2
-                          	when c3 > 0 then 3
-                            else null
-                       end > 2;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 0, TINYINT(-1, 0))), lnnvl(cast(t1.c2 > 0, TINYINT(-1,
-       0))), t1.c3 > 0, 3 > 2)]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 1
-                            when c2 > 0 then 2
-                          	when c3 > 0 then 3
-                            else null
-                       end > 2;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1
-                            when c2 > 0 then 2
-                          	when c3 > 0 then 3
-                            else null
-                       end > 2;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 0 THEN 1 WHEN t1.c2 > 0 THEN 2 WHEN t1.c3 > 0 THEN 3 ELSE 
-      NULL END > 2]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1
-                            when c2 > 0 then 2
-                          	when c3 > 0 then 3
-                            else null
-                       end > 2;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-
-**************************** Joint when and then exprs test **************************** 
-
-== case 1 
-EXPLAIN select * from t1 where 
-	case when 1 > 2 then 1
-			 when 2 > 3 then 2
-		   when null then c1
-			 when c2 > 0 then c2
-  	   else 1
-	end > 2;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c2 > 0 AND t1.c2 > 2]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where 
-	case when 1 > 2 then 1
-			 when 2 > 3 then 2
-		   when null then c1
-			 when c2 > 0 then c2
-  	   else 1
-	end > 2;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select /*+no_rewrite*/ * from t1 where 
-	case when 1 > 2 then 1
-			 when 2 > 3 then 2
-		   when null then c1
-			 when c2 > 0 then c2
-  	   else 1
-	end > 2;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN 1 > 2 THEN 1 WHEN 2 > 3 THEN 2 WHEN cast(NULL, DOUBLE(-1, -1)) THEN 
-      t1.c1 WHEN t1.c2 > 0 THEN t1.c2 ELSE 1 END > 2]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where 
-	case when 1 > 2 then 1
-			 when 2 > 3 then 2
-		   when null then c1
-			 when c2 > 0 then c2
-  	   else 1
-	end > 2;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-
-
-== case 2
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5);
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c1 > 0], [t1.c2 > 0 OR CASE WHEN t1.c1 > t1.c2 THEN t1.c1 ELSE 3 END > 5]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5);
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-EXPLAIN select 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5);
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([t1.c1 > 0], [t1.c2 > 0 OR CASE WHEN t1.c1 > t1.c2 THEN t1.c1 ELSE 3 END > 5]), rowset=256
-      access([t1.c1], [t1.c2]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5);
-+---+
-| 1 |
-+---+
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-| 1 |
-+---+
-
-
-== case 3
-EXPLAIN select /*+no_rewrite*/ 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5) 
-group by c3
-having case when c3 > 0 then c3 else 0 end > 4;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |HASH GROUP BY    |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter([CASE WHEN t1.c3 > 0 THEN t1.c3 ELSE 0 END > 4]), rowset=256
-      group([t1.c3]), agg_func(nil)
-  1 - output([t1.c3]), filter([t1.c1 > 0], [t1.c2 > 0 OR CASE WHEN t1.c1 > t1.c2 THEN t1.c1 ELSE 3 END > 5]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5) 
-group by c3
-having case when c3 > 0 then c3 else 0 end > 4;
-+---+
-| 1 |
-+---+
-| 1 |
-+---+
-
-EXPLAIN select 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5) 
-group by c3
-having case when c3 > 0 then c3 else 0 end > 4;
-Query Plan
-=================================================
-|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
-|0 |HASH GROUP BY    |    |1       |5           |
-|1 |??TABLE FULL SCAN|t1  |1       |5           |
-=================================================
-Outputs & filters:
--------------------------------------
-  0 - output([1]), filter(nil), rowset=256
-      group([t1.c3]), agg_func(nil)
-  1 - output([t1.c3]), filter([t1.c1 > 0], [t1.c3 > 0], [t1.c3 > 4], [t1.c2 > 0 OR CASE WHEN t1.c1 > t1.c2 THEN t1.c1 ELSE 3 END > 5]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5) 
-group by c3
-having case when c3 > 0 then c3 else 0 end > 4;
-+---+
-| 1 |
-+---+
-| 1 |
-+---+
-
-**************************** plan cache test **************************** 
-enable plan cache
-set ob_enable_plan_cache = 1;
-alter system set enable_sql_audit = true;
-ERROR 42000: System config unknown
-alter system flush plan cache global;
-
-
-== case 1
-EXPLAIN select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 3;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 3;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 4;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 4;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? when c3 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? when c3 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')],
-       [__all_virtual_plan_stat.object_status = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip 
-      = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? when c3 > ? then ? else ? end > ?";
-+-----------+----------------------------------+-----------------------------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                                           |
-+-----------+----------------------------------+-----------------------------------------------------------------------------------------------------+
-|         1 | 23532075EEE7A10F268EDCC682D83254 | select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 3 |
-+-----------+----------------------------------+-----------------------------------------------------------------------------------------------------+
-expect generate 1 plan
-alter system flush plan cache global;
-
-== case 2
-EXPLAIN select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c3 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?";
-+-----------+----------------------------------+-----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                         |
-+-----------+----------------------------------+-----------------------------------------------------------------------------------+
-|         0 | 30E91141184DE81292F108AD9950CF1C | select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1 |
-|         0 | 30E91141184DE81292F108AD9950CF1C | select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1 |
-+-----------+----------------------------------+-----------------------------------------------------------------------------------+
-expect generate 2 plan
-alter system flush plan cache global;
-
-== case 3
-EXPLAIN select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c2 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c3 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?";
-+-----------+----------------------------------+-----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                         |
-+-----------+----------------------------------+-----------------------------------------------------------------------------------+
-|         0 | 30E91141184DE81292F108AD9950CF1C | select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1 |
-|         0 | 30E91141184DE81292F108AD9950CF1C | select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1 |
-+-----------+----------------------------------+-----------------------------------------------------------------------------------+
-expect generate 2 plan
-alter system flush plan cache global;
-
-== case 4
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 1, 2 > 1)]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                        |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1 |
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1 |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-expect generate 2 plan
-alter system flush plan cache global;
-
-== case 5
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 1, 2 > 1)]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                        |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1 |
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1 |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-expect generate 2 plan
-NULL and const plan Constraint
-alter system flush plan cache global;
-
-== case 6
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 1, 2 > 1)]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+-------------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                           |
-+-----------+----------------------------------+-------------------------------------------------------------------------------------+
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1    |
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1 |
-+-----------+----------------------------------+-------------------------------------------------------------------------------------+
-expect generate 2 plan
-alter system flush plan cache global;
-
-== case 7
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 1, 2 > 1)]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+-------------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                           |
-+-----------+----------------------------------+-------------------------------------------------------------------------------------+
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1 |
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1    |
-+-----------+----------------------------------+-------------------------------------------------------------------------------------+
-expect generate 2 plan
-## The following test case generate 1 plan, for that can't be rewrite SQL, we don't add constraint
-alter system flush plan cache global;
-
-== case 8
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 1, 2 > 1)]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                        |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1 |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-expect generate 2 plan
-## The following test case generate 1 plan, for that can't be rewrite SQL, we don't add constraint
-alter system flush plan cache global;
-
-== case 9
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 1 THEN 2 ELSE 3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                        |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-|         1 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1 |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-expect generate 1 plan
-alter system flush plan cache global;
-
-== case 9.1
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |5       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter(nil), startup_filter([0]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 1 THEN 2 ELSE 3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')], [__all_virtual_plan_stat.object_status 
-      = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                        |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5 |
-|         0 | C0667D44810456FC45F1616D5A4E6CF6 | select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1 |
-+-----------+----------------------------------+----------------------------------------------------------------------------------+
-expect generate 2 plan
-## The following test case generate 1 plan, for NULL we add NVL(NULL, FALSE) as FALSE
-alter system flush plan cache global;
-
-== case 10
-EXPLAIN select * from t1 where case when 1 > 1 then c1 when NULL > 2 then c2 when 3 > 3 then c3 else c4 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c4 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 1 then c1 when NULL > 2 then c2 when 3 > 3 then c3 else c4 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when 1 > 1 then c1 when 2 > 2 then c2 when 3 > 3 then c3 else c4 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |1       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([t1.c4 > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 1 then c1 when 2 > 2 then c2 when 3 > 3 then c3 else c4 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 when ? > ? then c3 else c4 end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when ? > ? then c1 when ? > ? then c2 when ? > ? then c3 else c4 end > ?', VARCHAR(1048576)), '\\')],
-       [__all_virtual_plan_stat.object_status = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip 
-      = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 when ? > ? then c3 else c4 end > ?";
-+-----------+----------------------------------+---------------------------------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                                               |
-+-----------+----------------------------------+---------------------------------------------------------------------------------------------------------+
-|         0 | 33DD0D8C3E6C37CBC645380CB515B346 | select * from t1 where case when 1 > 1 then c1 when NULL > 2 then c2 when 3 > 3 then c3 else c4 end > 1 |
-|         0 | 33DD0D8C3E6C37CBC645380CB515B346 | select * from t1 where case when 1 > 1 then c1 when 2 > 2 then c2 when 3 > 3 then c3 else c4 end > 1    |
-+-----------+----------------------------------+---------------------------------------------------------------------------------------------------------+
-expect generate 1 plan
-alter system flush plan cache global;
-
-== case 11
-EXPLAIN select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 0;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c2 > 2 THEN 2 WHEN 3 > 3 THEN 3 ELSE 4 END > 0]), rowset=256
-      access([t1.c2], [t1.c1], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 0;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-|    3 |    3 |    3 |    3 |    3 |    3 |
-|    4 |    4 |    4 |    4 |    4 |    4 |
-|    5 |    5 |    5 |    5 |    5 |    5 |
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 3;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |3       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(1 > 1, TINYINT(-1, 0))), lnnvl(cast(t1.c2 > 2, TINYINT(-1,
-       0))), lnnvl(cast(3 > 3, TINYINT(-1, 0))), 4 > 3)]), rowset=256
-      access([t1.c2], [t1.c1], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 3;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-|    1 |    1 |    1 |    1 |    1 |    1 |
-|    2 |    2 |    2 |    2 |    2 |    2 |
-+------+------+------+------+------+------+
-EXPLAIN select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then ? when c2 > ? then ? when ? > ? then ? else ? end > ?";
-Query Plan
-==================================================================
-|ID|OPERATOR       |NAME                   |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
-|0 |TABLE FULL SCAN|__all_virtual_plan_stat|16      |150         |
-==================================================================
-Outputs & filters:
--------------------------------------
-  0 - output([__all_virtual_plan_stat.hit_count], [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.query_sql]), filter([(T_OP_LIKE, cast(__all_virtual_plan_stat.statement,
-       VARCHAR(1048576)), cast('select * from t1 where case when ? > ? then ? when c2 > ? then ? when ? > ? then ? else ? end > ?', VARCHAR(1048576)), '\\')],
-       [__all_virtual_plan_stat.object_status = 0], [__all_virtual_plan_stat.is_in_pc = 1], [__all_virtual_plan_stat.svr_port = RPC_PORT()], [__all_virtual_plan_stat.svr_ip 
-      = HOST_IP()])
-      access([__all_virtual_plan_stat.svr_ip], [__all_virtual_plan_stat.svr_port], [__all_virtual_plan_stat.object_status], [__all_virtual_plan_stat.is_in_pc],
-       [__all_virtual_plan_stat.sql_id], [__all_virtual_plan_stat.statement], [__all_virtual_plan_stat.query_sql], [__all_virtual_plan_stat.hit_count]), partitions(p1)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false,false], 
-      range_key(nil), range(MIN ; MAX)
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then ? when c2 > ? then ? when ? > ? then ? else ? end > ?";
-+-----------+----------------------------------+---------------------------------------------------------------------------------------------------+
-| hit_count | sql_id                           | query_sql                                                                                         |
-+-----------+----------------------------------+---------------------------------------------------------------------------------------------------+
-|         1 | C0AAFE143F3B0422D20F79461648D647 | select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 0 |
-+-----------+----------------------------------+---------------------------------------------------------------------------------------------------+
-expect generate 1 plan
-
-**************************** index scan test **************************** 
-set ob_enable_plan_cache = 0;
-create index t1c2 on t1(c2);
-
-== case 1
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else 0 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE 0 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else 0 end > 1;
-Query Plan
-===================================================
-|ID|OPERATOR       |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------
-|0 |TABLE FULL SCAN|t1(t1c2)|1       |13          |
-===================================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 2, 2 > 1)]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.c2], [t1.__pk_increment]), range(2,MAX ; MAX,MAX)
-select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else 0 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-expect use range scan on index t1c2 
-
-== case 2
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE NULL END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 end > 1;
-Query Plan
-===================================================
-|ID|OPERATOR       |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------
-|0 |TABLE FULL SCAN|t1(t1c2)|1       |13          |
-===================================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([(T_OP_AND, lnnvl(cast(t1.c1 > 1, TINYINT(-1, 0))), t1.c2 > 2, 2 > 1)]), rowset=256
-      access([t1.__pk_increment], [t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.c2], [t1.__pk_increment]), range(2,MAX ; MAX,MAX)
-select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-expect use range scan on index t1c2 
-
-== case 3
-EXPLAIN select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else c3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-EXPLAIN select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else c3 end > 1;
-Query Plan
-===============================================
-|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
-|0 |TABLE FULL SCAN|t1  |2       |5           |
-===============================================
-Outputs & filters:
--------------------------------------
-  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), filter([CASE WHEN t1.c1 > 1 THEN 1 WHEN t1.c2 > 2 THEN 2 ELSE t1.c3 END > 1]), rowset=256
-      access([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t1.c5], [t1.c6]), partitions(p0)
-      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
-      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
-select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else c3 end > 1;
-+------+------+------+------+------+------+
-| c1   | c2   | c3   | c4   | c5   | c6   |
-+------+------+------+------+------+------+
-+------+------+------+------+------+------+
-expect don't use range scan 
-end test
-USE DB_CONVERT_CASE_WHEN;
-drop database DB_CONVERT_CASE_WHEN;
-
diff --git a/tools/deploy/mysql_test/test_suite/transformer/t/transformer_convert_case_when_predicate.test b/tools/deploy/mysql_test/test_suite/transformer/t/transformer_convert_case_when_predicate.test
deleted file mode 100644
index 289ea0c..0000000
--- a/tools/deploy/mysql_test/test_suite/transformer/t/transformer_convert_case_when_predicate.test
+++ /dev/null
@@ -1,627 +0,0 @@
-
-# owner: kongfanhao.kfh
-# owner group: sql
-# tags: optimizer
-
---disable_info
---disable_metadata
---disable_abort_on_error
-
---result_format 4
---explain_protocol 2
-
---disable_warnings
-DROP DATABASE IF EXISTS DB_CONVERT_CASE_WHEN;
---enable_warnings
-CREATE DATABASE DB_CONVERT_CASE_WHEN;
-USE DB_CONVERT_CASE_WHEN;
-
---disable_warnings
-drop table if exists t1, t2, t3;
---enable_warnings
-create table t1(c1 int, c2 int, c3 int, c4 int, c5 int, c6 int);
-create table t2(c1 int, c2 int, c3 int);
-create table t3(c1 int, c2 varchar(64), c3 varchar(64));
-
-insert/*trace*/ into t1 values(1,1,1,1,1,1), (2,2,2,2,2,2), (3,3,3,3,3,3), (4,4,4,4,4,4), (5,5,5,5,5,5);
-insert/*trace*/ into t2 values(NULL, NULL, NULL);
-insert/*trace*/ into t3 values(1, "aaa", "is_aaa"), (2, "bbb", "is_bbb"), (3, "ccc", "is_ccc"), (4, "ddd", "is_ddd");
-
---disable_warnings
-drop table if exists is_c1;
---enable_warnings
-create table is_c1(c1 int);
-
-# disable plan cache
-set ob_enable_plan_cache = 0;
-
---echo **************************** basic test **************************** 
---echo
---echo == case 1
-select /*+no_rewrite*/* from (select /*+no_rewrite*/* from t2 where case when 1 is NULL then c1 else c2 end > 1); 
-select * from (select * from t2 where case when 1 is NULL then c1 else c2 end > 1); 
-
---echo
---echo == case 2
-select /*+no_rewrite*/* from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa";
-select * from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa";
-
---echo
---echo == case 3
-select /*+no_rewrite*/* from t3 where case when c1 > 0 then "aaa" else "bbb" end = "ccc";
-select * from t3 where case when c1 > 0 then "aaa" else "bbb" end = "ccc";
-
---echo
---echo == case 4 set union
-select /*+no_rewrite*/ * from ((select /*+no_rewrite*/ c1 from t1 where case when 1 > 2 then c1 else c2 end > 1) 
-                         union (select /*+no_rewrite*/ c1 from t3 where case when c1 > 0 then 1 else 2 end > 1)) as tmp;
-select * from ((select c1 from t1 where case when 1 > 2 then c1 else c2 end > 1) 
-         union (select c1 from t3 where case when c1 > 0 then 1 else 2 end > 1)) as tmp;
-
---echo **************************** convert when exprs test **************************** 
---echo
---echo == case 1
-select /*+no_rewrite*/ * from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-select * from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-
---echo
---echo == case 2
-select /*+no_rewrite*/ case when 2 > 1 then c1 else c2 end from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-select case when 2 > 1 then c1 else c2 end from t1 where c1 > 0 and case when 2 > 1 then c1 else c2 end > 1;
-
---echo
---echo == case 3
-select /*+no_rewrite*/ 1 from t1 where case when c1 > c2 then c1 else c2 end > 1;
-select 1 from t1 where case when c1 > c2 then c1 else c2 end > 1;
-
---echo
---echo == case 4
-select /*+no_rewrite*/ 1 from t1 where case when 2 > 2 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-select 1 from t1 where case when 2 > 2 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-
---echo
---echo == case 5
-select /*+no_rewrite*/ 1 from t1 where case when 2 > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-select 1 from t1 where case when 2 > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-                            
---echo
---echo == case 6
-select /*+no_rewrite*/ 1 from t1 where case when NULL > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-select 1 from t1 where case when NULL > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-
---echo
---echo == case 7
-select /*+no_rewrite*/ 1 from t1 where case when c1 > 1 then c1 
-                                            when 1 > 2  then 2 
-                                            when 2 < 3 then c2 
-                                            else c3 end > 1;
-select 1 from t1 where case when c1 > 1 then c1 
-                            when 1 > 2  then 2 
-                            when 2 < 3 then c2 
-                            else c3 end > 1;
-
---echo
---echo == case 8
-select /*+no_rewrite*/ 1 from t1 where case when 1 > 1 then c1 
-                                            else c3 end > 1;
-select 1 from t1 where case when 1 > 1 then c1 else c3 end > 1;
-
---echo
---echo == case 9
-select /*+no_rewrite*/ * from t1 where case when 1 < 2 then 1 
-                            when 2 > 3 then 2 
-                            when 3 > 2 then c1
-                            when c2 > 0 then c2
-                            else c3
-                        end > 2;
-select * from t1 where case when 1 < 2 then 1 
-                            when 2 > 3 then 2 
-                            when 3 > 2 then c1
-                            when c2 > 0 then c2
-                            else c3
-                        end > 2;
-
---echo
---echo == case 10: with scala group by
-select /*+no_rewrite*/ 1 from t1 having case when 1 > 1 then count(*) 
-                                             else 3 end > 1;
-select 1 from t1 having case when 1 > 1 then count(*) 
-                        else 3 end > 1;
-
---echo
---echo == case 11: with scala group by
-select /*+no_rewrite*/ case when 1 then 2 else count(*) end from t1 
-                        where c1 > 0 and case when 1 >= 1 then c1 else c2 end > 0
-                        having case when 1 > 1 then count(*) else 3 end > 1;
-select case when 1 then 2 else count(*) end from t1 
-                        where c1 > 0 and case when 1 >= 1 then c1 else c2 end > 0
-                        having case when 1 > 1 then count(*) else 3 end > 1;
-
---echo
---echo == case 12: with scala group by
-select /*+no_rewrite*/ 1 from t1 having case when 1 > 1 then count(*) 
-                                             when 2 > 1 then 2
-                                             else 3 end > 1;
-select 1 from t1 having case when 1 > 1 then count(*) 
-                                             when 2 > 1 then 2
-                                             else 3 end > 1;
-
---echo
---echo == case 13: with shared expr 
-select /*+no_rewrite*/ case when 2 > 1 then c1 else c2 end from t1 where 
-                                    case when 2 > 1 then c1 
-                                         else c2 
-                                    end > 1;
-select case when 2 > 1 then c1 else c2 end from t1 where 
-                                    case when 2 > 1 then c1 
-                                         else c2 
-                                    end > 1;
-
---echo
---echo == case 14: with subquery 
-select /*+no_rewrite*/1 from t1 where c1 > 0 and c2 in (
-    select /*+no_rewrite*/c2 from t2 where 
-    case when 0 > 1 then c1
-         when 1 > 2 then c2
-         else c3
-    end > 0
-) and c3 > 0;
-
-select 1 from t1 where c1 > 0 and c2 in (
-    select c2 from t2 where 
-    case when 0 > 1 then c1
-         when 1 > 2 then c2
-         else c3
-    end > 0
-) and c3 > 0;
-
---echo
---echo == case 15: with subquery with scala group by
-select /*+no_rewrite*/1 from t1 where c1 > 0 and c2 in (
-    select /*+no_rewrite*/c2 from t2 having 
-    case when 0 > 1 then count(*) 
-         when 1 > 2 then 2
-         else 2 
-    end > 0
-) and c3 > 0;
-
-select 1 from t1 where c1 > 0 and c2 in (
-    select c2 from t2 having 
-    case when 0 > 1 then count(*) 
-         when 1 > 2 then 2
-         else 2 
-    end > 0
-) and c3 > 0;
-
---echo
---echo == case 16: with scalar static const expr 
-select /*+no_rewrite*/ 1 from t1 where case when 1 > 2 then c1
-                            when 2 in (1,2,3) then c2
-                            when c1 > 2 then c3 
-                            else c4 
-                        end > 1;
-select 1 from t1 where case when 1 > 2 then c1
-                            when 2 in (1,2,3) then c2
-                            when c1 > 2 then c3 
-                            else c4 
-                        end > 1;
-
---echo
---echo == case 17: debug  
-select /*+no_rewrite*/ 1 from t1 where case when 1 > 2 then c1
-                            when 2 > 3 then c2
-                            when c1 > 2 then c3 
-                            when c2 > 2 then c4
-                            when c3 > 2 then c4
-                            else c4 
-                        end > 1;
-select 1 from t1 where case when 1 > 2 then c1
-                            when 2 > 3 then c2
-                            when c1 > 2 then c3 
-                            when c2 > 2 then c4
-                            when c3 > 2 then c4
-                            else c4 
-                        end > 1;
-
---echo set autocommit = 0;
-set autocommit = 0;
---echo 
---echo == case 18: insert SQL 
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when 2 > 2 then c1
-                                               when 2 > 1 then c2
-                                               else c3
-                                          end > 1;
-insert into is_c1 select c1 from t1 where case when 2 > 2 then c1
-                                               when 2 > 1 then c2
-                                               else c3
-                                          end > 1;
-select * from is_c1;
-rollback;
-
---echo 
---echo == case 19: insert SQL 
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when 1 > NULL then c1
-                                               when 2 > 2 then c2
-                                               else c3
-                                          end > 1;
-insert into is_c1 select c1 from t1 where case when 1 > NULL then c1
-                                               when 2 > 2 then c2
-                                               else c3
-                                          end > 1;
-select * from is_c1;
-rollback;
-
---echo 
---echo == case 20: insert SQL 
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                               else 3
-                                          end > 2;
-insert into is_c1 select c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                               else 3
-                                          end > 2;
-select * from is_c1;
-rollback;
-
---echo 
---echo == case 21: insert SQL 
-insert into is_c1 select /*+no_rewrite*/c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                          end > 2;
-insert into is_c1 select c1 from t1 where case when c1 > 1 then 1
-                                               when c2 > 2 then 2
-                                          end > 2;
-select * from is_c1;
-rollback;
-
---echo 
---echo == case 22: update SQL 
-update /*+no_rewrite*/ t1 set t1.c1 = t1.c1 + 1 where case when c1 > 1 then 1
-                                                           when c2 > 2 then 2
-                                                      end > 2;
-update t1 set t1.c1 = t1.c1 + 1 where case when c1 > 1 then 1
-                                           when c2 > 2 then 2
-                                      end > 2;
-select * from t1;
-rollback;
-
---echo 
---echo == case 23: update SQL 
-update /*+no_rewrite*/ t1 set t1.c1 = t1.c1 + 1 where case when 1 > 1 then c1
-                                                           when 2 > 2 then c2
-                                                           else c3
-                                                      end > 2;
-update t1 set t1.c1 = t1.c1 + 1 where case when 1 > 1 then c1
-                                           when 2 > 2 then c2
-                                           else c3
-                                      end > 2;
-select * from t1;
-rollback;
-
-delete from t1 where c1 = (select /*+no_rewrite*/ c1 from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa" limit 1);
-delete from t1 where c1 = (select c1 from t3 where case when c1 > 0 then "aaa" else "bbb" end = "aaa" limit 1);
-select * from t1;
-rollback;
-
-set autocommit = 1;
-
-
---echo **************************** convert then exprs test **************************** 
---echo
---echo == case 1
-select /*+no_rewrite*/* from t1 where case when c1 > 0 then 0 else 1 end > 0;
-select * from t1 where case when c1 > 0 then 0 else 1 end > 0;
-
---echo
---echo == case 2
-select /*+no_rewrite*/* from t1 where case when c1 > 0 then 0 else 1 end > 1;
-select * from t1 where case when c1 > 0 then 0 else 1 end > 1;
-
---echo
---echo == case 3
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 0 
-							when c2 > 0 then 0 
-							else 1 
-					   end > 1;
-select * from t1 where case when c1 > 0 then 0 
-							when c2 > 0 then 0 
-							else 1 
-					   end > 1;
-
---echo
---echo == case 4
-select /*+no_rewrite*/ * from t1 where c1 > 0 and c2 > 0 and 
-                            case when c1 > 0 then 1 
-                                 when c2 > 0 then 2
-                                 else 0 
-                            end > 1;
-select * from t1 where c1 > 0 and c2 > 0 and 
-                            case when c1 > 0 then 1 
-                                 when c2 > 0 then 2
-                                 else 0 
-                            end > 1;
-
---echo
---echo == case 5
-select /*+no_rewrite*/ * from t1 where c1 > 0 or (c2 > 0 and 
-                                case when c1 > 0 then 1 
-                                    when c2 > 0 then 2
-                                    else 0 
-                                end > 1);
-select * from t1 where c1 > 0 or (c2 > 0 and 
-                                case when c1 > 0 then 1 
-                                    when c2 > 0 then 2
-                                    else 0 
-                                end > 1);
-
---echo
---echo == case 6: test with scala group by
-select /*+no_rewrite*/ case when c1 > 0 then 1 else count(*) end > 2 from t1;
-select case when c1 > 0 then 1 else count(*) end > 2 from t1;
-
---echo
---echo == case 7: test with scala group by
-select /*+no_rewrite*/ c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 from t1;
-select c2 > 0 and case when c1 > 0 then 1 else count(*) end > 2 from t1;
-
---echo
---echo == case 8: test with scala group by
-select /*+no_rewrite*/ 1 from t1 having case when 1 then 1 else count(*) end > 2;
-select 1 from t1 having case when 1 then 1 else count(*) end > 2;
-
---echo
---echo == case 9: test with scala group by
-select 1 from t1 where c1 > 0 or (c2 > 0 and 
-                                    case when c1 > 0 then 1 
-                                        when c2 > 0 then 2
-                                        else 0 
-                                    end > 1)
-                    having case when 1 then 1 else count(*) end > 2;
-select /*+no_rewrite*/ 1 from t1 where c1 > 0 or (c2 > 0 and 
-                                    case when c1 > 0 then 1 
-                                        when c2 > 0 then 2
-                                        else 0 
-                                    end > 1)
-                    having case when 1 then 1 else count(*) end > 2;
-
---echo
---echo == case 10: can't be rewrite 
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1 else 2 end > 0;
-select * from t1 where case when c1 > 0 then 1 else 2 end > 0;
-
---echo
---echo == case 11: can't be rewrite 
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1 
-                          	when c2 > 0 then 2
-                      	    when c3 > 0 then 3
-                          	else 4
-                       end > 1;
-select * from t1 where case when c1 > 0 then 1 
-                          	when c2 > 0 then 2
-                      	    when c3 > 0 then 3
-                          	else 4
-                       end > 1;
-                    
---echo
---echo == case 12: can't be rewrite 
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then c1 else c2 end > 0;
-select * from t1 where case when c1 > 0 then c1 else c2 end > 0;
- 
---echo
---echo == case 13: can't be rewrite 
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then c1 
-                                when c2 > 0 then c2
-                                when c3 > 0 then 0
-                                else 0
-                            end > 1;
-
-select * from t1 where case when c1 > 0 then c1 
-                          	when c2 > 0 then c2
-                      	    when c3 > 0 then 0
-                          	else 0
-                       end > 1;
-
---echo
---echo == case 13: can't be rewrite with NULL
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then null else 0 end = 0;
-select * from t1 where case when c1 > 0 then null else 0 end = 0;
-
---echo
---echo == case 13: can't be rewrite with NULL
-select * from t1 where case when c1 > 0 then 1
-                            when c2 > 0 then 2
-                          	when c3 > 0 then 3
-                            else null
-                       end > 2;
-select /*+no_rewrite*/ * from t1 where case when c1 > 0 then 1
-                            when c2 > 0 then 2
-                          	when c3 > 0 then 3
-                            else null
-                       end > 2;
-
-
---echo **************************** Joint when and then exprs test **************************** 
---echo
---echo == case 1 
-select * from t1 where 
-	case when 1 > 2 then 1
-			 when 2 > 3 then 2
-		   when null then c1
-			 when c2 > 0 then c2
-  	   else 1
-	end > 2;
-select /*+no_rewrite*/ * from t1 where 
-	case when 1 > 2 then 1
-			 when 2 > 3 then 2
-		   when null then c1
-			 when c2 > 0 then c2
-  	   else 1
-	end > 2;
-
---echo 
---echo == case 2
-select /*+no_rewrite*/ 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5);
-select 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5);
-
---echo 
---echo == case 3
-select /*+no_rewrite*/ 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5) 
-group by c3
-having case when c3 > 0 then c3 else 0 end > 4;
-
-select 1 from t1 where c1 > 0 and (c2 > 0 or case when c1 > c2 then c1 else 3 end > 5) 
-group by c3
-having case when c3 > 0 then c3 else 0 end > 4;
-
-
---echo **************************** plan cache test **************************** 
---echo enable plan cache
-set ob_enable_plan_cache = 1;
-alter system set enable_sql_audit = true;
-alter system flush plan cache global;
-
---echo
---echo == case 1
-select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 3;
-select * from t1 where case when c1 > 0 then 0 when c2 > 0 then 1 when c3 > 0 then 2 else 3 end > 4;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? when c3 > ? then ? else ? end > ?";
---echo expect generate 1 plan
-
-alter system flush plan cache global;
---echo
---echo == case 2
-select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1;
-select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?";
---echo expect generate 2 plan
-
-alter system flush plan cache global;
---echo
---echo == case 3
-select * from t1 where case when 1 > 2 then c1 when 2 > 1 then c2 else c3 end > 1;
-select * from t1 where case when 1 > 2 then c1 when 2 > 3 then c2 else c3 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 else c3 end > ?";
---echo expect generate 2 plan
-
-alter system flush plan cache global;
---echo
---echo == case 4
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 2 plan
-
-alter system flush plan cache global;
---echo
---echo == case 5
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 1 else 0 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 2 plan
-
---echo NULL and const plan Constraint
-alter system flush plan cache global;
---echo
---echo == case 6
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 2 plan
-
-alter system flush plan cache global;
---echo
---echo == case 7
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL else 0 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 2 plan
-
-## The following test case generate 1 plan, for that can't be rewrite SQL, we don't add constraint
-alter system flush plan cache global;
---echo
---echo == case 8
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then NULL end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 0 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 2 plan
-
-## The following test case generate 1 plan, for that can't be rewrite SQL, we don't add constraint
-alter system flush plan cache global;
---echo
---echo == case 9
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 1 plan
-
-alter system flush plan cache global;
---echo
---echo == case 9.1
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 5;
-select * from t1 where case when c1 > 1 then 1 when c2 > 1 then 2 else 3 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when c1 > ? then ? when c2 > ? then ? else ? end > ?";
---echo expect generate 2 plan
-
-## The following test case generate 1 plan, for NULL we add NVL(NULL, FALSE) as FALSE
-alter system flush plan cache global;
---echo
---echo == case 10
-select * from t1 where case when 1 > 1 then c1 when NULL > 2 then c2 when 3 > 3 then c3 else c4 end > 1;
-select * from t1 where case when 1 > 1 then c1 when 2 > 2 then c2 when 3 > 3 then c3 else c4 end > 1;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then c1 when ? > ? then c2 when ? > ? then c3 else c4 end > ?";
---echo expect generate 1 plan
-
-alter system flush plan cache global;
---echo
---echo == case 11
-select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 0;
-select * from t1 where case when 1 > 1 then 1 when c2 > 2 then 2 when 3 > 3 then 3 else 4 end > 3;
-select hit_count, sql_id, query_sql from oceanbase.V$OB_PLAN_CACHE_PLAN_STAT where statement like "select * from t1 where case when ? > ? then ? when c2 > ? then ? when ? > ? then ? else ? end > ?";
---echo expect generate 1 plan
-
-
---echo **************************** index scan test **************************** 
-set ob_enable_plan_cache = 0;
-create index t1c2 on t1(c2);
---echo
---echo == case 1
-select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else 0 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else 0 end > 1;
---echo expect use range scan on index t1c2 
-
---echo
---echo == case 2
-select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 end > 1;
---echo expect use range scan on index t1c2 
-
---echo
---echo == case 3
-select /*+no_rewrite*/ * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else c3 end > 1;
-select * from t1 where case when c1 > 1 then 1 when c2 > 2 then 2 else c3 end > 1;
---echo expect don't use range scan 
-
---echo end test
-
-USE DB_CONVERT_CASE_WHEN;
-drop database DB_CONVERT_CASE_WHEN;
-
