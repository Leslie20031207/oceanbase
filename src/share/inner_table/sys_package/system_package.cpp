// This file is generated by CMake, do not edit it!

#include <cstdint>
#include <utility>

namespace oceanbase {
namespace pl {

extern const int64_t syspack_source_count = 48;
extern const std::pair<const char * const, const char* const> syspack_source_contents[] = {
{
"__dbms_upgrade_body_mysql.sql", // size = 302 bytes
R"sys_pack_del(#package_name:dbms_upgrade
#author: hr351303


CREATE OR REPLACE PACKAGE BODY __DBMS_UPGRADE
  PROCEDURE UPGRADE(package_name VARCHAR(1024), load_from_file BOOLEAN);
    PRAGMA INTERFACE(c, UPGRADE_SINGLE);
  PROCEDURE UPGRADE_ALL(load_from_file BOOLEAN);
    PRAGMA INTERFACE(c, UPGRADE_ALL);
END;
//
)sys_pack_del"
},
{
"__dbms_upgrade_mysql.sql", // size = 264 bytes
R"sys_pack_del(#package_name:dbms_upgrade
#author: hr351303


CREATE OR REPLACE PACKAGE __DBMS_UPGRADE
  PROCEDURE UPGRADE(package_name VARCHAR(1024),
                    load_from_file BOOLEAN DEFAULT TRUE);
  PROCEDURE UPGRADE_ALL(load_from_file BOOLEAN DEFAULT TRUE);
END;
//
)sys_pack_del"
},
{
"dbms_application_body_mysql.sql", // size = 658 bytes
R"sys_pack_del(#package_name:dbms_application_info
#author: xiaoyi.xy
CREATE OR REPLACE PACKAGE BODY DBMS_APPLICATION_INFO
  PROCEDURE READ_CLIENT_INFO(OUT CLIENT_INFO VARCHAR(65535));
  PRAGMA INTERFACE(c, READ_CLIENT_INFO);
  PROCEDURE READ_MODULE(OUT MODULE_NAME VARCHAR(65535), OUT ACTION_NAME VARCHAR(65535));
  PRAGMA INTERFACE(c, READ_MODULE);
  PROCEDURE SET_ACTION(IN ACTION_NAME VARCHAR(65535));
  PRAGMA INTERFACE(c, SET_ACTION);
  PROCEDURE SET_CLIENT_INFO(IN CLIENT_INFO VARCHAR(65535));
  PRAGMA INTERFACE(c, SET_CLIENT_INFO);
  PROCEDURE SET_MODULE(IN MODULE_NAME VARCHAR(65535), IN ACTION_NAME VARCHAR(65535));
  PRAGMA INTERFACE(c, SET_MODULE);
END;


//

)sys_pack_del"
},
{
"dbms_application_mysql.sql", // size = 465 bytes
R"sys_pack_del(#package_name: dbms_application_info
#author: xiaoyi.xy
CREATE OR REPLACE PACKAGE DBMS_APPLICATION_INFO
  PROCEDURE READ_CLIENT_INFO(OUT CLIENT_INFO VARCHAR(65535));
  PROCEDURE READ_MODULE(OUT MODULE_NAME VARCHAR(65535), OUT ACTION_NAME VARCHAR(65535));
  PROCEDURE SET_ACTION(IN ACTION_NAME VARCHAR(65535));
  PROCEDURE SET_CLIENT_INFO(IN CLIENT_INFO VARCHAR(65535));
  PROCEDURE SET_MODULE(IN MODULE_NAME VARCHAR(65535), IN ACTION_NAME VARCHAR(65535));
END;

//
)sys_pack_del"
},
{
"dbms_ash_internal.sql", // size = 254 bytes
R"sys_pack_del(-- package_name:dbms_ash_internal
-- author:xiaochu.yh


CREATE OR REPLACE PACKAGE dbms_ash_internal AUTHID CURRENT_USER AS

  FUNCTION  IN_MEMORY_ASH_VIEW_SQL
    RETURN  VARCHAR2;

  FUNCTION  ASH_VIEW_SQL
    RETURN  VARCHAR2;

END dbms_ash_internal;
)sys_pack_del"
},
{
"dbms_ash_internal_body.sql", // size = 3660 bytes
R"sys_pack_del(-- package_name:dbms_ash_internal
-- author:xiaochu.yh

CREATE OR REPLACE PACKAGE BODY dbms_ash_internal AS

  FUNCTION  IN_MEMORY_ASH_VIEW_SQL
    RETURN  VARCHAR2
  IS
    RETVAL    VARCHAR2(30000);
  BEGIN
    RETVAL := 'SELECT a.sample_id, a.sample_time, ' ||
              '       a.svr_ip, ' ||
              '       a.svr_port, ' ||
              '       a.con_id, ' ||
              '       a.user_id, ' ||
              '       a.session_id, '   ||
              '       a.session_type, ' ||
              '       a.session_state, ' ||
              '       a.top_level_sql_id, ' ||
              '       a.sql_id, ' ||
              '       plan_id, ' ||
              '       a.trace_id, ' ||
              '       nvl(a.event, ''CPU + Wait for CPU'') as event, ' ||
              '       nvl(a.event_no, 1) as event_no, ' ||
              '       a.p1, a.p1text, ' ||
              '       a.p2, a.p2text, ' ||
              '       a.p3, a.p3text, ' ||
              '       nvl(a.wait_class, ''CPU'') as wait_class, ' ||
              '       nvl(a.wait_class_id, 9999) as wait_class_id, ' ||
              '       a.time_waited, ' ||
              '       a.sql_plan_line_id, ' ||
              '       a.in_parse, ' ||
              '       a.in_pl_parse, ' ||
              '       a.in_plan_cache, ' ||
              '       a.in_sql_optimize, ' ||
              '       a.in_sql_execution, ' ||
              '       a.in_px_execution, ' ||
              '       a.in_sequence_load, ' ||
              '       a.in_committing, ' ||
              '       a.in_storage_read, ' ||
              '       a.in_storage_write, ' ||
              '       a.in_remote_das_execution, ' ||
              '       a.in_plsql_execution, ' ||
              '       a.in_plsql_compilation, ' ||
              '       a.plsql_entry_object_id, ' ||
              '       a.plsql_entry_subprogram_id, ' ||
              '       a.plsql_entry_subprogram_name, ' ||
              '       a.plsql_object_id, ' ||
              '       a.plsql_subprogram_id, ' ||
              '       a.plsql_subprogram_name, ' ||
              '       a.module, a.action, a.client_id ' ||
              'FROM GV$ACTIVE_SESSION_HISTORY a ' ||
              'WHERE  1=1 ';
    RETURN RETVAL;
  END IN_MEMORY_ASH_VIEW_SQL;

  FUNCTION  ASH_VIEW_SQL
    RETURN  VARCHAR2
  IS
    RETVAL  VARCHAR2(30000);
  BEGIN
    RETVAL := 'SELECT * FROM    (' || IN_MEMORY_ASH_VIEW_SQL ||
              '            and  a.sample_time between :ash_mem_btime and :ash_mem_etime ' ||
              '  AND   (:ash_svr_ip IS NULL ' ||
              '         OR svr_ip like :ash_svr_ip) ' ||
              '  AND   (:ash_svr_port IS NULL ' ||
              '         OR svr_port like :ash_svr_port) ' ||
              '         ) unified_ash ' ||
              'WHERE  sample_time between :ash_begin_time ' ||
              '                        and :ash_end_time ' ||
              '  AND   (:ash_sql_id IS NULL ' ||
              '         OR sql_id like :ash_sql_id) ' ||
              '  AND   (:ash_trace_id IS NULL ' ||
              '         OR trace_id like :ash_trace_id) ' ||
              '  AND   (:ash_wait_class IS NULL ' ||
              '         OR wait_class like :ash_wait_class) ' ||
              '  AND   (:ash_module IS NULL ' ||
              '         OR module like :ash_module) ' ||
              '  AND   (:ash_action IS NULL ' ||
              '         OR action like :ash_action) ' ||
              '  AND   (:ash_client_id IS NULL ' ||
              '         OR client_id like :ash_client_id)';
       RETURN RETVAL;
  END ASH_VIEW_SQL;

END dbms_ash_internal;
)sys_pack_del"
},
{
"dbms_balance.sql", // size = 222 bytes
R"sys_pack_del(#package_name: DBMS_BALANCE
#author: wangzhennan.wzn

CREATE OR REPLACE PACKAGE dbms_balance AUTHID CURRENT_USER AS

  PROCEDURE trigger_partition_balance(balance_timeout BINARY_INTEGER DEFAULT NULL);

END dbms_balance;
//)sys_pack_del"
},
{
"dbms_balance_body.sql", // size = 270 bytes
R"sys_pack_del(#package_name: DBMS_BALANCE
#author: wangzhennan.wzn

CREATE OR REPLACE PACKAGE BODY dbms_balance AS

  PROCEDURE trigger_partition_balance(balance_timeout BINARY_INTEGER DEFAULT NULL);
  PRAGMA INTERFACE(C, DBMS_BALANCE_TRIGGER_PARTITION_BALANCE);

END dbms_balance;
//)sys_pack_del"
},
{
"dbms_balance_body_mysql.sql", // size = 256 bytes
R"sys_pack_del(#package_name: DBMS_BALANCE
#author: wangzhennan.wzn

CREATE OR REPLACE PACKAGE BODY dbms_balance

  PROCEDURE trigger_partition_balance(balance_timeout INT DEFAULT NULL);
  PRAGMA INTERFACE(C, DBMS_BALANCE_TRIGGER_PARTITION_BALANCE);

END dbms_balance;
//)sys_pack_del"
},
{
"dbms_balance_mysql.sql", // size = 208 bytes
R"sys_pack_del(#package_name: DBMS_BALANCE
#author: wangzhennan.wzn

CREATE OR REPLACE PACKAGE dbms_balance AUTHID CURRENT_USER

  PROCEDURE trigger_partition_balance(balance_timeout INT DEFAULT NULL);

END dbms_balance;
//)sys_pack_del"
},
{
"dbms_monitor_body_mysql.sql", // size = 1894 bytes
R"sys_pack_del(#package_name:dbms_monitor
#author: xiaoyi.xy
CREATE OR REPLACE PACKAGE BODY DBMS_MONITOR
  PROCEDURE OB_SESSION_TRACE_ENABLE(SESSION_ID   DECIMAL(20, 0),
                                    LEVEL        DECIMAL(20, 0),
                                    SAMPLE_PCT   DECIMAL(20, 10),
                                    RECORD_POLICY VARCHAR(65535));
  PRAGMA INTERFACE(c, OB_SESSION_TRACE_ENABLE);
  PROCEDURE OB_SESSION_TRACE_DISABLE(session_id   DECIMAL(20, 0));
  PRAGMA INTERFACE(c, OB_SESSION_TRACE_DISABLE);

  PROCEDURE OB_CLIENT_ID_TRACE_ENABLE(CLIENT_ID    VARCHAR(65535),
                                      LEVEL        DECIMAL(20, 0),
                                      SAMPLE_PCT   DECIMAL(20, 10),
                                      RECORD_POLICY VARCHAR(65535));
  PRAGMA INTERFACE(c, OB_CLIENT_ID_TRACE_ENABLE);
  PROCEDURE OB_CLIENT_ID_TRACE_DISABLE(CLIENT_ID VARCHAR(65535));
  PRAGMA INTERFACE(c, OB_CLIENT_ID_TRACE_DISABLE);

  PROCEDURE OB_MOD_ACT_TRACE_ENABLE(MODULE_NAME     VARCHAR(65535),
                                    ACTION_NAME     VARCHAR(65535),
                                    LEVEL        DECIMAL(20, 0),
                                    SAMPLE_PCT   DECIMAL(20, 10),
                                    RECORD_POLICY VARCHAR(65535));
  PRAGMA INTERFACE(c, OB_MOD_ACT_TRACE_ENABLE);
  PROCEDURE OB_MOD_ACT_TRACE_DISABLE(MODULE_NAME     VARCHAR(65535),
                                     ACTION_NAME     VARCHAR(65535));
  PRAGMA INTERFACE(c, OB_MOD_ACT_TRACE_DISABLE);

  PROCEDURE OB_TENANT_TRACE_ENABLE(LEVEL        DECIMAL(20, 0),
                            SAMPLE_PCT   DECIMAL(20, 10),
                            RECORD_POLICY VARCHAR(65535));
  PRAGMA INTERFACE(c, OB_TENANT_TRACE_ENABLE);
  PROCEDURE OB_TENANT_TRACE_DISABLE(TENANT_NAME  VARCHAR(65535) DEFAULT NULL);
  PRAGMA INTERFACE(c, OB_TENANT_TRACE_DISABLE);
END;


//

)sys_pack_del"
},
{
"dbms_monitor_mysql.sql", // size = 1498 bytes
R"sys_pack_del(#package_name:dbms_monitor
#author: xiaoyi.xy
CREATE OR REPLACE PACKAGE DBMS_MONITOR
  PROCEDURE OB_SESSION_TRACE_ENABLE(SESSION_ID   DECIMAL(20, 0),
                                    LEVEL        DECIMAL(20, 0),
                                    SAMPLE_PCT   DECIMAL(20, 10),
                                    RECORD_POLICY VARCHAR(65535));
  PROCEDURE OB_SESSION_TRACE_DISABLE(session_id   DECIMAL(20, 0));

  PROCEDURE OB_CLIENT_ID_TRACE_ENABLE(CLIENT_ID    VARCHAR(65535),
                                      LEVEL        DECIMAL(20, 0),
                                      SAMPLE_PCT   DECIMAL(20, 10),
                                      RECORD_POLICY VARCHAR(65535));
  PROCEDURE OB_CLIENT_ID_TRACE_DISABLE(CLIENT_ID VARCHAR(65535));

  PROCEDURE OB_MOD_ACT_TRACE_ENABLE(MODULE_NAME     VARCHAR(65535),
                                    ACTION_NAME     VARCHAR(65535),
                                    LEVEL        DECIMAL(20, 0),
                                    SAMPLE_PCT   DECIMAL(20, 10),
                                    RECORD_POLICY VARCHAR(65535));
  PROCEDURE OB_MOD_ACT_TRACE_DISABLE(MODULE_NAME     VARCHAR(65535),
                                    ACTION_NAME     VARCHAR(65535));

  PROCEDURE OB_TENANT_TRACE_ENABLE(LEVEL        DECIMAL(20, 0),
                            SAMPLE_PCT   DECIMAL(20, 10),
                            RECORD_POLICY VARCHAR(65535));
  PROCEDURE OB_TENANT_TRACE_DISABLE(TENANT_NAME  VARCHAR(65535) DEFAULT NULL);
END;


//

)sys_pack_del"
},
{
"dbms_ob_limit_calculator_body_mysql.sql", // size = 2627 bytes
R"sys_pack_del(#package_name:dbms_ob_limit_calculator
#author:cxf262476, yangyifei.yyf

CREATE OR replace PACKAGE BODY dbms_ob_limit_calculator
  PROCEDURE phy_res_calculate_by_logic_res_inner(
    IN  args                                VARCHAR(1024) DEFAULT '',
    OUT res                                 VARCHAR(2048));
  PRAGMA INTERFACE(C, PHY_RES_CALCULATE_BY_LOGIC_RES);

  PROCEDURE phy_res_calculate_by_unit_inner(
    IN  tenant_id                           INTEGER,
    IN  server                              VARCHAR(64),
    OUT res                                 VARCHAR(2048));
  PRAGMA INTERFACE(C, PHY_RES_CALCULATE_BY_UNIT);

  PROCEDURE phy_res_calculate_by_standby_tenant_inner(
    IN  primary_tenant_id                   INTEGER,
    IN  standby_tenant_unit_num             INTEGER,
    OUT res                                 VARCHAR(2048));
  PRAGMA INTERFACE(C, PHY_RES_CALCULATE_BY_STANDBY_TENANT);

  PROCEDURE calculate_min_phy_res_needed_by_unit(
    IN tenant_id                            INTEGER,
    IN server                               VARCHAR(64))
  BEGIN
    DECLARE res VARCHAR(2048);
    CALL phy_res_calculate_by_unit_inner(tenant_id, server, res);
    SELECT * FROM JSON_TABLE(res, '$[*]' COLUMNS (SVR_IP VARCHAR(64) PATH '$.svr_ip',
                                                  SVR_PORT INTEGER PATH '$.svr_port',
                                                  TENANT_ID INTEGER PATH '$.tenant_id',
                                                  PHYSICAL_RESOURCE_NAME  VARCHAR(64) PATH '$.physical_resource_name',
                                                  MIN_VALUE BIGINT PATH '$.min_value')) t;
  END;

  PROCEDURE calculate_min_phy_res_needed_by_logic_res(
    IN args                                 VARCHAR(1024) DEFAULT '')
  BEGIN
    DECLARE res VARCHAR(2048);
    CALL phy_res_calculate_by_logic_res_inner(args, res);
    SELECT * FROM JSON_TABLE(res, '$[*]' COLUMNS (PHYSICAL_RESOURCE_NAME VARCHAR(64) PATH '$.physical_resource_name',
                                                  MIN_VALUE BIGINT PATH '$.min_value')) t;
  END;

  PROCEDURE calculate_min_phy_res_needed_by_standby_tenant(
    IN primary_tenant_id                    INTEGER,
    IN standby_tenant_unit_num              INTEGER)
  BEGIN
    DECLARE res VARCHAR(2048);
    CALL phy_res_calculate_by_standby_tenant_inner(primary_tenant_id, standby_tenant_unit_num, res);
    SELECT * FROM JSON_TABLE(res, '$[*]' COLUMNS (PHYSICAL_RESOURCE_NAME VARCHAR(64) PATH '$.physical_resource_name',
                                                  MIN_VALUE BIGINT PATH '$.min_value')) t;
  END;


END;
//
)sys_pack_del"
},
{
"dbms_ob_limit_calculator_mysql.sql", // size = 616 bytes
R"sys_pack_del(#package_name:dbms_ob_limit_calculator
#author:cxf262476, yangyifei.yyf

CREATE OR REPLACE PACKAGE dbms_ob_limit_calculator
  PROCEDURE calculate_min_phy_res_needed_by_unit(
    IN tenant_id                                  INTEGER,
    IN server                                     VARCHAR(64));
  PROCEDURE calculate_min_phy_res_needed_by_logic_res(
    IN args                                       VARCHAR(1024) DEFAULT '');
  PROCEDURE calculate_min_phy_res_needed_by_standby_tenant(
    IN primary_tenant_id                          INTEGER,
    IN standby_tenant_unit_num                    INTEGER);
END;
//
)sys_pack_del"
},
{
"dbms_profiler.sql", // size = 2049 bytes
R"sys_pack_del(#package_name: dbms_profiler
#author: heyongyi.hyy

CREATE OR REPLACE PACKAGE DBMS_PROFILER
AUTHID CURRENT_USER
AS
  success constant binary_integer := 0;

  error_param constant binary_integer := 1;

  error_io constant binary_integer := 2;

  error_version constant binary_integer := -1;

  version_mismatch exception;
  profiler_error exception;

  major_version constant binary_integer := 2;
  minor_version constant binary_integer := 0;


  function start_profiler(run_comment IN varchar2 := sysdate,
                          run_comment1 IN varchar2 := '',
                          run_number  OUT binary_integer)
    return binary_integer;
  procedure  start_profiler(run_comment IN varchar2 := sysdate,
                            run_comment1 IN varchar2 := '',
                            run_number  OUT binary_integer);

  function start_profiler(run_comment IN varchar2 := sysdate,
                          run_comment1 IN varchar2 := '')
    return binary_integer;
  procedure  start_profiler(run_comment IN varchar2 := sysdate,
                            run_comment1 IN varchar2 := '');


  function stop_profiler return binary_integer;
  procedure stop_profiler;


  function pause_profiler return binary_integer;
  procedure pause_profiler;


  function resume_profiler return binary_integer;
  procedure resume_profiler;


  function flush_data return binary_integer;
  procedure flush_data;


  procedure get_version(major out binary_integer,
                        minor out binary_integer);


  function internal_version_check return binary_integer;


  procedure rollup_unit(run_number IN number, unit IN number);


  procedure rollup_run(run_number IN number);

  --
  -- Create sequence and tables that the profiler needs
  -- if force_create is true, then drop and recreate the tables
  -- otherwise only create objects do not exist
  --
  procedure ob_init_objects(force_create IN boolean := FALSE);

  --
  -- Drop sequence and tables that the profiler may have created
  --
  procedure ob_drop_objects;

END;



//
)sys_pack_del"
},
{
"dbms_profiler_body.sql", // size = 8379 bytes
R"sys_pack_del(#package_name: dbms_profiler
#author: heyongyi.hyy

CREATE OR REPLACE PACKAGE BODY DBMS_PROFILER
AS

  RUN_STATUS VARCHAR2(64) := NULL;

  USER_SCHEMA VARCHAR2(128) := NULL;

  PROFILER_PAUSED CONSTANT BINARY_INTEGER := 0;
  PROFILER_RESUMED CONSTANT BINARY_INTEGER := 1;

  FUNCTION INTERNAL_VERSION_CHECK_INNER(major IN BINARY_INTEGER,
                                        minor IN BINARY_INTEGER)
  RETURN BINARY_INTEGER;
  PRAGMA INTERFACE(c, DBMS_PROFILER_CHECK_VERSION);


  FUNCTION INTERNAL_VERSION_CHECK RETURN BINARY_INTEGER IS
  BEGIN
    RETURN INTERNAL_VERSION_CHECK_INNER(major_version, minor_version);
  END INTERNAL_VERSION_CHECK;



  FUNCTION START_PROFILER_INNER_C(RUN_COMMENT IN VARCHAR2,
                                  RUN_COMMENT1 IN VARCHAR2,
                                  RUN_NUMBER OUT BINARY_INTEGER)
  RETURN BINARY_INTEGER;
  PRAGMA INTERFACE(c, DBMS_PROFILER_START_PROFILER);


  FUNCTION START_PROFILER_INNER(RUN_COMMENT IN VARCHAR2,
                                RUN_COMMENT1 IN VARCHAR2,
                                RUN_NUMBER OUT BINARY_INTEGER)
  RETURN BINARY_INTEGER IS
  local_runid BINARY_INTEGER;
  ret BINARY_INTEGER;
  BEGIN
    IF (RUN_STATUS IS NULL) THEN
      ret := START_PROFILER_INNER_C(run_comment, run_comment1, local_runid);
      IF (ret = SUCCESS) THEN
        RUN_NUMBER := local_runid;
        RUN_STATUS := local_runid || '@' || PROFILER_RESUMED;
      END IF;
      RETURN ret;
    ELSE
      RETURN SUCCESS;
    END IF;
  END START_PROFILER_INNER;


  FUNCTION START_PROFILER(RUN_COMMENT IN VARCHAR2 := SYSDATE,
                          RUN_COMMENT1 IN VARCHAR2 := '',
                          RUN_NUMBER OUT BINARY_INTEGER)
  RETURN BINARY_INTEGER IS
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RETURN ERROR_VERSION;
    END IF;
    RETURN START_PROFILER_INNER(RUN_COMMENT, RUN_COMMENT1, RUN_NUMBER);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN ERROR_IO;
  END START_PROFILER;


  FUNCTION START_PROFILER(RUN_COMMENT IN VARCHAR2 := SYSDATE,
                          RUN_COMMENT1 IN VARCHAR2 := '')
  RETURN BINARY_INTEGER IS
    RUN_NUMBER BINARY_INTEGER;
  BEGIN
    RETURN START_PROFILER(RUN_COMMENT, RUN_COMMENT1, RUN_NUMBER);
  END;


  PROCEDURE START_PROFILER(RUN_COMMENT IN VARCHAR2 := SYSDATE,
                          RUN_COMMENT1 IN VARCHAR2 := '',
                          RUN_NUMBER OUT BINARY_INTEGER) IS
    FUNC_RET BINARY_INTEGER;
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RAISE VERSION_MISMATCH;
    END IF;

    BEGIN
      FUNC_RET := START_PROFILER_INNER(RUN_COMMENT, RUN_COMMENT1, RUN_NUMBER);
      EXCEPTION
        WHEN OTHERS THEN
          RAISE PROFILER_ERROR;
    END;
    IF (FUNC_RET != SUCCESS)
    THEN
      RAISE PROFILER_ERROR;
    END IF;

  END START_PROFILER;


  PROCEDURE START_PROFILER(RUN_COMMENT IN VARCHAR2 := SYSDATE,
                          RUN_COMMENT1 IN VARCHAR2 := '') IS
    RUN_NUMBER BINARY_INTEGER;
  BEGIN
    START_PROFILER(RUN_COMMENT, RUN_COMMENT1, RUN_NUMBER);
  END START_PROFILER;



  FUNCTION STOP_PROFILER_INNER_C RETURN BINARY_INTEGER;
  PRAGMA INTERFACE(c, DBMS_PROFILER_STOP_PROFILER);


  FUNCTION STOP_PROFILER_INNER RETURN BINARY_INTEGER IS
  ret BINARY_INTEGER;
  BEGIN
    IF (RUN_STATUS IS NOT NULL) THEN
      PAUSE_PROFILER();
      FLUSH_DATA();
      ret := STOP_PROFILER_INNER_C;
      RUN_STATUS := NULL;
      RETURN ret;
    ELSE
      RETURN SUCCESS;
    END IF;
  END;


  FUNCTION STOP_PROFILER RETURN BINARY_INTEGER IS
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RETURN ERROR_VERSION;
    END IF;
    RETURN STOP_PROFILER_INNER;
  EXCEPTION
    WHEN OTHERS THEN
      RETURN ERROR_IO;
  END STOP_PROFILER;


  PROCEDURE STOP_PROFILER IS
    FUNC_RET BINARY_INTEGER;
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RAISE VERSION_MISMATCH;
    END IF;

    BEGIN
      FUNC_RET := STOP_PROFILER_INNER;
    EXCEPTION
      WHEN OTHERS THEN
        RAISE PROFILER_ERROR;
    END;
    IF (FUNC_RET != SUCCESS)
    THEN
      RAISE PROFILER_ERROR;
    END IF;
  END STOP_PROFILER;



  FUNCTION CHANGE_PROFILER_STATE_INNER_C(new_state IN BINARY_INTEGER)
  RETURN BINARY_INTEGER;
  PRAGMA INTERFACE(c, DBMS_PROFILER_CHANGE_STATE);


  FUNCTION CHANGE_PROFILER_STATE_INNER(new_state IN BINARY_INTEGER)
  RETURN BINARY_INTEGER IS
  ret BINARY_INTEGER := success;
  local_runid BINARY_INTEGER := -1;
  BEGIN
    IF (RUN_STATUS IS NOT NULL) THEN
      ret := CHANGE_PROFILER_STATE_INNER_C(new_state);

      IF (ret = success) THEN
        local_runid := substr(RUN_STATUS, 1, INSTR(RUN_STATUS, '@') - 1);
        CASE new_state
          WHEN profiler_paused THEN
            RUN_STATUS := local_runid || '@' || PROFILER_PAUSED;
          WHEN profiler_resumed THEN
            RUN_STATUS := local_runid || '@' || PROFILER_RESUMED;
          ELSE
            ret := error_param;
        END CASE;
      END IF;
    END IF;

    RETURN ret;
  END;


  FUNCTION PAUSE_PROFILER RETURN BINARY_INTEGER IS
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RETURN ERROR_VERSION;
    END IF;
    RETURN CHANGE_PROFILER_STATE_INNER(profiler_paused);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN ERROR_IO;
  END;


  PROCEDURE PAUSE_PROFILER IS
    FUNC_RET BINARY_INTEGER;
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RAISE VERSION_MISMATCH;
    END IF;

    BEGIN
      FUNC_RET := CHANGE_PROFILER_STATE_INNER(profiler_paused);
    EXCEPTION
      WHEN OTHERS THEN
        RAISE PROFILER_ERROR;
    END;
    IF (FUNC_RET != SUCCESS)
    THEN
      RAISE PROFILER_ERROR;
    END IF;

  END PAUSE_PROFILER;



  FUNCTION RESUME_PROFILER RETURN BINARY_INTEGER IS
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RETURN ERROR_VERSION;
    END IF;
    RETURN CHANGE_PROFILER_STATE_INNER(profiler_resumed);
  EXCEPTION
    WHEN OTHERS THEN
      RETURN ERROR_IO;
  END;


  PROCEDURE RESUME_PROFILER IS
    FUNC_RET BINARY_INTEGER;
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RAISE VERSION_MISMATCH;
    END IF;

    BEGIN
      FUNC_RET := CHANGE_PROFILER_STATE_INNER(profiler_resumed);
    EXCEPTION
      WHEN OTHERS THEN
        RAISE PROFILER_ERROR;
    END;
    IF (FUNC_RET != SUCCESS)
    THEN
      RAISE PROFILER_ERROR;
    END IF;

  END RESUME_PROFILER;



  FUNCTION FLUSH_DATA_INNER RETURN BINARY_INTEGER;
  PRAGMA INTERFACE(c, DBMS_PROFILER_FLUSH_DATA);


  FUNCTION FLUSH_DATA RETURN BINARY_INTEGER IS
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RETURN ERROR_VERSION;
    END IF;
    RETURN FLUSH_DATA_INNER;
  EXCEPTION
    WHEN OTHERS THEN
      RETURN ERROR_IO;
  END FLUSH_DATA;

  PROCEDURE FLUSH_DATA IS
    FUNC_RET BINARY_INTEGER;
  BEGIN
    IF (INTERNAL_VERSION_CHECK <> 0) THEN
      RAISE VERSION_MISMATCH;
    END IF;
    BEGIN
      FUNC_RET := FLUSH_DATA_INNER;
    EXCEPTION
      WHEN OTHERS THEN
        RAISE PROFILER_ERROR;
    END;
    IF (FUNC_RET != SUCCESS)
    THEN
      RAISE PROFILER_ERROR;
    END IF;
  END FLUSH_DATA;



  PROCEDURE ROLLUP_UNIT(RUN_NUMBER IN NUMBER, UNIT IN NUMBER) IS
  C VARCHAR2(1000);
  BEGIN
     C :=
                'update plsql_profiler_units set total_time = ' ||
                        '(select sum(total_time) from plsql_profiler_data ' ||
            'where runid = ' || RUN_NUMBER || ' and unit_number = ' || UNIT ||
                    ') ' ||
        'where runid = ' || RUN_NUMBER || ' and unit_number = ' || UNIT;
        EXECUTE IMMEDIATE C;
    COMMIT;
  END ROLLUP_UNIT;



  PROCEDURE ROLLUP_RUN(RUN_NUMBER IN NUMBER) IS
    C VARCHAR2(1000);
  BEGIN
      C := 'update plsql_profiler_units p1 ' ||
                  ' set total_time = (select sum(total_time) ' ||
              ' from  plsql_profiler_data p2 ' ||
                          ' where runid= ' || RUN_NUMBER ||
                            ' and p2.unit_number=p1.unit_number) ' ||
                    ' where runid= ' || RUN_NUMBER;
    EXECUTE IMMEDIATE C;
        COMMIT;
  END ROLLUP_RUN;



  PROCEDURE GET_VERSION(MAJOR OUT BINARY_INTEGER,
                        MINOR OUT BINARY_INTEGER) IS
  BEGIN
    MAJOR := MAJOR_VERSION;
    MINOR := MINOR_VERSION;
  END GET_VERSION;

  PROCEDURE OB_INIT_OBJECTS(FORCE_CREATE IN BOOLEAN := FALSE);
  PRAGMA INTERFACE(c, DBMS_PROFILER_INIT_OBJECTS);

  PROCEDURE OB_DROP_OBJECTS;
  PRAGMA INTERFACE(c, DBMS_PROFILER_DROP_OBJECTS);

END;



//)sys_pack_del"
},
{
"dbms_resource_manager_body_mysql.sql", // size = 1827 bytes
R"sys_pack_del(#package_name:dbms_resource_manager
#author:dachuan.sdc

CREATE OR REPLACE PACKAGE BODY dbms_resource_manager

PROCEDURE create_plan (
  plan VARCHAR(65535),
  comment VARCHAR(65535) DEFAULT ''
);
pragma interface (C, CREATE_PLAN_INNER);

PROCEDURE delete_plan (
  plan    VARCHAR(65535)
);
pragma interface (C, DELETE_PLAN_INNER);

PROCEDURE create_consumer_group (
  consumer_group  VARCHAR(65535),
  comment         VARCHAR(65535)  DEFAULT NULL
);
pragma interface (C, CREATE_CONSUMER_GROUP_INNER);

PROCEDURE delete_consumer_group (
  consumer_group VARCHAR(65535)
);
pragma interface (C, DELETE_CONSUMER_GROUP_INNER);

PROCEDURE create_plan_directive (
  plan              VARCHAR(65535),
  group_or_subplan  VARCHAR(65535),
  comment           VARCHAR(65535) DEFAULT '',
  mgmt_p1           INT DEFAULT 100,
  utilization_limit INT DEFAULT 100,
  min_iops          INT DEFAULT 0,
  max_iops          INT DEFAULT 100,
  weight_iops       INT DEFAULT 0
);
pragma interface (C, CREATE_PLAN_DIRECTIVE_INNER);

PROCEDURE update_plan_directive (
  plan                  VARCHAR(65535),
  group_or_subplan      VARCHAR(65535),
  new_comment           VARCHAR(65535) DEFAULT NULL,
  new_mgmt_p1           INT DEFAULT NULL,
  new_utilization_limit INT DEFAULT NULL,
  new_min_iops          INT DEFAULT NULL,
  new_max_iops          INT DEFAULT NULL,
  new_weight_iops       INT DEFAULT NULL
);
pragma interface (C, UPDATE_PLAN_DIRECTIVE_INNER);

PROCEDURE delete_plan_directive (
  plan              VARCHAR(65535),
  group_or_subplan  VARCHAR(65535)
);
pragma interface (C, DELETE_PLAN_DIRECTIVE_INNER);

PROCEDURE set_consumer_group_mapping (
  attribute VARCHAR(65535),
  value VARCHAR(65535),
  consumer_group VARCHAR(65535) DEFAULT NULL
);
pragma interface (C, SET_CONSUMER_GROUP_MAPPING_INNER);


END dbms_resource_manager;
)sys_pack_del"
},
{
"dbms_resource_manager_mysql.sql", // size = 1885 bytes
R"sys_pack_del(#package_name:dbms_resource_manager
#author:dachuan.sdc

--
-- 完整 PL 包参考文档：https://docs.oracle.com/database/121/ARPLS/d_resmgr.htm
--
CREATE OR REPLACE PACKAGE dbms_resource_manager AUTHID CURRENT_USER

--
-- create a resource plan
--
  PROCEDURE create_plan(
    plan    VARCHAR(65535),
    comment VARCHAR(65535) DEFAULT ''
  );

--
-- delete resource plan
--
  PROCEDURE delete_plan(
    plan    VARCHAR(65535)
  );

--
-- create consumer group
--
  PROCEDURE create_consumer_group (
    consumer_group  VARCHAR(65535),
    comment         VARCHAR(65535) DEFAULT NULL
  );

--
-- delete consumer group
--
  PROCEDURE delete_consumer_group (
    consumer_group VARCHAR(65535)
  );

--
-- create plan directive
--
  PROCEDURE create_plan_directive(
    plan              VARCHAR(65535),
    group_or_subplan  VARCHAR(65535),
    comment           VARCHAR(65535) DEFAULT '',
    mgmt_p1           INT DEFAULT 100,
    utilization_limit INT DEFAULT 100,
    min_iops          INT DEFAULT 0,
    max_iops          INT DEFAULT 100,
    weight_iops       INT DEFAULT 0
  );

--
-- update plan directive
--
  PROCEDURE update_plan_directive(
    plan                  VARCHAR(65535),
    group_or_subplan      VARCHAR(65535),
    new_comment           VARCHAR(65535) DEFAULT NULL,
    new_mgmt_p1           INT DEFAULT NULL,
    new_utilization_limit INT DEFAULT NULL,
    new_min_iops          INT DEFAULT NULL,
    new_max_iops          INT DEFAULT NULL,
    new_weight_iops       INT DEFAULT NULL
  );

--
-- delete plan directive
--
  PROCEDURE delete_plan_directive (
    plan              VARCHAR(65535),
    group_or_subplan  VARCHAR(65535)
  );

--
-- set consumer group mapping rule
--
  PROCEDURE set_consumer_group_mapping (
    attribute VARCHAR(65535),
    value VARCHAR(65535),
    consumer_group VARCHAR(65535) DEFAULT NULL
  );



END dbms_resource_manager;
)sys_pack_del"
},
{
"dbms_rls.sql", // size = 15163 bytes
R"sys_pack_del(#package_name:DBMS_RLS
#author: sean.yyj

CREATE OR REPLACE PACKAGE DBMS_RLS AUTHID CURRENT_USER AS

  STATIC                     CONSTANT   BINARY_INTEGER := 1;
  SHARED_STATIC              CONSTANT   BINARY_INTEGER := 2;
  CONTEXT_SENSITIVE          CONSTANT   BINARY_INTEGER := 3;
  SHARED_CONTEXT_SENSITIVE   CONSTANT   BINARY_INTEGER := 4;
  DYNAMIC                    CONSTANT   BINARY_INTEGER := 5;
  XDS1                       CONSTANT   BINARY_INTEGER := 6;
  XDS2                       CONSTANT   BINARY_INTEGER := 7;
  XDS3                       CONSTANT   BINARY_INTEGER := 8;
  OLS                        CONSTANT   BINARY_INTEGER := 9;

  -- security relevant columns options, default is null
  ALL_ROWS                   CONSTANT   BINARY_INTEGER := 1;

  -- Type of refresh on static acl mv
  XDS_ON_COMMIT_MV  CONSTANT BINARY_INTEGER := 0;
  XDS_ON_DEMAND_MV  CONSTANT BINARY_INTEGER := 1;
  XDS_SCHEDULED_MV  CONSTANT BINARY_INTEGER := 2;

  -- Type of static acl mv
  XDS_SYSTEM_GENERATED_MV  CONSTANT BINARY_INTEGER := 0;
  XDS_USER_SPECIFIED_MV    CONSTANT BINARY_INTEGER := 1;

  -- alter options for a row level security policy
  ADD_ATTRIBUTE_ASSOCIATION       CONSTANT   BINARY_INTEGER := 1;
  REMOVE_ATTRIBUTE_ASSOCIATION    CONSTANT   BINARY_INTEGER := 2;


  -- ------------------------------------------------------------------------
  -- add_grouped_policy -  add a row level security policy to a policy group
  --                        for a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_group    - name of group of the policy to be added
  --   policy_name     - name of policy to be added
  --   function_schema - schema of the policy function, current user if NULL
  --   policy_function - function to generate predicates for this policy
  --   statement_types - statement type that the policy apply, default is any
  --   update_check    - policy checked against updated or inserted value?
  --   enable          - policy is enabled?
  --   static_policy   - policy is static (predicate is always the same)?
  --   policy_type     - policy type - overwrite static_policy if non-null
  --   long_predicate  - max predicate length 4000 bytes (default) or 32K
  --   sec_relevant_cols - list of security relevant columns
  --   sec_relevant_cols_opt - security relevant columns option
  --   namespace       - name of application context namespace
  --   attribute       - name of application context attribute

  PROCEDURE add_grouped_policy(object_schema   IN VARCHAR2 := NULL,
                               object_name     IN VARCHAR2,
                               policy_group    IN VARCHAR2 := 'SYS_DEFAULT',
                               policy_name     IN VARCHAR2,
                               function_schema IN VARCHAR2 := NULL,
                               policy_function IN VARCHAR2,
                               statement_types IN VARCHAR2 := NULL,
                               update_check    IN BOOLEAN  := FALSE,
                               enable          IN BOOLEAN  := TRUE,
                               static_policy   IN BOOLEAN  := FALSE,
                               policy_type     IN BINARY_INTEGER := NULL,
                               long_predicate  IN BOOLEAN  := FALSE,
                               sec_relevant_cols IN VARCHAR2  := NULL,
                               sec_relevant_cols_opt IN BINARY_INTEGER := NULL,
                               namespace       IN VARCHAR2 := NULL,
                               attribute       IN VARCHAR2 := NULL);

  -- ------------------------------------------------------------------------
  -- add_policy -  add a row level security policy to a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_name     - name of policy to be added
  --   function_schema - schema of the policy function, current user if NULL
  --   policy_function - function to generate predicates for this policy
  --   statement_types - statement type that the policy apply, default is any
  --   update_check    - policy checked against updated or inserted value?
  --   enable          - policy is enabled?
  --   static_policy   - policy is static (predicate is always the same)?
  --   policy_type     - policy type - overwrite static_policy if non-null
  --   long_predicate  - max predicate length 4000 bytes (default) or 32K
  --   sec_relevant_cols - list of security relevant columns
  --   sec_relevant_cols_opt - security relevant column option
  --   namespace       - name of application context namespace
  --   attribute       - name of application context attribute

  PROCEDURE add_policy(object_schema   IN VARCHAR2 := NULL,
                       object_name     IN VARCHAR2,
                       policy_name     IN VARCHAR2,
                       function_schema IN VARCHAR2 := NULL,
                       policy_function IN VARCHAR2,
                       statement_types IN VARCHAR2 := NULL,
                       update_check    IN BOOLEAN  := FALSE,
                       enable          IN BOOLEAN  := TRUE,
                       static_policy   IN BOOLEAN  := FALSE,
                       policy_type     IN BINARY_INTEGER := NULL,
                       long_predicate  IN BOOLEAN  := FALSE,
                       sec_relevant_cols IN VARCHAR2  := NULL,
                       sec_relevant_cols_opt IN BINARY_INTEGER := NULL,
                       namespace       IN VARCHAR2 := NULL,
                       attribute       IN VARCHAR2 := NULL);

  -- ------------------------------------------------------------------------
  -- add_policy_context -  add a driving context to a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   namespace       - namespace of driving context
  --   attribute       - attribute of driving context

  PROCEDURE add_policy_context(object_schema   IN VARCHAR2 := NULL,
                               object_name     IN VARCHAR2,
                               namespace       IN VARCHAR2,
                               attribute       IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- alter_policy -  alter a row level security policy
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_name     - name of policy to be added
  --   alter_option    - addition/removal of attribute association
  --   namespace       - name of application context namespace
  --   attribute       - name of application context attribute

  PROCEDURE alter_policy(object_schema IN VARCHAR2 := NULL,
                         object_name     IN VARCHAR2,
                         policy_name     IN VARCHAR2,
                         alter_option    IN BINARY_INTEGER := NULL,
                         namespace       IN VARCHAR2,
                         attribute       IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- alter_grouped_policy -  alter a row level security policy of a
  --                         policy group
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_group    - name of group of the policy to be altered
  --   policy_name     - name of policy to be altered
  --   alter_option    - addition/removal of attribute association
  --   namespace       - name of application context namespace
  --   attribute       - name of application context attribute

  PROCEDURE alter_grouped_policy(object_schema   IN VARCHAR2 := NULL,
                                 object_name     IN VARCHAR2,
                                 policy_group    IN VARCHAR2 := 'SYS_DEFAULT',
                                 policy_name     IN VARCHAR2,
                                 alter_option    IN BINARY_INTEGER := NULL,
                                 namespace       IN VARCHAR2,
                                 attribute       IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- create_policy_group - create a policy group for a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_group    - name of policy group to be created

  PROCEDURE create_policy_group(object_schema IN VARCHAR2 := NULL,
                                object_name   IN VARCHAR2,
                                policy_group  IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- delete_policy_group - drop a policy group for a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_group    - name of policy group to be dropped

  PROCEDURE delete_policy_group(object_schema IN VARCHAR2 := NULL,
                                object_name   IN VARCHAR2,
                                policy_group  IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- disable_grouped_policy - enable or disable a policy for a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   group_name    - name of group of the policy to be refreshed
  --   policy_name     - name of policy to be enabled or disabled

  PROCEDURE disable_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                   object_name   IN VARCHAR2,
                                   group_name    IN VARCHAR2,
                                   policy_name   IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- drop_grouped_policy - drop a row level security policy from a policy
  --                          group of a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_group    - name of policy to be dropped
  --   policy_name     - name of policy to be dropped

  PROCEDURE drop_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                object_name   IN VARCHAR2,
                                policy_group  IN VARCHAR2 := 'SYS_DEFAULT',
                                policy_name   IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- drop_policy - drop a row level security policy from a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_name     - name of policy to be dropped

  PROCEDURE drop_policy(object_schema IN VARCHAR2 := NULL,
                        object_name   IN VARCHAR2,
                        policy_name   IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- drop_policy_context -  drop a driving context from a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   namespace       - namespace of driving context
  --   attribute       - attribute of driving context

  PROCEDURE drop_policy_context(object_schema   IN VARCHAR2 := NULL,
                                object_name     IN VARCHAR2,
                                namespace       IN VARCHAR2,
                                attribute       IN VARCHAR2);

  -- ------------------------------------------------------------------------
  -- enable_grouped_policy - enable or disable a policy for a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   group_name      - name of group of the policy to be enabled or disabled
  --   policy_name     - name of policy to be enabled or disabled
  --   enable          - TRUE to enable the policy, FALSE to disable the policy

  PROCEDURE enable_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                  object_name   IN VARCHAR2,
                                  group_name    IN VARCHAR2,
                                  policy_name   IN VARCHAR2,
                                  enable        IN BOOLEAN := TRUE);

  -- ------------------------------------------------------------------------
  -- enable_policy - enable or disable a security policy for a table or view
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_name     - name of policy to be enabled or disabled
  --   enable          - TRUE to enable the policy, FALSE to disable the policy

  PROCEDURE enable_policy(object_schema IN VARCHAR2 := NULL,
                          object_name   IN VARCHAR2,
                          policy_name   IN VARCHAR2,
                          enable        IN BOOLEAN := TRUE );

  -- ------------------------------------------------------------------------
  -- refresh_grouped_policy - invalidate all cursors associated with the policy
  --                  if no argument provides, all cursors with
  --                  policies involved will be invalidated
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   group_name      - name of group of the policy to be refreshed
  --   policy_name     - name of policy to be refreshed

  PROCEDURE refresh_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                   object_name   IN VARCHAR2 := NULL,
                                   group_name    IN VARCHAR2 := NULL,
                                   policy_name   IN VARCHAR2 := NULL);

  -- ------------------------------------------------------------------------
  -- refresh_policy - invalidate all cursors associated with the policy
  --                  if no argument provides, all cursors with
  --                  policies involved will be invalidated
  --
  -- INPUT PARAMETERS
  --   object_schema   - schema owning the table/view, current user if NULL
  --   object_name     - name of table or view
  --   policy_name     - name of policy to be refreshed

  PROCEDURE refresh_policy(object_schema IN VARCHAR2 := NULL,
                           object_name   IN VARCHAR2 := NULL,
                           policy_name   IN VARCHAR2 := NULL);

END DBMS_RLS;
//
)sys_pack_del"
},
{
"dbms_rls_body.sql", // size = 6200 bytes
R"sys_pack_del(#package_name:DBMS_RLS
#author: sean.yyj

CREATE OR REPLACE PACKAGE BODY DBMS_RLS AS

  PROCEDURE add_grouped_policy(object_schema   IN VARCHAR2 := NULL,
                               object_name     IN VARCHAR2,
                               policy_group    IN VARCHAR2 := 'SYS_DEFAULT',
                               policy_name     IN VARCHAR2,
                               function_schema IN VARCHAR2 := NULL,
                               policy_function IN VARCHAR2,
                               statement_types IN VARCHAR2 := NULL,
                               update_check    IN BOOLEAN  := FALSE,
                               enable          IN BOOLEAN  := TRUE,
                               static_policy   IN BOOLEAN  := FALSE,
                               policy_type     IN BINARY_INTEGER := NULL,
                               long_predicate  IN BOOLEAN  := FALSE,
                               sec_relevant_cols IN VARCHAR2  := NULL,
                               sec_relevant_cols_opt IN BINARY_INTEGER := NULL,
                               namespace       IN VARCHAR2 := NULL,
                               attribute       IN VARCHAR2 := NULL);
  PRAGMA INTERFACE(c, rls_add_grouped_policy);

  PROCEDURE add_policy(object_schema   IN VARCHAR2 := NULL,
                       object_name     IN VARCHAR2,
                       policy_name     IN VARCHAR2,
                       function_schema IN VARCHAR2 := NULL,
                       policy_function IN VARCHAR2,
                       statement_types IN VARCHAR2 := NULL,
                       update_check    IN BOOLEAN  := FALSE,
                       enable          IN BOOLEAN  := TRUE,
                       static_policy   IN BOOLEAN  := FALSE,
                       policy_type     IN BINARY_INTEGER := NULL,
                       long_predicate  IN BOOLEAN  := FALSE,
                       sec_relevant_cols IN VARCHAR2  := NULL,
                       sec_relevant_cols_opt IN BINARY_INTEGER := NULL,
                       namespace       IN VARCHAR2 := NULL,
                       attribute       IN VARCHAR2 := NULL);
  PRAGMA INTERFACE(c, rls_add_policy);

  PROCEDURE add_policy_context(object_schema   IN VARCHAR2 := NULL,
                               object_name     IN VARCHAR2,
                               namespace       IN VARCHAR2,
                               attribute       IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_add_policy_context);

  PROCEDURE alter_policy(object_schema IN VARCHAR2 := NULL,
                         object_name     IN VARCHAR2,
                         policy_name     IN VARCHAR2,
                         alter_option    IN BINARY_INTEGER := NULL,
                         namespace       IN VARCHAR2,
                         attribute       IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_alter_policy);

  PROCEDURE alter_grouped_policy(object_schema   IN VARCHAR2 := NULL,
                                 object_name     IN VARCHAR2,
                                 policy_group    IN VARCHAR2 := 'SYS_DEFAULT',
                                 policy_name     IN VARCHAR2,
                                 alter_option    IN BINARY_INTEGER := NULL,
                                 namespace       IN VARCHAR2,
                                 attribute       IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_alter_grouped_policy);

  PROCEDURE create_policy_group(object_schema IN VARCHAR2 := NULL,
                                object_name   IN VARCHAR2,
                                policy_group  IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_create_policy_group);

  PROCEDURE delete_policy_group(object_schema IN VARCHAR2 := NULL,
                                object_name   IN VARCHAR2,
                                policy_group  IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_delete_policy_group);

  PROCEDURE disable_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                   object_name   IN VARCHAR2,
                                   group_name    IN VARCHAR2,
                                   policy_name   IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_disable_grouped_policy);

  PROCEDURE drop_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                object_name   IN VARCHAR2,
                                policy_group  IN VARCHAR2 := 'SYS_DEFAULT',
                                policy_name   IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_drop_grouped_policy);

  PROCEDURE drop_policy(object_schema IN VARCHAR2 := NULL,
                        object_name   IN VARCHAR2,
                        policy_name   IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_drop_policy);

  PROCEDURE drop_policy_context(object_schema   IN VARCHAR2 := NULL,
                                object_name     IN VARCHAR2,
                                namespace       IN VARCHAR2,
                                attribute       IN VARCHAR2);
  PRAGMA INTERFACE(c, rls_drop_policy_context);

  PROCEDURE enable_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                  object_name   IN VARCHAR2,
                                  group_name    IN VARCHAR2,
                                  policy_name   IN VARCHAR2,
                                  enable        IN BOOLEAN := TRUE);
  PRAGMA INTERFACE(c, rls_enable_grouped_policy);

  PROCEDURE enable_policy(object_schema IN VARCHAR2 := NULL,
                          object_name   IN VARCHAR2,
                          policy_name   IN VARCHAR2,
                          enable        IN BOOLEAN := TRUE );
  PRAGMA INTERFACE(c, rls_enable_policy);

  PROCEDURE refresh_grouped_policy(object_schema IN VARCHAR2 := NULL,
                                   object_name   IN VARCHAR2 := NULL,
                                   group_name    IN VARCHAR2 := NULL,
                                   policy_name   IN VARCHAR2 := NULL);
  PRAGMA INTERFACE(c, rls_refresh_grouped_policy);

  PROCEDURE refresh_policy(object_schema IN VARCHAR2 := NULL,
                           object_name   IN VARCHAR2 := NULL,
                           policy_name   IN VARCHAR2 := NULL);
  PRAGMA INTERFACE(c, rls_refresh_policy);

END DBMS_RLS
//
)sys_pack_del"
},
{
"dbms_scheduler_mysql.sql", // size = 620 bytes
R"sys_pack_del(CREATE OR REPLACE PACKAGE dbms_scheduler

  PROCEDURE create_job    ( job_name            VARCHAR(65535),
                            enabled             BOOLEAN DEFAULT FALSE);

  PROCEDURE enable ( job_name  VARCHAR(65535));

  PROCEDURE disable ( job_name          VARCHAR(65535),
                      force             BOOLEAN DEFAULT FALSE,
                      commit_semantics  VARCHAR(65535) DEFAULT  'STOP_ON_FIRST_ERROR');

  PROCEDURE set_attribute ( job_name  VARCHAR(65535),
                            name      VARCHAR(65535),
                            value     VARCHAR(65535));

END dbms_scheduler;
)sys_pack_del"
},
{
"dbms_scheduler_mysql_body.sql", // size = 845 bytes
R"sys_pack_del(CREATE OR REPLACE PACKAGE BODY dbms_scheduler

  PROCEDURE create_job    ( job_name            VARCHAR(65535),
                            enabled             BOOLEAN DEFAULT FALSE);
  PRAGMA INTERFACE(C, DBMS_SCHEDULER_MYSQL_CREATE_JOB);

  PROCEDURE enable ( job_name  VARCHAR(65535));
  PRAGMA INTERFACE(C, DBMS_SCHEDULER_MYSQL_ENABLE);

  PROCEDURE disable ( job_name          VARCHAR(65535),
                      force             BOOLEAN DEFAULT FALSE,
                      commit_semantics  VARCHAR(65535) DEFAULT  'STOP_ON_FIRST_ERROR');
  PRAGMA INTERFACE(C, DBMS_SCHEDULER_MYSQL_DISABLE);

  PROCEDURE set_attribute ( job_name  VARCHAR(65535),
                            name      VARCHAR(65535),
                            value     VARCHAR(65535));
  PRAGMA INTERFACE(C, DBMS_SCHEDULER_MYSQL_SET_ATTRIBUTE);

END dbms_scheduler;
)sys_pack_del"
},
{
"dbms_session_body_mysql.sql", // size = 218 bytes
R"sys_pack_del(CREATE OR REPLACE PACKAGE BODY DBMS_SESSION
  PROCEDURE SET_IDENTIFIER(CLIENT_ID VARCHAR(65535));
  PRAGMA INTERFACE(c, SET_IDENTIFIER);
  PROCEDURE CLEAR_IDENTIFIER();
  PRAGMA INTERFACE(c, CLEAR_IDENTIFIER);
END;
//
)sys_pack_del"
},
{
"dbms_session_mysql.sql", // size = 314 bytes
R"sys_pack_del(#package_name:dbms_session
#author: peihan.dph

CREATE OR REPLACE PACKAGE DBMS_SESSION
PROCEDURE SET_IDENTIFIER(CLIENT_ID VARCHAR(65535));
  --    Input parameters: 
  --    client_id
  --      client identifier being set for this session .
PROCEDURE CLEAR_IDENTIFIER();
  -- Input parameters:
  --   none
END;
//
)sys_pack_del"
},
{
"dbms_stats_body_mysql.sql", // size = 17634 bytes
R"sys_pack_del(# package_name : dbms_stats_mysql
# author : jiangxiu.wt

CREATE OR REPLACE PACKAGE BODY dbms_stats
    PROCEDURE gather_table_stats (
      ownname            VARCHAR(65535),
      tabname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      estimate_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      block_sample       BOOLEAN DEFAULT NULL,
      method_opt         VARCHAR(65535) DEFAULT DEFAULT_METHOD_OPT,
      degree             DECIMAL(20, 10) DEFAULT NULL,
      granularity        VARCHAR(65535) DEFAULT DEFAULT_GRANULARITY,
      cascade            BOOLEAN DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      stattype           VARCHAR(65535) DEFAULT 'DATA',
      force              BOOLEAN DEFAULT FALSE,
      hist_est_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      hist_block_sample  BOOLEAN DEFAULT NULL
    );
    PRAGMA INTERFACE(C, GATHER_TABLE_STATS);

    PROCEDURE gather_schema_stats (
      ownname            VARCHAR(65535),
      estimate_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      block_sample       BOOLEAN DEFAULT NULL,
      method_opt         VARCHAR(65535) DEFAULT DEFAULT_METHOD_OPT,
      degree             DECIMAL(20, 10) DEFAULT NULL,
      granularity        VARCHAR(65535) DEFAULT DEFAULT_GRANULARITY,
      cascade            BOOLEAN DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      stattype           VARCHAR(65535) DEFAULT 'DATA',
      force              BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, GATHER_SCHEMA_STATS);

    PROCEDURE gather_index_stats (
      ownname            VARCHAR(65535),
      indname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      estimate_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      degree             DECIMAL(20, 10) DEFAULT NULL,
      granularity        VARCHAR(65535) DEFAULT DEFAULT_GRANULARITY,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      force              BOOLEAN DEFAULT FALSE,
      tabname            VARCHAR(65535) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, GATHER_INDEX_STATS);

    PROCEDURE set_table_stats (
      ownname            VARCHAR(65535),
      tabname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      numrows            DECIMAL(20, 10) DEFAULT NULL,
      numblks            DECIMAL(20, 10) DEFAULT NULL,
      avgrlen            DECIMAL(20, 10) DEFAULT NULL,
      flags              DECIMAL(20, 10) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      cachedblk          DECIMAL(20, 10) DEFAULT NULL,
      cachehit           DECIMAL(20, 10) DEFAULT NULL,
      force              BOOLEAN DEFAULT FALSE,
      nummacroblks       DECIMAL(20, 10) DEFAULT NULL,
      nummicroblks       DECIMAL(20, 10) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, SET_TABLE_STATS);

    PROCEDURE set_column_stats (
      ownname            VARCHAR(65535),
      tabname            VARCHAR(65535),
      colname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      distcnt            DECIMAL(20, 10) DEFAULT NULL,
      density            DECIMAL(20, 10) DEFAULT NULL,
      nullcnt            DECIMAL(20, 10) DEFAULT NULL,
      epc                DECIMAL(20, 10) DEFAULT NULL,
      minval             TEXT DEFAULT NULL,
      maxval             TEXT DEFAULT NULL,
      bkvals             TEXT DEFAULT NULL,
      novals             TEXT DEFAULT NULL,
      chvals             TEXT DEFAULT NULL,
      eavals             TEXT DEFAULT NULL,
      rpcnts             TEXT DEFAULT NULL,
      eavs               DECIMAL(20, 10) DEFAULT NULL,
      avgclen            DECIMAL(20, 10) DEFAULT NULL,
      flags              DECIMAL(20, 10) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      force              BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, SET_COLUMN_STATS);

    PROCEDURE set_index_stats (
      ownname            VARCHAR(65535),
      indname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      numrows            DECIMAL(20, 10)    DEFAULT NULL,
      numlblks           DECIMAL(20, 10)    DEFAULT NULL,
      numdist            DECIMAL(20, 10)    DEFAULT NULL,
      avglblk            DECIMAL(20, 10)    DEFAULT NULL,
      avgdblk            DECIMAL(20, 10)    DEFAULT NULL,
      clstfct            DECIMAL(20, 10)    DEFAULT NULL,
      indlevel           DECIMAL(20, 10)    DEFAULT NULL,
      flags              DECIMAL(20, 10)    DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN    DEFAULT FALSE,
      guessq             DECIMAL(20, 10)    DEFAULT NULL,
      cachedblk          DECIMAL(20, 10)    DEFAULT NULL,
      cachehit           DECIMAL(20, 10)    DEFAULT NULL,
      force              BOOLEAN    DEFAULT FALSE,
      avgrlen            DECIMAL(20, 10)    DEFAULT NULL,
      nummacroblks       DECIMAL(20, 10)    DEFAULT NULL,
      nummicroblks       DECIMAL(20, 10)    DEFAULT NULL,
      tabname            VARCHAR(65535) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, SET_INDEX_STATS);

    PROCEDURE delete_table_stats (
      ownname           VARCHAR(65535),
      tabname           VARCHAR(65535),
      partname          VARCHAR(65535) DEFAULT NULL,
      stattab           VARCHAR(65535) DEFAULT NULL,
      statid            VARCHAR(65535) DEFAULT NULL,
      cascade_parts     BOOLEAN DEFAULT TRUE,
      cascade_columns   BOOLEAN DEFAULT TRUE,
      cascade_indexes   BOOLEAN DEFAULT TRUE,
      statown           VARCHAR(65535) DEFAULT NULL,
      no_invalidate     BOOLEAN DEFAULT FALSE,
      force             BOOLEAN DEFAULT FALSE,
      degree            DECIMAL(20, 10) DEFAULT 1
    );
    PRAGMA INTERFACE(C, DELETE_TABLE_STATS);

    PROCEDURE delete_column_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      colname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535) DEFAULT NULL,
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade_parts    BOOLEAN DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE,
      col_stat_type    VARCHAR(65535) DEFAULT 'ALL',
      degree           DECIMAL(20, 10) DEFAULT 1
    );
    PRAGMA INTERFACE(C, DELETE_COLUMN_STATS);

    procedure delete_index_stats(
      ownname          VARCHAR(65535),
      indname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535) DEFAULT NULL,
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade_parts    BOOLEAN        DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN        DEFAULT FALSE,
      stattype         VARCHAR(65535) DEFAULT 'ALL',
      force            BOOLEAN        DEFAULT FALSE,
      tabname          VARCHAR(65535) DEFAULT NULL,
      degree           DECIMAL(20, 10) DEFAULT 1
    );
    PRAGMA INTERFACE(C, DELETE_INDEX_STATS);

    PROCEDURE delete_schema_stats (
      ownname           VARCHAR(65535),
      stattab           VARCHAR(65535) DEFAULT NULL,
      statid            VARCHAR(65535) DEFAULT NULL,
      statown           VARCHAR(65535) DEFAULT NULL,
      no_invalidate     BOOLEAN DEFAULT FALSE,
      force             BOOLEAN DEFAULT FALSE,
      degree            DECIMAL(20, 10) DEFAULT 1
    );
    PRAGMA INTERFACE(C, DELETE_SCHEMA_STATS);

    PROCEDURE FLUSH_DATABASE_MONITORING_INFO();
    PRAGMA INTERFACE(C, FLUSH_DATABASE_MONITORING_INFO);

    PROCEDURE GATHER_DATABASE_STATS_JOB_PROC(duration BIGINT DEFAULT NULL);
    PRAGMA INTERFACE(C, GATHER_DATABASE_STATS_JOB_PROC);

    PROCEDURE create_stat_table(
      ownname          VARCHAR(65535),
      stattab          VARCHAR(65535),
      tblspace         VARCHAR(65535) DEFAULT NULL,
      global_temporary BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, CREATE_STAT_TABLE);

    PROCEDURE drop_stat_table(
      ownname VARCHAR(65535),
      stattab VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, DROP_STAT_TABLE);

     PROCEDURE export_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade          BOOLEAN DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      stat_category    VARCHAR(65535) DEFAULT DEFAULT_STAT_CATEGORY
    );
    PRAGMA INTERFACE(C, EXPORT_TABLE_STATS);

    PROCEDURE export_column_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      colname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, EXPORT_COLUMN_STATS);

    PROCEDURE export_schema_stats (
      ownname          VARCHAR(65535),
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, EXPORT_SCHEMA_STATS);


    PROCEDURE export_index_stats (
      ownname           VARCHAR(65535),
      indname           VARCHAR(65535),
      partname          VARCHAR(65535) DEFAULT NULL,
      stattab           VARCHAR(65535),
      statid            VARCHAR(65535) DEFAULT NULL,
      statown           VARCHAR(65535) DEFAULT NULL,
      tabname           VARCHAR(65535) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, EXPORT_INDEX_STATS);

    PROCEDURE import_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade          BOOLEAN DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE,
      stat_category    VARCHAR(65535) DEFAULT DEFAULT_STAT_CATEGORY
    );
    PRAGMA INTERFACE(C, IMPORT_TABLE_STATS);

    PROCEDURE import_column_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      colname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, IMPORT_COLUMN_STATS);

    PROCEDURE import_schema_stats (
      ownname          VARCHAR(65535),
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, IMPORT_SCHEMA_STATS);

    PROCEDURE import_index_stats (
      ownname          VARCHAR(65535),
      indname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE,
      tabname          VARCHAR(65535) DEFAULT NULL
    );
    PRAGMA INTERFACE(C, IMPORT_INDEX_STATS);

    PROCEDURE lock_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      stattype         VARCHAR(65535) DEFAULT 'ALL'
    );
    PRAGMA INTERFACE(C, LOCK_TABLE_STATS);

    PROCEDURE lock_partition_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, LOCK_PARTITION_STATS);

    PROCEDURE lock_schema_stats(
      ownname          VARCHAR(65535),
      STATTYPE         VARCHAR(65535) DEFAULT 'ALL'
    );
    PRAGMA INTERFACE(C, LOCK_SCHEMA_STATS);

    PROCEDURE unlock_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      stattype         VARCHAR(65535) DEFAULT 'ALL'
    );
    PRAGMA INTERFACE(C, UNLOCK_TABLE_STATS);

    PROCEDURE unlock_partition_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, UNLOCK_PARTITION_STATS);

    PROCEDURE unlock_schema_stats(
      ownname          VARCHAR(65535),
      STATTYPE         VARCHAR(65535) DEFAULT 'ALL'
    );
    PRAGMA INTERFACE(C, UNLOCK_SCHEMA_STATS);

    PROCEDURE restore_table_stats (
      ownname               VARCHAR(65535),
      tabname               VARCHAR(65535),
      as_of_timestamp       DATETIME(6),
      restore_cluster_index BOOLEAN DEFAULT FALSE,
      force                 BOOLEAN DEFAULT FALSE,
      no_invalidate         BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, RESTORE_TABLE_STATS);

    PROCEDURE restore_schema_stats (
      ownname               VARCHAR(65535),
      as_of_timestamp       DATETIME(6),
      force                 BOOLEAN DEFAULT FALSE,
      no_invalidate         BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, RESTORE_SCHEMA_STATS);

    PROCEDURE purge_stats(
      before_timestamp      DATETIME(6)
    );
    PRAGMA INTERFACE(C, PURGE_STATS);

    PROCEDURE alter_stats_history_retention(
      retention             DECIMAL(20, 10)
    );
    PRAGMA INTERFACE(C, ALTER_STATS_HISTORY_RETENTION);

    FUNCTION get_stats_history_availability() RETURN DATETIME(6);
    PRAGMA INTERFACE(C, GET_STATS_HISTORY_AVAILABILITY);

    FUNCTION get_stats_history_retention() RETURN DECIMAL;
    PRAGMA INTERFACE(C, GET_STATS_HISTORY_RETENTION);

    PROCEDURE reset_global_pref_defaults();
    PRAGMA INTERFACE(C, RESET_GLOBAL_PREF_DEFAULTS);

    PROCEDURE reset_param_defaults()
    BEGIN
      call reset_global_pref_defaults();
    END;

    PROCEDURE set_global_prefs(
      pname         VARCHAR(65535),
      pvalue        VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, SET_GLOBAL_PREFS);

    PROCEDURE set_param(pname VARCHAR(65535), pval VARCHAR(65535))
    BEGIN
      call set_global_prefs(pname, pval);
    END;

    PROCEDURE set_schema_prefs(
      ownname        VARCHAR(65535),
      pname          VARCHAR(65535),
      pvalue         VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, SET_SCHEMA_PREFS);

    PROCEDURE set_table_prefs(
      ownname        VARCHAR(65535),
      tabname        VARCHAR(65535),
      pname          VARCHAR(65535),
      pvalue         VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, SET_TABLE_PREFS);

    FUNCTION get_prefs (
      pname           VARCHAR(65535),
      ownname         VARCHAR(65535) DEFAULT NULL,
      tabname         VARCHAR(65535) DEFAULT NULL
    ) RETURN VARCHAR(65535);
    PRAGMA INTERFACE(C, GET_PREFS);

    FUNCTION get_param (
      pname           VARCHAR(65535)
    )RETURN VARCHAR(65535)
    BEGIN
      RETURN dbms_stats.get_prefs(pname);
    END;

    PROCEDURE delete_schema_prefs(
      ownname        VARCHAR(65535),
      pname          VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, DELETE_SCHEMA_PREFS);

    PROCEDURE delete_table_prefs (
      ownname        VARCHAR(65535),
      tabname        VARCHAR(65535),
      pname          VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, DELETE_TABLE_PREFS);

    PROCEDURE copy_table_stats (
      ownname        VARCHAR(65535),
      tabname        VARCHAR(65535),
      srcpartname    VARCHAR(65535),
      dstpartname		 VARCHAR(65535),
      scale_factor	 DECIMAL(20, 10) DEFAULT 1,
      flags					 DECIMAL(20, 10) DEFAULT NULL,
      force          BOOLEAN DEFAULT FALSE
    );
    PRAGMA INTERFACE(C, COPY_TABLE_STATS);

    PROCEDURE cancel_gather_stats (
      taskid          VARCHAR(65535)
    );
    PRAGMA INTERFACE(C, CANCEL_GATHER_STATS);

    PROCEDURE GATHER_SYSTEM_STATS();
    PRAGMA INTERFACE(C, GATHER_SYSTEM_STATS);

    PROCEDURE DELETE_SYSTEM_STATS();
    PRAGMA INTERFACE(C, DELETE_SYSTEM_STATS);

    PROCEDURE SET_SYSTEM_STATS (
      pname          VARCHAR(65535),
      pvalue         DECIMAL(20, 10)
    );
    PRAGMA INTERFACE(C, SET_SYSTEM_STATS);

    PROCEDURE async_gather_stats_job_proc (duration BIGINT DEFAULT NULL);
    PRAGMA INTERFACE(C, ASYNC_GATHER_STATS_JOB_PROC);
END dbms_stats;
)sys_pack_del"
},
{
"dbms_stats_mysql.sql", // size = 15589 bytes
R"sys_pack_del(# package_name : dbms_stats_mysql
# author : jiangxiu.wt

create or replace PACKAGE dbms_stats AUTHID CURRENT_USER

    DECLARE DEFAULT_METHOD_OPT     VARCHAR(1) DEFAULT 'Z';
    DECLARE DEFAULT_GRANULARITY    VARCHAR(1) DEFAULT 'Z';
    DECLARE AUTO_SAMPLE_SIZE       DECIMAL(20, 10) DEFAULT 0;
    DECLARE DEFAULT_STAT_CATEGORY  VARCHAR(20) DEFAULT 'OBJECT_STATS';

    PROCEDURE gather_table_stats (
      ownname            VARCHAR(65535),
      tabname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      estimate_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      block_sample       BOOLEAN DEFAULT NULL,
      method_opt         VARCHAR(65535) DEFAULT DEFAULT_METHOD_OPT,
      degree             DECIMAL(20, 10) DEFAULT NULL,
      granularity        VARCHAR(65535) DEFAULT DEFAULT_GRANULARITY,
      cascade            BOOLEAN DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      stattype           VARCHAR(65535) DEFAULT 'DATA',
      force              BOOLEAN DEFAULT FALSE,
      hist_est_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      hist_block_sample  BOOLEAN DEFAULT NULL
    );

    PROCEDURE gather_schema_stats (
      ownname            VARCHAR(65535),
      estimate_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      block_sample       BOOLEAN DEFAULT NULL,
      method_opt         VARCHAR(65535) DEFAULT DEFAULT_METHOD_OPT,
      degree             DECIMAL(20, 10) DEFAULT NULL,
      granularity        VARCHAR(65535) DEFAULT DEFAULT_GRANULARITY,
      cascade            BOOLEAN DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      stattype           VARCHAR(65535) DEFAULT 'DATA',
      force              BOOLEAN DEFAULT FALSE
    );

    PROCEDURE gather_index_stats (
      ownname            VARCHAR(65535),
      indname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      estimate_percent   DECIMAL(20, 10) DEFAULT AUTO_SAMPLE_SIZE,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      degree             DECIMAL(20, 10) DEFAULT NULL,
      granularity        VARCHAR(65535) DEFAULT DEFAULT_GRANULARITY,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      force              BOOLEAN DEFAULT FALSE,
      tabname            VARCHAR(65535) DEFAULT NULL
    );

    PROCEDURE set_table_stats (
      ownname            VARCHAR(65535),
      tabname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      numrows            DECIMAL(20, 10) DEFAULT NULL,
      numblks            DECIMAL(20, 10) DEFAULT NULL,
      avgrlen            DECIMAL(20, 10) DEFAULT NULL,
      flags              DECIMAL(20, 10) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      cachedblk          DECIMAL(20, 10) DEFAULT NULL,
      cachehit           DECIMAL(20, 10) DEFAULT NULL,
      force              BOOLEAN DEFAULT FALSE,
      nummacroblks       DECIMAL(20, 10) DEFAULT NULL,
      nummicroblks       DECIMAL(20, 10) DEFAULT NULL
    );

    PROCEDURE set_column_stats (
      ownname            VARCHAR(65535),
      tabname            VARCHAR(65535),
      colname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      distcnt            DECIMAL(20, 10) DEFAULT NULL,
      density            DECIMAL(20, 10) DEFAULT NULL,
      nullcnt            DECIMAL(20, 10) DEFAULT NULL,
      epc                DECIMAL(20, 10) DEFAULT NULL,
      minval             TEXT DEFAULT NULL,
      maxval             TEXT DEFAULT NULL,
      bkvals             TEXT DEFAULT NULL,
      novals             TEXT DEFAULT NULL,
      chvals             TEXT DEFAULT NULL,
      eavals             TEXT DEFAULT NULL,
      rpcnts             TEXT DEFAULT NULL,
      eavs               DECIMAL(20, 10) DEFAULT NULL,
      avgclen            DECIMAL(20, 10) DEFAULT NULL,
      flags              DECIMAL(20, 10) DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN DEFAULT FALSE,
      force              BOOLEAN DEFAULT FALSE
    );

    PROCEDURE set_index_stats (
      ownname            VARCHAR(65535),
      indname            VARCHAR(65535),
      partname           VARCHAR(65535) DEFAULT NULL,
      stattab            VARCHAR(65535) DEFAULT NULL,
      statid             VARCHAR(65535) DEFAULT NULL,
      numrows            DECIMAL(20, 10)    DEFAULT NULL,
      numlblks           DECIMAL(20, 10)    DEFAULT NULL,
      numdist            DECIMAL(20, 10)    DEFAULT NULL,
      avglblk            DECIMAL(20, 10)    DEFAULT NULL,
      avgdblk            DECIMAL(20, 10)    DEFAULT NULL,
      clstfct            DECIMAL(20, 10)    DEFAULT NULL,
      indlevel           DECIMAL(20, 10)    DEFAULT NULL,
      flags              DECIMAL(20, 10)    DEFAULT NULL,
      statown            VARCHAR(65535) DEFAULT NULL,
      no_invalidate      BOOLEAN    DEFAULT FALSE,
      guessq             DECIMAL(20, 10)    DEFAULT NULL,
      cachedblk          DECIMAL(20, 10)    DEFAULT NULL,
      cachehit           DECIMAL(20, 10)    DEFAULT NULL,
      force              BOOLEAN    DEFAULT FALSE,
      avgrlen            DECIMAL(20, 10)    DEFAULT NULL,
      nummacroblks       DECIMAL(20, 10)    DEFAULT NULL,
      nummicroblks       DECIMAL(20, 10)    DEFAULT NULL,
      tabname            VARCHAR(65535) DEFAULT NULL
    );

    PROCEDURE delete_table_stats (
      ownname           VARCHAR(65535),
      tabname           VARCHAR(65535),
      partname          VARCHAR(65535) DEFAULT NULL,
      stattab           VARCHAR(65535) DEFAULT NULL,
      statid            VARCHAR(65535) DEFAULT NULL,
      cascade_parts     BOOLEAN DEFAULT TRUE,
      cascade_columns   BOOLEAN DEFAULT TRUE,
      cascade_indexes   BOOLEAN DEFAULT TRUE,
      statown           VARCHAR(65535) DEFAULT NULL,
      no_invalidate     BOOLEAN DEFAULT FALSE,
      force             BOOLEAN DEFAULT FALSE,
      degree            DECIMAL(20, 10) DEFAULT 1
    );

    PROCEDURE delete_column_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      colname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535) DEFAULT NULL,
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade_parts    BOOLEAN DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE,
      col_stat_type    VARCHAR(65535) DEFAULT 'ALL',
      degree           DECIMAL(20, 10) DEFAULT 1
    );

    procedure delete_index_stats(
      ownname          VARCHAR(65535),
      indname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535) DEFAULT NULL,
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade_parts    BOOLEAN        DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN        DEFAULT FALSE,
      stattype         VARCHAR(65535) DEFAULT 'ALL',
      force            BOOLEAN        DEFAULT FALSE,
      tabname          VARCHAR(65535) DEFAULT NULL,
      degree           DECIMAL(20, 10) DEFAULT 1
    );

    PROCEDURE delete_schema_stats (
      ownname           VARCHAR(65535),
      stattab           VARCHAR(65535) DEFAULT NULL,
      statid            VARCHAR(65535) DEFAULT NULL,
      statown           VARCHAR(65535) DEFAULT NULL,
      no_invalidate     BOOLEAN DEFAULT FALSE,
      force             BOOLEAN DEFAULT FALSE,
      degree            DECIMAL(20, 10) DEFAULT 1
    );

    PROCEDURE FLUSH_DATABASE_MONITORING_INFO();
    PROCEDURE GATHER_DATABASE_STATS_JOB_PROC(duration BIGINT DEFAULT NULL);

    PROCEDURE create_stat_table(
      ownname          VARCHAR(65535),
      stattab          VARCHAR(65535),
      tblspace         VARCHAR(65535) DEFAULT NULL,
      global_temporary BOOLEAN DEFAULT FALSE
    );

    PROCEDURE drop_stat_table(
      ownname VARCHAR(65535),
      stattab VARCHAR(65535)
    );

    PROCEDURE export_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade          BOOLEAN DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      stat_category    VARCHAR(65535) DEFAULT DEFAULT_STAT_CATEGORY
    );

    PROCEDURE export_column_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      colname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL
    );

    PROCEDURE export_schema_stats (
      ownname          VARCHAR(65535),
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL
    );

    PROCEDURE export_index_stats (
      ownname           VARCHAR(65535),
      indname           VARCHAR(65535),
      partname          VARCHAR(65535) DEFAULT NULL,
      stattab           VARCHAR(65535),
      statid            VARCHAR(65535) DEFAULT NULL,
      statown           VARCHAR(65535) DEFAULT NULL,
      tabname           VARCHAR(65535) DEFAULT NULL
    );

    PROCEDURE import_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      cascade          BOOLEAN DEFAULT TRUE,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE,
      stat_category    VARCHAR(65535) DEFAULT DEFAULT_STAT_CATEGORY
    );

    PROCEDURE import_column_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      colname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE
    );

   PROCEDURE import_schema_stats (
      ownname          VARCHAR(65535),
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE
    );

    PROCEDURE import_index_stats (
      ownname          VARCHAR(65535),
      indname          VARCHAR(65535),
      partname         VARCHAR(65535) DEFAULT NULL,
      stattab          VARCHAR(65535),
      statid           VARCHAR(65535) DEFAULT NULL,
      statown          VARCHAR(65535) DEFAULT NULL,
      no_invalidate    BOOLEAN DEFAULT FALSE,
      force            BOOLEAN DEFAULT FALSE,
      tabname          VARCHAR(65535) DEFAULT NULL
    );

    PROCEDURE lock_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      stattype         VARCHAR(65535) DEFAULT 'ALL'
    );

    PROCEDURE lock_partition_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535)
    );

    PROCEDURE lock_schema_stats(
      ownname          VARCHAR(65535),
      STATTYPE         VARCHAR(65535) DEFAULT 'ALL'
    );

    PROCEDURE unlock_table_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      stattype         VARCHAR(65535) DEFAULT 'ALL'
    );

    PROCEDURE unlock_partition_stats (
      ownname          VARCHAR(65535),
      tabname          VARCHAR(65535),
      partname         VARCHAR(65535)
    );

    PROCEDURE unlock_schema_stats(
      ownname          VARCHAR(65535),
      STATTYPE         VARCHAR(65535) DEFAULT 'ALL'
    );

    PROCEDURE restore_table_stats (
      ownname               VARCHAR(65535),
      tabname               VARCHAR(65535),
      as_of_timestamp       DATETIME(6),
      restore_cluster_index BOOLEAN DEFAULT FALSE,
      force                 BOOLEAN DEFAULT FALSE,
      no_invalidate         BOOLEAN DEFAULT FALSE
    );

    PROCEDURE restore_schema_stats (
      ownname               VARCHAR(65535),
      as_of_timestamp       DATETIME(6),
      force                 BOOLEAN DEFAULT FALSE,
      no_invalidate         BOOLEAN DEFAULT FALSE
    );

    PROCEDURE purge_stats(
      before_timestamp      DATETIME(6)
    );

    PROCEDURE alter_stats_history_retention(
      retention             DECIMAL(20, 10)
    );

    FUNCTION get_stats_history_availability() RETURN DATETIME(6);

    FUNCTION get_stats_history_retention() RETURN DECIMAL;

    PROCEDURE reset_global_pref_defaults();

    PROCEDURE reset_param_defaults();

    PROCEDURE set_global_prefs(
      pname         VARCHAR(65535),
      pvalue        VARCHAR(65535)
    );

    PROCEDURE set_param(
      pname          VARCHAR(65535),
      pval           VARCHAR(65535)
    );

    PROCEDURE set_schema_prefs(
      ownname        VARCHAR(65535),
      pname          VARCHAR(65535),
      pvalue         VARCHAR(65535)
    );

    PROCEDURE set_table_prefs(
      ownname        VARCHAR(65535),
      tabname        VARCHAR(65535),
      pname          VARCHAR(65535),
      pvalue         VARCHAR(65535)
    );

    FUNCTION get_prefs (
      pname           VARCHAR(65535),
      ownname         VARCHAR(65535) DEFAULT NULL,
      tabname         VARCHAR(65535) DEFAULT NULL
    ) RETURN VARCHAR(65535);

    FUNCTION get_param (
      pname           VARCHAR(65535)
    )RETURN VARCHAR(65535);

    PROCEDURE delete_schema_prefs(
      ownname        VARCHAR(65535),
      pname          VARCHAR(65535)
    );

    PROCEDURE delete_table_prefs (
      ownname        VARCHAR(65535),
      tabname        VARCHAR(65535),
      pname          VARCHAR(65535)
    );

    PROCEDURE copy_table_stats (
      ownname        VARCHAR(65535),
      tabname        VARCHAR(65535),
      srcpartname    VARCHAR(65535),
      dstpartname		 VARCHAR(65535),
      scale_factor	 DECIMAL(20, 10) DEFAULT 1,
      flags					 DECIMAL(20, 10) DEFAULT NULL,
      force          BOOLEAN DEFAULT FALSE
    );

    PROCEDURE cancel_gather_stats (
      taskid          VARCHAR(65535)
    );

    PROCEDURE GATHER_SYSTEM_STATS();

    PROCEDURE DELETE_SYSTEM_STATS();

    PROCEDURE SET_SYSTEM_STATS (
      pname          VARCHAR(65535),
      pvalue         DECIMAL(20, 10)
    );

    PROCEDURE async_gather_stats_job_proc (duration BIGINT DEFAULT NULL);
END dbms_stats;
)sys_pack_del"
},
{
"dbms_udr.sql", // size = 493 bytes
R"sys_pack_del(#package_name:dbms_udr
#author: luofan.zp

CREATE OR REPLACE PACKAGE DBMS_UDR AUTHID CURRENT_USER AS

  PROCEDURE CREATE_RULE (
    rule_name          IN VARCHAR,
    pattern            IN CLOB,
    replacement        IN CLOB,
    enabled            IN VARCHAR  := 'YES'
  );

  PROCEDURE REMOVE_RULE (
    rule_name          IN VARCHAR
  );

  PROCEDURE ENABLE_RULE (
    rule_name          IN VARCHAR
  );

  PROCEDURE DISABLE_RULE (
    rule_name          IN VARCHAR
  );

END DBMS_UDR;
//
)sys_pack_del"
},
{
"dbms_udr_body.sql", // size = 622 bytes
R"sys_pack_del(#package_name:dbms_udr
#author: luofan.zp

CREATE OR REPLACE PACKAGE BODY DBMS_UDR AS

  PROCEDURE CREATE_RULE (
    rule_name          IN VARCHAR,
    pattern            IN CLOB,
    replacement        IN CLOB,
    enabled            IN VARCHAR := 'YES'
  );
  PRAGMA INTERFACE(c, CREATE_RULE);

  PROCEDURE REMOVE_RULE (
    rule_name          IN VARCHAR
  );
  PRAGMA INTERFACE(c, REMOVE_RULE);

  PROCEDURE ENABLE_RULE (
    rule_name          IN VARCHAR
  );
  PRAGMA INTERFACE(c, ENABLE_RULE);

  PROCEDURE DISABLE_RULE (
    rule_name          IN VARCHAR
  );
  PRAGMA INTERFACE(c, DISABLE_RULE);

END DBMS_UDR;
//
)sys_pack_del"
},
{
"dbms_udr_body_mysql.sql", // size = 670 bytes
R"sys_pack_del(#package_name: dbms_udr
#author: luofan.zp

CREATE OR REPLACE PACKAGE BODY DBMS_UDR

  PROCEDURE CREATE_RULE (
    rule_name          VARCHAR(256),
    rule_owner_name    VARCHAR(128),
    pattern            LONGTEXT,
    replacement        LONGTEXT,
    enabled            VARCHAR(64) DEFAULT 'YES'
  );
  PRAGMA INTERFACE(c, CREATE_RULE);

  PROCEDURE REMOVE_RULE (
    rule_name          VARCHAR(256)
  );
  PRAGMA INTERFACE(c, REMOVE_RULE);

  PROCEDURE ENABLE_RULE (
    rule_name          VARCHAR(256)
  );
  PRAGMA INTERFACE(c, ENABLE_RULE);

  PROCEDURE DISABLE_RULE (
    rule_name          VARCHAR(256)
  );
  PRAGMA INTERFACE(c, DISABLE_RULE);

END dbms_udr;
)sys_pack_del"
},
{
"dbms_udr_mysql.sql", // size = 539 bytes
R"sys_pack_del(#package_name:dbms_udr
#author: luofan.zp

CREATE OR REPLACE PACKAGE DBMS_UDR AUTHID CURRENT_USER

  PROCEDURE CREATE_RULE (
    rule_name          VARCHAR(256),
    rule_owner_name    VARCHAR(128),
    pattern            LONGTEXT,
    replacement        LONGTEXT,
    enabled            VARCHAR(64) DEFAULT 'YES'
  );

  PROCEDURE REMOVE_RULE (
    rule_name          VARCHAR(256)
  );

  PROCEDURE ENABLE_RULE (
    rule_name          VARCHAR(256)
  );

  PROCEDURE DISABLE_RULE (
    rule_name          VARCHAR(256)
  );

END DBMS_UDR;
)sys_pack_del"
},
{
"dbms_workload_repository.sql", // size = 1484 bytes
R"sys_pack_del(-- package_name:dbms_workload_repository
-- author:xiaochu.yh


--
-- 完整 PL 包参考文档：https://docs.oracle.com/database/121/ARPLS/d_workload_repos.htm#ARPLS093
--
CREATE OR REPLACE PACKAGE dbms_workload_repository AUTHID CURRENT_USER AS

  PROCEDURE ASH_REPORT(BTIME         IN TIMESTAMP,
                       ETIME         IN TIMESTAMP,
                       SQL_ID        IN VARCHAR2  DEFAULT NULL,
                       TRACE_ID      IN VARCHAR2  DEFAULT NULL,
                       WAIT_CLASS    IN VARCHAR2  DEFAULT NULL,
                       REPORT_TYPE   IN VARCHAR2  DEFAULT 'text',
                       SVR_IP        IN VARCHAR2  DEFAULT NULL,
                       SVR_PORT      IN NUMBER    DEFAULT NULL,
                       TENANT_ID     IN NUMBER    DEFAULT NULL
                     );

  FUNCTION ASH_REPORT_TEXT(L_BTIME     IN TIMESTAMP,
                           L_ETIME       IN TIMESTAMP,
                           SQL_ID        IN VARCHAR2  DEFAULT NULL,
                           TRACE_ID      IN VARCHAR2  DEFAULT NULL,
                           WAIT_CLASS    IN VARCHAR2  DEFAULT NULL,
                           SVR_IP        IN VARCHAR2  DEFAULT NULL,
                           SVR_PORT      IN NUMBER    DEFAULT NULL,
                           TENANT_ID     IN NUMBER    DEFAULT NULL,
                           REPORT_TYPE   IN VARCHAR2  DEFAULT 'text'
                          )
  RETURN CLOB;

END dbms_workload_repository;
)sys_pack_del"
},
{
"dbms_workload_repository_body.sql", // size = 2352 bytes
R"sys_pack_del(CREATE OR REPLACE PACKAGE BODY dbms_workload_repository AS

-- main function
FUNCTION ASH_REPORT_TEXT(L_BTIME       IN TIMESTAMP,
                         L_ETIME       IN TIMESTAMP,
                         SQL_ID        IN VARCHAR2  DEFAULT NULL,
                         TRACE_ID      IN VARCHAR2  DEFAULT NULL,
                         WAIT_CLASS    IN VARCHAR2  DEFAULT NULL,
                         SVR_IP        IN VARCHAR2  DEFAULT NULL,
                         SVR_PORT      IN NUMBER    DEFAULT NULL,
                         TENANT_ID     IN NUMBER    DEFAULT NULL,
                         REPORT_TYPE   IN VARCHAR2  DEFAULT 'text'
                        )
  RETURN CLOB;
  PRAGMA INTERFACE(C, GENERATE_ASH_REPORT_TEXT);

PROCEDURE ASH_REPORT(BTIME         IN TIMESTAMP,
                     ETIME         IN TIMESTAMP,
                     SQL_ID        IN VARCHAR2  DEFAULT NULL,
                     TRACE_ID      IN VARCHAR2  DEFAULT NULL,
                     WAIT_CLASS    IN VARCHAR2  DEFAULT NULL,
                     REPORT_TYPE   IN VARCHAR2  DEFAULT 'text',
                     SVR_IP        IN VARCHAR2  DEFAULT NULL,
                     SVR_PORT      IN NUMBER       DEFAULT NULL,
                     TENANT_ID     IN NUMBER       DEFAULT NULL
                   )
IS
  res CLOB;
  clob_length INTEGER;
  begin_offset INTEGER := 1;
  end_offset INTEGER := 1;
  line CLOB;
  newline_char CHAR(1) := CHR(10); -- Newline character (LF)
BEGIN
  DBMS_OUTPUT.ENABLE(NULL);
  IF (LOWER(REPORT_TYPE) = 'text' OR LOWER(REPORT_TYPE) = 'html') THEN
    res := DBMS_WORKLOAD_REPOSITORY.ASH_REPORT_TEXT(BTIME, ETIME, SQL_ID, TRACE_ID, WAIT_CLASS, SVR_IP, SVR_PORT, TENANT_ID, LOWER(REPORT_TYPE));
    clob_length := DBMS_LOB.GETLENGTH(res);
    WHILE end_offset <= clob_length LOOP
      end_offset := DBMS_LOB.INSTR(res, newline_char, begin_offset, 1);
      IF end_offset = 0 THEN
        DBMS_OUTPUT.PUT_LINE(DBMS_LOB.SUBSTR(res, 32767, begin_offset));
        EXIT;
      END IF;
      line := DBMS_LOB.SUBSTR(res, end_offset - begin_offset, begin_offset);
      DBMS_OUTPUT.PUT_LINE(line);
      begin_offset := end_offset + 1;
    END LOOP;
  ELSE
    DBMS_OUTPUT.PUT_LINE('Other formats are not currently supported besides text and html');
  END IF;
  -- DBMS_OUTPUT.NEW_LINE();
END ASH_REPORT;

END dbms_workload_repository;
)sys_pack_del"
},
{
"dbms_workload_repository_body_mysql.sql", // size = 2038 bytes
R"sys_pack_del(#package_name: dbms_workload_repository
#author: jiajingzhe.jjz

CREATE OR REPLACE PACKAGE BODY dbms_workload_repository

  PROCEDURE CREATE_SNAPSHOT (
    flush_level            VARCHAR(64) DEFAULT 'TYPICAL'
  );
  PRAGMA INTERFACE(c, WR_CREATE_SNAPSHOT);

  PROCEDURE DROP_SNAPSHOT_RANGE(
    low_snap_id    INT,
    high_snap_id   INT);
  PRAGMA INTERFACE(C, WR_DROP_SNAPSHOT_RANGE);

  PROCEDURE MODIFY_SNAPSHOT_SETTINGS(
    retention     INT    DEFAULT  NULL,
    interval      INT    DEFAULT  NULL,
    topnsql       INT    DEFAULT  NULL);
  PRAGMA INTERFACE(C, WR_MODIFY_SNAPSHOT_SETTINGS);

  FUNCTION ASH_REPORT_TEXT(BTIME         TIMESTAMP,
                           ETIME         TIMESTAMP,
                           SQL_ID        VARCHAR(64)  DEFAULT NULL,
                           TRACE_ID      VARCHAR(64)  DEFAULT NULL,
                           WAIT_CLASS    VARCHAR(64)  DEFAULT NULL,
                           SVR_IP        VARCHAR(64)  DEFAULT NULL,
                           SVR_PORT      INT          DEFAULT NULL,
                           TENANT_ID     INT          DEFAULT NULL,
                           REPORT_TYPE   VARCHAR(64)  DEFAULT 'text'
  )RETURN TEXT;
  PRAGMA INTERFACE(C, GENERATE_ASH_REPORT_TEXT);

  PROCEDURE ASH_REPORT(
    BTIME         TIMESTAMP,
    ETIME         TIMESTAMP,
    SQL_ID        VARCHAR(64)  DEFAULT NULL,
    TRACE_ID      VARCHAR(64)  DEFAULT NULL,
    WAIT_CLASS    VARCHAR(64)  DEFAULT NULL,
    REPORT_TYPE   VARCHAR(64)  DEFAULT 'text',
    SVR_IP        VARCHAR(64)  DEFAULT NULL,
    SVR_PORT      INT          DEFAULT NULL,
    TENANT_ID     INT          DEFAULT NULL)
  BEGIN
    IF (LOWER(REPORT_TYPE) = 'text' OR LOWER(REPORT_TYPE) = 'html') THEN
        SELECT DBMS_WORKLOAD_REPOSITORY.ASH_REPORT_TEXT(BTIME, ETIME,SQL_ID,TRACE_ID,WAIT_CLASS, SVR_IP, SVR_PORT, TENANT_ID, LOWER(REPORT_TYPE)) AS REPORT ;
    ELSE
        SELECT "Other formats are not currently supported besides text and html" AS Message;
    END IF;
  END ;

END dbms_workload_repository;
)sys_pack_del"
},
{
"dbms_workload_repository_mysql.sql", // size = 1656 bytes
R"sys_pack_del(#package_name:dbms_workload_repository
#author: jiajingzhe.jjz

-- only support SYS tenant
CREATE OR REPLACE PACKAGE dbms_workload_repository AUTHID CURRENT_USER

  PROCEDURE CREATE_SNAPSHOT(flush_level VARCHAR(64) DEFAULT 'TYPICAL');

  PROCEDURE DROP_SNAPSHOT_RANGE(
    low_snap_id    INT,
    high_snap_id   INT);

  PROCEDURE MODIFY_SNAPSHOT_SETTINGS(
    retention     INT    DEFAULT  NULL,
    interval      INT    DEFAULT  NULL,
    topnsql       INT    DEFAULT  NULL);

  FUNCTION ASH_REPORT_TEXT(BTIME         TIMESTAMP,
                           ETIME         TIMESTAMP,
                           SQL_ID        VARCHAR(64)  DEFAULT NULL,
                           TRACE_ID      VARCHAR(64)  DEFAULT NULL,
                           WAIT_CLASS    VARCHAR(64)  DEFAULT NULL,
                           SVR_IP        VARCHAR(64)  DEFAULT NULL,
                           SVR_PORT      INT          DEFAULT NULL,
                           TENANT_ID     INT          DEFAULT NULL,
                           REPORT_TYPE   VARCHAR(64)  DEFAULT 'text'
  )RETURN TEXT ;

  PROCEDURE ASH_REPORT(BTIME         TIMESTAMP,
                       ETIME         TIMESTAMP,
                       SQL_ID        VARCHAR(64)  DEFAULT NULL,
                       TRACE_ID      VARCHAR(64)  DEFAULT NULL,
                       WAIT_CLASS    VARCHAR(64)  DEFAULT NULL,
                       REPORT_TYPE   VARCHAR(64)  DEFAULT 'text',
                       SVR_IP        VARCHAR(64)  DEFAULT NULL,
                       SVR_PORT      INT          DEFAULT NULL,
                       TENANT_ID     INT          DEFAULT NULL);

END dbms_workload_repository;
)sys_pack_del"
},
{
"dbms_xplan_mysql.sql", // size = 2856 bytes
R"sys_pack_del(#package_name:dbms_xplan
#author:zhenling.zzg

CREATE OR REPLACE PACKAGE dbms_xplan  AUTHID CURRENT_USER

    --  CONSTANTS
    DECLARE DEFAULT_INENTIFIER      VARCHAR(20)    DEFAULT '';
    DECLARE DEFAULT_LEVEL           DECIMAL        DEFAULT 1;

    --  TYPES

    -- FUNCTIONS and PROCEDURES
    PROCEDURE enable_opt_trace(
        sql_id          VARCHAR(32)  DEFAULT '',
        identifier      VARCHAR(20)  DEFAULT DEFAULT_INENTIFIER,
        level           DECIMAL      DEFAULT DEFAULT_LEVEL
    );

    PROCEDURE disable_opt_trace();

    PROCEDURE set_opt_trace_parameter(
        sql_id          VARCHAR(32)  DEFAULT '',
        identifier      VARCHAR(20)  DEFAULT DEFAULT_INENTIFIER,
        level           DECIMAL      DEFAULT DEFAULT_LEVEL
    );

    -- display plan table`s plan
    function display(format       VARCHAR(32) default 'TYPICAL', -- 'BASIC', 'TYPICAL', 'ALL', 'ADVANCED'
                     statement_id VARCHAR(32) default null,
                     table_name   VARCHAR(32) default 'PLAN_TABLE',
                     filter_preds VARCHAR(255) default null)
    return text;

    -- display sql plan table`s plan
    function display_cursor(plan_id      DECIMAL default 0,             -- default value: last plan
                            format		 VARCHAR(32) default 'TYPICAL',
                            svr_ip       VARCHAR(64) default null,      -- default value: server connected by client
                            svr_port     DECIMAL default 0,             -- default value: server connected by client
                            tenant_id	 DECIMAL default 0              -- default value: current tenant
                        )
    return text;

    -- display base line plan
    function display_sql_plan_baseline(sql_handle   VARCHAR(32)  default  NULL,
                                        plan_name    VARCHAR(32)  default  NULL,
                                        format       VARCHAR(32)  default  'TYPICAL',
                                        svr_ip       VARCHAR(64) default null,      -- default value: server connected by client
                                        svr_port     DECIMAL default 0,             -- default value: server connected by client
                                        tenant_id	 DECIMAL default 0              -- default value: current tenant
                                    )
    return text;

    -- disable real time plan
    function display_active_session_plan(
                session_id   DECIMAL default 0,
                format       VARCHAR(32)  default  'TYPICAL',
                svr_ip       VARCHAR(64) default null,          -- default value: server connected by client
                svr_port     DECIMAL default 0                  -- default value: server connected by client
                )
    return text;

END dbms_xplan;
)sys_pack_del"
},
{
"dbms_xplan_mysql_body.sql", // size = 2973 bytes
R"sys_pack_del(# package_name : dbms_xplan
# author : zhenling.zzg

CREATE OR REPLACE PACKAGE BODY dbms_xplan

    PROCEDURE enable_opt_trace(
        sql_id          VARCHAR(32)  DEFAULT '',
        identifier      VARCHAR(20)  DEFAULT DEFAULT_INENTIFIER,
        level           DECIMAL      DEFAULT DEFAULT_LEVEL
    );
    PRAGMA INTERFACE(C, ENABLE_OPT_TRACE);

    PROCEDURE disable_opt_trace();
    PRAGMA INTERFACE(C, DISABLE_OPT_TRACE);

    PROCEDURE set_opt_trace_parameter(
        sql_id          VARCHAR(32)  DEFAULT '',
        identifier      VARCHAR(20)  DEFAULT DEFAULT_INENTIFIER,
        level           DECIMAL      DEFAULT DEFAULT_LEVEL
    );
    PRAGMA INTERFACE(C, SET_OPT_TRACE_PARAMETER);

    -- display plan table`s plan
    function display(format       VARCHAR(32) default 'TYPICAL', -- 'BASIC', 'TYPICAL', 'ALL', 'ADVANCED'
                     statement_id VARCHAR(32) default null,
                     table_name   VARCHAR(32) default 'PLAN_TABLE',
                     filter_preds VARCHAR(255) default null)
    return text;
    PRAGMA INTERFACE(C, DISPLAY);

    -- display sql plan table`s plan
    function display_cursor(plan_id      DECIMAL default 0,             -- default value: last plan
                            format		 VARCHAR(32) default 'TYPICAL',
                            svr_ip       VARCHAR(64) default null,      -- default value: server connected by client
                            svr_port     DECIMAL default 0,             -- default value: server connected by client
                            tenant_id	 DECIMAL default 0              -- default value: current tenant
                        )
    return text;
    PRAGMA INTERFACE(C, DISPLAY_CURSOR);

    -- display base line plan
    function display_sql_plan_baseline(sql_handle   VARCHAR(32)  default  NULL,
                                        plan_name    VARCHAR(32)  default  NULL,
                                        format       VARCHAR(32)  default  'TYPICAL',
                                        svr_ip       VARCHAR(64) default null,      -- default value: server connected by client
                                        svr_port     DECIMAL default 0,             -- default value: server connected by client
                                        tenant_id	 DECIMAL default 0              -- default value: current tenant
                                    )
    return text;
    PRAGMA INTERFACE(C, DISPLAY_SQL_PLAN_BASELINE);

    -- disable real time plan
    function display_active_session_plan(
                session_id   DECIMAL default 0,
                format       VARCHAR(32)  default  'TYPICAL',
                svr_ip       VARCHAR(64) default null,          -- default value: server connected by client
                svr_port     DECIMAL default 0                  -- default value: server connected by client
                )
    return text;
    PRAGMA INTERFACE(C, DISPLAY_ACTIVE_SESSION_PLAN);

END dbms_xplan;
)sys_pack_del"
},
{
"external_table_alert_log.sql", // size = 1127 bytes
R"sys_pack_del(#package_name: external_table_alert_log
#author: liangjinrong.ljr

create database if not exists sys_external_tbs;
//

create external table if not exists sys_external_tbs.__all_external_alert_log_info (
  time varchar(30) as (metadata$filecol1),
  level varchar(10) as (metadata$filecol2),
  module varchar(30) as (metadata$filecol3),
  event varchar(100) as (metadata$filecol4),
  errcode int as (metadata$filecol5),
  ip varchar(100) as (substr(metadata$fileurl, 1, instr(metadata$fileurl, ':') - 1)),
  port varchar(100) as (substr(metadata$fileurl, instr(metadata$fileurl, ':') + 1, instr(metadata$fileurl, '%') - instr(metadata$fileurl, ':') - 1)),
  tenant_id int as (metadata$filecol6),
  thread_id int as (metadata$filecol7),
  thread_name varchar(50) as (metadata$filecol8),
  trace_id varchar(50) as (metadata$filecol9),
  func_name varchar(100) as (metadata$filecol10),
  code_location varchar(100) as (metadata$filecol11),
  message longtext as (metadata$filecol12)
)
location = 'log/alert'
format = (
  type = 'csv'
  field_delimiter = '|'
  field_optionally_enclosed_by = '"'
)
pattern = 'alert.log[.0-9]*'
;
//
)sys_pack_del"
},
{
"json_array_type.sql", // size = 1057 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE JSON_ARRAY_T FORCE OID '300025' AS OPAQUE
(
  STATIC FUNCTION parse(jsn VARCHAR2) return JSON_ARRAY_T,
  STATIC FUNCTION parse(jsn CLOB)     return JSON_ARRAY_T,
  STATIC FUNCTION parse(jsn BLOB)     return JSON_ARRAY_T,

  CONSTRUCTOR FUNCTION JSON_ARRAY_T RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_ARRAY_T(o JSON_ELEMENT_T) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_ARRAY_T(o JSON_ARRAY_T) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_ARRAY_T(jsn VARCHAR2) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_ARRAY_T(jsn CLOB) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_ARRAY_T(jsn BLOB) RETURN SELF AS RESULT,

  MEMBER PROCEDURE on_Error(SELF IN OUT NOCOPY JSON_ARRAY_T, val NUMBER),
  MEMBER FUNCTION get(SELF IN OUT NOCOPY JSON_ARRAY_T, pos NUMBER) return JSON_ELEMENT_T,
  MEMBER FUNCTION get_Type(pos NUMBER) return VARCHAR2,
  MEMBER FUNCTION get_Size RETURN NUMBER,
  MEMBER FUNCTION to_String RETURN VARCHAR2,
  MEMBER FUNCTION clone(SELF IN OUT NOCOPY JSON_ARRAY_T) RETURN JSON_ARRAY_T
);
//)sys_pack_del"
},
{
"json_array_type_body.sql", // size = 1700 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE BODY JSON_ARRAY_T AS
  STATIC function parse(jsn VARCHAR2) return JSON_ARRAY_T;
  PRAGMA INTERFACE(c, JSON_ARRAY_PARSE);

  STATIC FUNCTION parse(jsn CLOB) return JSON_ARRAY_T;
  PRAGMA INTERFACE(c, JSON_ARRAY_PARSE);
  STATIC FUNCTION parse(jsn BLOB) return JSON_ARRAY_T;
  PRAGMA INTERFACE(c, JSON_ARRAY_PARSE);

  CONSTRUCTOR FUNCTION JSON_ARRAY_T RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_ARRAY_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_ARRAY_T(jsn VARCHAR2) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_ARRAY_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_ARRAY_T(jsn CLOB) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_ARRAY_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_ARRAY_T(jsn BLOB) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_ARRAY_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_ARRAY_T(o JSON_ELEMENT_T) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_ARRAY_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_ARRAY_T(o JSON_ARRAY_T) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_ARRAY_CONSTRUCTOR);

  MEMBER FUNCTION get(SELF IN OUT NOCOPY JSON_ARRAY_T, pos IN NUMBER) return JSON_ELEMENT_T;
  PRAGMA INTERFACE(c, JSON_ARRAY_GET);

  MEMBER PROCEDURE on_Error(SELF IN OUT NOCOPY JSON_ARRAY_T, val IN NUMBER);
  PRAGMA INTERFACE(c, JSON_ARRAY_ON_ERROR);

  MEMBER FUNCTION get_Type(pos IN NUMBER) return VARCHAR2;
  PRAGMA INTERFACE(c, JSON_ARRAY_GET_TYPE);

  MEMBER FUNCTION to_String RETURN VARCHAR2;
  PRAGMA INTERFACE(c, JSON_TO_STRING);

  MEMBER FUNCTION get_Size  RETURN NUMBER;
  PRAGMA INTERFACE(c, JSON_GET_SIZE);

  MEMBER FUNCTION clone(SELF IN OUT NOCOPY JSON_ARRAY_T) RETURN JSON_ARRAY_T;
  PRAGMA INTERFACE(c, JSON_ARRAY_CLONE);
END;
//)sys_pack_del"
},
{
"json_element_type.sql", // size = 1280 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE JSON_ELEMENT_T FORCE OID '300023' AS OPAQUE
(
  STATIC FUNCTION parse(jsn VARCHAR2) return   JSON_ELEMENT_T,
  STATIC FUNCTION parse(jsn CLOB)     return   JSON_ELEMENT_T,
  STATIC FUNCTION parse(jsn BLOB)     return   JSON_ELEMENT_T,

  MEMBER FUNCTION to_String    RETURN VARCHAR2,
  MEMBER FUNCTION to_Number    RETURN NUMBER,
  MEMBER FUNCTION to_Date      RETURN DATE,
  MEMBER FUNCTION to_Timestamp RETURN TIMESTAMP,
  MEMBER FUNCTION to_Boolean   RETURN BOOLEAN,
  MEMBER FUNCTION to_Clob      RETURN CLOB,
  MEMBER FUNCTION to_Blob      RETURN BLOB,

  MEMBER PROCEDURE to_Clob(c IN OUT CLOB),
  MEMBER PROCEDURE to_Blob(c IN OUT BLOB),
  MEMBER PROCEDURE on_Error(val IN NUMBER),

  MEMBER FUNCTION is_Object    RETURN BOOLEAN,
  MEMBER FUNCTION is_Array     RETURN BOOLEAN,
  MEMBER FUNCTION is_Scalar    RETURN BOOLEAN,
  MEMBER FUNCTION is_String    RETURN BOOLEAN,
  MEMBER FUNCTION is_Number    RETURN BOOLEAN,
  MEMBER FUNCTION is_Boolean   RETURN BOOLEAN,
  MEMBER FUNCTION is_True      RETURN BOOLEAN,
  MEMBER FUNCTION is_False     RETURN BOOLEAN,
  MEMBER FUNCTION is_Null      RETURN BOOLEAN,
  MEMBER FUNCTION is_Date      RETURN BOOLEAN,
  MEMBER FUNCTION is_Timestamp RETURN BOOLEAN,
  MEMBER FUNCTION get_Size     RETURN NUMBER
);
//)sys_pack_del"
},
{
"json_element_type_body.sql", // size = 2275 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE BODY JSON_ELEMENT_T AS
  STATIC FUNCTION parse(jsn VARCHAR2) return   JSON_ELEMENT_T;
  PRAGMA INTERFACE(c, JSON_ELEMENT_PARSE);

  STATIC FUNCTION parse(jsn CLOB)     return   JSON_ELEMENT_T;
  PRAGMA INTERFACE(c, JSON_ELEMENT_PARSE);

  STATIC FUNCTION parse(jsn BLOB)     return   JSON_ELEMENT_T;
  PRAGMA INTERFACE(c, JSON_ELEMENT_PARSE);

  MEMBER FUNCTION to_String    RETURN VARCHAR2;
  PRAGMA INTERFACE(c, JSON_TO_STRING);

  MEMBER FUNCTION to_Number    RETURN NUMBER;
  PRAGMA INTERFACE(c, JSON_TO_NUMBER);

  MEMBER FUNCTION to_Date      RETURN DATE;
  PRAGMA INTERFACE(c, JSON_TO_DATE);

  MEMBER FUNCTION to_Timestamp RETURN TIMESTAMP;
  PRAGMA INTERFACE(c, JSON_TO_TIMESTAMP);

  MEMBER FUNCTION to_Boolean   RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_TO_BOOLEAN);

  MEMBER FUNCTION to_Clob      RETURN CLOB;
  PRAGMA INTERFACE(c, JSON_TO_CLOB);

  MEMBER FUNCTION to_Blob      RETURN BLOB;
  PRAGMA INTERFACE(c, JSON_TO_BLOB);

  MEMBER PROCEDURE to_Clob(c IN OUT CLOB);
  PRAGMA INTERFACE(c, JSON_TO_CLOB_PROC);

  MEMBER PROCEDURE to_Blob(c IN OUT BLOB);
  PRAGMA INTERFACE(c, JSON_TO_BLOB_PROC);

  MEMBER PROCEDURE on_Error(val IN NUMBER);
  PRAGMA INTERFACE(c, JSON_ELEMENT_ON_ERROR);

  MEMBER FUNCTION is_Object    RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_OBJECT);

  MEMBER FUNCTION is_Array     RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_ARRAY);

  MEMBER FUNCTION is_Scalar    RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_SCALAR);

  MEMBER FUNCTION is_String    RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_STRING);

  MEMBER FUNCTION is_Number    RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_NUMBER);

  MEMBER FUNCTION is_Boolean   RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_BOOLEAN);

  MEMBER FUNCTION is_True      RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_TRUE);

  MEMBER FUNCTION is_False     RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_FALSE);

  MEMBER FUNCTION is_Null      RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_NULL);

  MEMBER FUNCTION is_Date      RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_DATE);

  MEMBER FUNCTION is_Timestamp RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_TIMESTAMP);

  MEMBER FUNCTION get_Size     RETURN NUMBER;
  PRAGMA INTERFACE(c, JSON_GET_SIZE);

END;
//)sys_pack_del"
},
{
"json_object_type.sql", // size = 4117 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE JSON_OBJECT_T OID '300024' AS OPAQUE
(
  STATIC FUNCTION parse(jsn VARCHAR2) return JSON_OBJECT_T,
  STATIC FUNCTION parse(jsn CLOB)     return JSON_OBJECT_T,
  STATIC FUNCTION parse(jsn BLOB)     return JSON_OBJECT_T,

  CONSTRUCTOR FUNCTION JSON_OBJECT_T RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn JSON_ELEMENT_T) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn JSON_OBJECT_T) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn VARCHAR2) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn CLOB) RETURN SELF AS RESULT,
  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn BLOB) RETURN SELF AS RESULT,

  MEMBER FUNCTION is_Object RETURN BOOLEAN,
  MEMBER FUNCTION is_Array RETURN BOOLEAN,
  MEMBER FUNCTION is_Scalar RETURN BOOLEAN,
  MEMBER FUNCTION is_String RETURN BOOLEAN,
  MEMBER FUNCTION is_Number RETURN BOOLEAN,
  MEMBER FUNCTION is_Boolean RETURN BOOLEAN,
  MEMBER FUNCTION is_True RETURN BOOLEAN,
  MEMBER FUNCTION is_False RETURN BOOLEAN,
  MEMBER FUNCTION is_Null RETURN BOOLEAN,
  MEMBER FUNCTION is_Date RETURN BOOLEAN,
  MEMBER FUNCTION is_Timestamp RETURN BOOLEAN,
  MEMBER FUNCTION get_Size     RETURN NUMBER,

  MEMBER FUNCTION to_String RETURN VARCHAR2,
  MEMBER FUNCTION to_Number    RETURN NUMBER,
  MEMBER FUNCTION to_Date      RETURN DATE,
  MEMBER FUNCTION to_Timestamp RETURN TIMESTAMP,
  MEMBER FUNCTION to_Boolean   RETURN BOOLEAN,
  MEMBER FUNCTION to_Clob      RETURN CLOB,
  MEMBER FUNCTION to_Blob      RETURN BLOB,

  MEMBER PROCEDURE to_Clob(c IN OUT CLOB),
  MEMBER PROCEDURE to_Blob(c IN OUT BLOB),

  MEMBER FUNCTION get_String(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return VARCHAR2,
  MEMBER FUNCTION get_Number(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return NUMBER,
  MEMBER FUNCTION get_Date(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return DATE,
  MEMBER FUNCTION get_Timestamp(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return TIMESTAMP,
  MEMBER FUNCTION get_Boolean(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return BOOLEAN,
  MEMBER FUNCTION get_Clob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return CLOB,
  MEMBER FUNCTION get_Blob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return BLOB,
  MEMBER FUNCTION get_Object(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return JSON_OBJECT_T,
  MEMBER FUNCTION get(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return JSON_ELEMENT_T,

  MEMBER PROCEDURE get_Clob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, c IN OUT CLOB),
  MEMBER PROCEDURE get_Blob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, c IN OUT BLOB),

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value BOOLEAN),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON_OBJECT_T),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON_ELEMENT_T),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON_ARRAY_T),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value VARCHAR2),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value NUMBER),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value DATE),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value TIMESTAMP),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value BLOB),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value CLOB),
  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON),
  MEMBER PROCEDURE put_Null(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2),
  MEMBER PROCEDURE remove(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2),
  MEMBER PROCEDURE rename_Key(SELF IN OUT NOCOPY JSON_OBJECT_T, keyOld VARCHAR2, keyNew VARCHAR2),
  MEMBER PROCEDURE on_Error(SELF IN OUT NOCOPY JSON_OBJECT_T, val NUMBER),

  MEMBER FUNCTION has(key VARCHAR2) return BOOLEAN,
  MEMBER FUNCTION get_Type(key VARCHAR2) return VARCHAR2,
  MEMBER FUNCTION clone(self IN OUT NOCOPY JSON_OBJECT_T) RETURN JSON_OBJECT_T
);
//)sys_pack_del"
},
{
"json_object_type_body.sql", // size = 6670 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE BODY JSON_OBJECT_T AS
  STATIC function parse(jsn VARCHAR2) return JSON_OBJECT_T;
  PRAGMA INTERFACE(c, JSON_OBJECT_PARSE);

  STATIC FUNCTION parse(jsn CLOB) return JSON_OBJECT_T;
  PRAGMA INTERFACE(c, JSON_OBJECT_PARSE);

  STATIC FUNCTION parse(jsn BLOB) return JSON_OBJECT_T;
  PRAGMA INTERFACE(c, JSON_OBJECT_PARSE);

  CONSTRUCTOR FUNCTION JSON_OBJECT_T RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_OBJECT_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn VARCHAR2) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_OBJECT_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn CLOB) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_OBJECT_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn BLOB) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_OBJECT_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn JSON_ELEMENT_T) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_OBJECT_CONSTRUCTOR);

  CONSTRUCTOR FUNCTION JSON_OBJECT_T(jsn JSON_OBJECT_T) RETURN SELF AS RESULT;
  PRAGMA INTERFACE(c, JSON_OBJECT_CONSTRUCTOR);

  MEMBER FUNCTION is_Object RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_OBJECT);

  MEMBER FUNCTION is_Array RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_ARRAY);

  MEMBER FUNCTION is_Scalar RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_SCALAR);

  MEMBER FUNCTION is_String RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_STRING);

  MEMBER FUNCTION is_Number RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_NUMBER);

  MEMBER FUNCTION is_Boolean RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_BOOLEAN);

  MEMBER FUNCTION is_True RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_TRUE);

  MEMBER FUNCTION is_False RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_FALSE);

  MEMBER FUNCTION is_Null RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_NULL);

  MEMBER FUNCTION is_Date RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_DATE);

  MEMBER FUNCTION is_Timestamp RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_IS_TIMESTAMP);

  MEMBER FUNCTION to_String RETURN VARCHAR2;
  PRAGMA INTERFACE(c, JSON_TO_STRING);

  MEMBER FUNCTION to_Number    RETURN NUMBER;
  PRAGMA INTERFACE(c, JSON_TO_NUMBER);

  MEMBER FUNCTION to_Date      RETURN DATE;
  PRAGMA INTERFACE(c, JSON_TO_DATE);

  MEMBER FUNCTION to_Timestamp RETURN TIMESTAMP;
  PRAGMA INTERFACE(c, JSON_TO_TIMESTAMP);

  MEMBER FUNCTION to_Boolean   RETURN BOOLEAN;
  PRAGMA INTERFACE(c, JSON_TO_BOOLEAN);

  MEMBER FUNCTION to_Clob      RETURN CLOB;
  PRAGMA INTERFACE(c, JSON_TO_CLOB);

  MEMBER FUNCTION to_Blob      RETURN BLOB;
  PRAGMA INTERFACE(c, JSON_TO_BLOB);

  MEMBER PROCEDURE to_Clob(c IN OUT CLOB);
  PRAGMA INTERFACE(c, JSON_TO_CLOB_PROC);

  MEMBER PROCEDURE to_Blob(c IN OUT BLOB);
  PRAGMA INTERFACE(c, JSON_TO_BLOB_PROC);

  MEMBER FUNCTION get_Size     RETURN NUMBER;
  PRAGMA INTERFACE(c, JSON_GET_SIZE);

  MEMBER FUNCTION get_String(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return VARCHAR2;
  PRAGMA INTERFACE(c, JSON_OBJECT_GETSTR);

  MEMBER FUNCTION get_Number(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return NUMBER;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_NUMBER);

  MEMBER FUNCTION get_Date(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return DATE;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_DATE);

  MEMBER FUNCTION get_Timestamp(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return TIMESTAMP;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_TIMESTAMP);

  MEMBER FUNCTION get_Boolean(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return BOOLEAN;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_BOOLEAN);

  MEMBER FUNCTION get_Clob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return CLOB;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_CLOB);

  MEMBER FUNCTION get_Blob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return BLOB;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_BLOB);

  MEMBER FUNCTION get_Object(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return JSON_OBJECT_T;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_OBJECT);

  MEMBER FUNCTION get(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2) return JSON_ELEMENT_T;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_ELEMENT);

  MEMBER PROCEDURE get_Clob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, c IN OUT CLOB);
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_CLOB_PROC);

  MEMBER PROCEDURE get_Blob(self IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, c IN OUT BLOB);
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_BLOB_PROC);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value BOOLEAN);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT_BOOL);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON_OBJECT_T);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON_ELEMENT_T);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON_ARRAY_T);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value VARCHAR2);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT_VARCHAR);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value NUMBER);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value DATE);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value TIMESTAMP);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value BLOB);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT_BLOB);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value CLOB);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT_CLOB);

  MEMBER PROCEDURE put(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2, value JSON);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT_JSON);

  MEMBER PROCEDURE put_Null(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2);
  PRAGMA INTERFACE(c, JSON_OBJECT_PUT_NULL);

  MEMBER PROCEDURE remove(SELF IN OUT NOCOPY JSON_OBJECT_T, key VARCHAR2);
  PRAGMA INTERFACE(c, JSON_OBJECT_REMOVE);

  MEMBER PROCEDURE rename_Key(SELF IN OUT NOCOPY JSON_OBJECT_T, keyOld VARCHAR2, keyNew VARCHAR2);
  PRAGMA INTERFACE(c, JSON_OBJECT_RENAME_KEY);

  MEMBER PROCEDURE on_Error(SELF IN OUT NOCOPY JSON_OBJECT_T, val NUMBER);
  PRAGMA INTERFACE(c, JSON_OBJECT_ON_ERROR);

  MEMBER FUNCTION has(key VARCHAR2) return BOOLEAN;
  PRAGMA INTERFACE(c, JSON_OBJECT_HAS);

  MEMBER FUNCTION get_Type(key VARCHAR2) return VARCHAR2;
  PRAGMA INTERFACE(c, JSON_OBJECT_GET_TYPE);

  MEMBER FUNCTION clone(self IN OUT NOCOPY JSON_OBJECT_T) RETURN JSON_OBJECT_T;
  PRAGMA INTERFACE(c, JSON_OBJECT_CLONE);
END;
//)sys_pack_del"
},
{
"sdo_geometry.sql", // size = 1313 bytes
R"sys_pack_del(
#type_name:sdo_geometry
#package_name:sdo_geometry

CREATE OR REPLACE TYPE SDO_POINT_TYPE FORCE OID '300027' IS OBJECT (
 X NUMBER,
 Y NUMBER,
 Z NUMBER
 );
//

CREATE OR REPLACE TYPE SDO_ELEM_INFO_ARRAY FORCE OID '300029' AS VARRAY (1048576) of NUMBER;
//
CREATE OR REPLACE TYPE SDO_ORDINATE_ARRAY FORCE OID '300030' AS VARRAY (1048576) of NUMBER;
//

CREATE OR REPLACE TYPE SDO_GEOMETRY OID '300028' IS OBJECT (
 SDO_GTYPE NUMBER,
 SDO_SRID NUMBER,
 SDO_POINT SDO_POINT_TYPE,
 SDO_ELEM_INFO SDO_ELEM_INFO_ARRAY,
 SDO_ORDINATES SDO_ORDINATE_ARRAY,
 -- extraction functions
 MEMBER FUNCTION GET_WKB RETURN BLOB DETERMINISTIC,
 MEMBER FUNCTION GET_WKT RETURN CLOB DETERMINISTIC,
 MEMBER FUNCTION Get_GType RETURN NUMBER DETERMINISTIC,
 MEMBER FUNCTION ST_CoordDim RETURN NUMBER DETERMINISTIC,
 MEMBER FUNCTION Get_Dims RETURN NUMBER DETERMINISTIC,
 MEMBER FUNCTION ST_IsValid RETURN NUMBER DETERMINISTIC,
 MEMBER FUNCTION Get_GeoJson RETURN CLOB DETERMINISTIC,

 CONSTRUCTOR FUNCTION SDO_GEOMETRY(wkb IN BLOB, srid IN NUMBER DEFAULT NULL) RETURN SELF AS RESULT DETERMINISTIC,
 CONSTRUCTOR FUNCTION SDO_GEOMETRY(wkt IN CLOB, srid IN NUMBER DEFAULT NULL) RETURN SELF AS RESULT DETERMINISTIC,
 CONSTRUCTOR FUNCTION SDO_GEOMETRY(wkt IN VARCHAR2, srid IN NUMBER DEFAULT NULL) RETURN SELF AS RESULT DETERMINISTIC
);
//
)sys_pack_del"
},
{
"sdo_geometry_body.sql", // size = 1358 bytes
R"sys_pack_del(#type_name:sdo_geometry
#package_name:sdo_geometry

CREATE OR REPLACE TYPE BODY SDO_GEOMETRY AS

  -- extraction functions
  MEMBER FUNCTION GET_WKB RETURN BLOB DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_get_wkb);

  MEMBER FUNCTION GET_WKT RETURN CLOB DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_get_wkt);

  MEMBER FUNCTION Get_GType RETURN NUMBER DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_get_gtype);

  MEMBER FUNCTION ST_CoordDim RETURN NUMBER DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_st_coorddim);

  MEMBER FUNCTION Get_Dims RETURN NUMBER DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_get_dims);

  MEMBER FUNCTION ST_IsValid RETURN NUMBER DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_st_isvalid);

  MEMBER FUNCTION Get_GeoJson RETURN CLOB DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_get_geojson);

  CONSTRUCTOR FUNCTION SDO_GEOMETRY(wkb IN BLOB, srid IN NUMBER DEFAULT NULL) RETURN SELF AS RESULT DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_constructor);

  CONSTRUCTOR FUNCTION SDO_GEOMETRY(wkt IN CLOB, srid IN NUMBER DEFAULT NULL) RETURN SELF AS RESULT DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_constructor);

  CONSTRUCTOR FUNCTION SDO_GEOMETRY(wkt IN VARCHAR2, srid IN NUMBER DEFAULT NULL) RETURN SELF AS RESULT DETERMINISTIC;
  PRAGMA INTERFACE(c, sdo_geometry_constructor);
END;
//
)sys_pack_del"
},
{
"utl_recomp.sql", // size = 650 bytes
R"sys_pack_del(-- package_name: utl_recomp
-- author: webber.wb

CREATE OR REPLACE PACKAGE UTL_RECOMP AS
  USE_EXIST_TABLE   CONSTANT PLS_INTEGER := 512;
  DROP_EXIST_TABLE  CONSTANT PLS_INTEGER := 1024;

  PROCEDURE recomp_parallel(threads PLS_INTEGER := NULL,
                            schema  VARCHAR2    := NULL,
                            flags   PLS_INTEGER := 0);
  PROCEDURE recomp_serial(schema VARCHAR2 := NULL,
                          flags PLS_INTEGER := 0);
  PROCEDURE parallel_slave(flags PLS_INTEGER);
  PROCEDURE truncate_utl_recomp_skip_list(flags PLS_INTEGER := 0);
  PROCEDURE populate_utl_recomp_skip_list(flags PLS_INTEGER := 0);
END;
//
)sys_pack_del"
},
{
"utl_recomp_body.sql", // size = 13969 bytes
R"sys_pack_del(-- package_name: utl_recomp
-- author: webber.wb

create or replace package body utl_recomp AS
  num_threads number;
  num_batch number;
  current_batch number := 0;

  sorted_table varchar2(50) := 'SYS.UTL_RECOMP_SORTED';
  compiled_table varchar2(50) := 'SYS.UTL_RECOMP_COMPILED';
  errors_table varchar2(50) := 'SYS.UTL_RECOMP_ERRORS';
  skip_list_table varchar2(50) := 'SYS.UTL_RECOMP_SKIP_LIST';

  sorted_table_ddl varchar2(500) := 'create table sys.utl_recomp_sorted (
                                      obj# number not null enable,
                                      owner varchar2(128),
                                      objname varchar2(128),
                                      edition_name  varchar2(128),
                                      namespace number,
                                      depth number,
                                      batch# number)';
  idx_sorted_table_ddl varchar2(500) := 'create index sys.idx_utl_recomp_sorted_1 on sys.utl_recomp_sorted(obj#,depth)';
  compiled_table_ddl varchar2(500) := 'create table sys.utl_recomp_compiled (
                                        obj# number not null enable,
                                        batch# number,
                                        compiled_at timestamp (6),
                                        completed_at timestamp (6),
                                        compiled_by varchar2(64))';
  idx_compiled_table_ddl varchar2(500) := 'create index sys.idx_utl_recomp_compiled_1 on sys.utl_recomp_compiled(obj#)';
  errors_table_ddl varchar2(500) := 'create table sys.utl_recomp_errors(
                                      obj# number,
                                      error_at timestamp (6),
                                      compile_err varchar2(4000))';
  idx_errors_table_ddl varchar2(500) := 'create index sys.idx_errors_table_ddl_1 on sys.utl_recomp_errors(obj#)';
  skip_list_table_ddl varchar2(500) := 'create table sys.utl_recomp_skip_list
                                          (OBJ# NUMBER NOT NULL ENABLE)';


  table_not_exist exception;
  pragma exception_init(table_not_exist, -5019);

  valid_routine_name exception;
  pragma exception_init(valid_routine_name, -5980);

  TYPE str_array is table of varchar2(200);

  TYPE OBJECT_INFO IS RECORD (object_id number,
                              owner varchar2(128),
                              object_name varchar2(128),
                              object_type varchar2(23));
  TYPE OBJECT_INFO_ARRAY IS TABLE OF OBJECT_INFO;

  procedure check_privilege as
  begin
    if user != 'SYS' then
      raise valid_routine_name;
    end if;
  end;

  procedure dynamic_execute(sql_str varchar2) as
  begin
    execute immediate sql_str;
  end;

  procedure check_table_exist(table_name varchar2, is_exist out bool) as
    select_str varchar2(200);
  begin
    is_exist := false;
    select_str := 'select count(1) from ' || table_name || ' where 0 = 1';
    execute immediate select_str;
    is_exist := true;
    exception
      when table_not_exist then
        is_exist := false;
      when others then
        raise;
  end;

  procedure prepare_table(table_name varchar2, ddl varchar2, flags PLS_INTEGER) as
    is_exist boolean := false;
  begin
    check_table_exist(table_name, is_exist);
    if (is_exist) then
      if (flags = USE_EXIST_TABLE) then
        null;
      elsif (flags = DROP_EXIST_TABLE) then
        dynamic_execute('drop table ' || table_name);
        dynamic_execute(ddl);
        if table_name = sorted_table then
          dynamic_execute(idx_sorted_table_ddl);
        elsif table_name = compiled_table then
          dynamic_execute(idx_compiled_table_ddl);
        elsif table_name = errors_table then
          dynamic_execute(idx_errors_table_ddl);
        end if;
      else
        RAISE_APPLICATION_ERROR(-20001,
          'table ' || table_name ||' exists, parameter FLAGS must be set to 512 to continue using the table, or set to 1024 to automatically drop and recreate the table');
      end if;
    else
      dynamic_execute(ddl);
      if table_name = sorted_table then
        dynamic_execute(idx_sorted_table_ddl);
      elsif table_name = compiled_table then
        dynamic_execute(idx_compiled_table_ddl);
      elsif table_name = errors_table then
        dynamic_execute(idx_errors_table_ddl);
      end if;
    end if;
  end;


  PROCEDURE truncate_utl_recomp_skip_list(flags PLS_INTEGER := 0) as
    is_exist boolean := false;
  begin
    check_privilege();
    check_table_exist(skip_list_table, is_exist);
    if is_exist then
      if (flags = USE_EXIST_TABLE) then
        dynamic_execute('truncate table sys.utl_recomp_skip_list');
      elsif (flags = DROP_EXIST_TABLE) then
        dynamic_execute('drop table sys.utl_recomp_skip_list');
        dynamic_execute(skip_list_table_ddl);
      else
        RAISE_APPLICATION_ERROR(-20001,
          'table UTL_RECOMP_SKIP_LIST exists, parameter FLAGS must be set to 512 to continue using the table, or set to 1024 to automatically drop and recreate the table');
      end if;
    else
      dynamic_execute(skip_list_table_ddl);
    end if;
  end;

  PROCEDURE populate_utl_recomp_skip_list(flags PLS_INTEGER := 0) as
    dml_str varchar2(500);
  begin
    check_privilege();
    prepare_table(skip_list_table, skip_list_table_ddl, flags);
    prepare_table(compiled_table, compiled_table_ddl, flags);
    dml_str := 'insert into sys.utl_recomp_skip_list select object_id from sys.all_objects o
                where o.status != ''VALID''
                      and o.object_id not in
                        (select OBJ# from sys.utl_recomp_compiled
                        union all select OBJ# from sys.utl_recomp_skip_list)
                      and o.object_type in (''PACKAGE'', ''PROCEDURE'', ''FUNCTION'', ''TYPE'', ''TRIGGER'')';

    dynamic_execute(dml_str);
  end;


  procedure parallel_slave(flags pls_integer) as
    TYPE compile_info IS RECORD (object_id number,
                                owner varchar2(128),
                                object_name varchar2(128),
                                object_type varchar2(23),
                                compile_time timestamp,
                                complete_time timestamp,
                                compile_by varchar2(64));
    type compile_info_array is table of compile_info;
    compile_arr compile_info_array;
    batch_no int := flags;
    error_msg varchar2(4000);
  begin
    check_privilege();
    execute immediate 'select o.object_id, o.owner, o.object_name, o.object_type, null, null, null
                        from sys.all_objects o
                        join sys.utl_recomp_sorted s on o.object_id = s.obj# and s.batch# = :1
                        where o.object_type in (''PACKAGE'', ''PROCEDURE'', ''FUNCTION'', ''TYPE'', ''TRIGGER'')'
            bulk collect into compile_arr using batch_no;
    for i in 1 .. compile_arr.count() loop
      begin
        compile_arr(i).compile_time := systimestamp;
        sys.dbms_utility.VALIDATE(compile_arr(i).object_id);
        exception when others then
          error_msg := sys.dbms_utility.format_error_stack();
          execute immediate 'insert into sys.utl_recomp_errors values (:1, :2, :3)'
            using compile_arr(i).object_id, systimestamp, error_msg;
      end;
      compile_arr(i).complete_time := systimestamp;
      execute immediate 'insert into sys.utl_recomp_compiled values (:1, :2, :3, :4, :5)'
        using compile_arr(i).object_id, batch_no, compile_arr(i).compile_time,
              compile_arr(i).complete_time, batch_no;
      commit;
    end loop;
    exception when others then
      error_msg := sys.dbms_utility.format_error_stack();
      execute immediate 'insert into sys.utl_recomp_errors values (:1, :2, :3)'
            using 0, systimestamp, error_msg;
      commit;
  end;


  procedure drop_jobs is
    job_names str_array;
  begin
    select job_name bulk collect into job_names from SYS.DBA_SCHEDULER_JOBS where job_action like 'SYS.UTL_RECOMP.PARALLEL_SLAVE(%';
    for i in 1 .. job_names.count() loop
      begin
        dbms_scheduler.drop_job(job_names(i), true);
      exception when others then
        null;
      end;
    end loop;
  end;

  -- 清理utl_recomp_compiled表和utl_recomp_errors表,清理系统中已有的job
  procedure init(schema varchar2) is
  begin
    if (schema is null) then
      dynamic_execute('truncate table sys.utl_recomp_compiled');
      dynamic_execute('truncate table sys.utl_recomp_errors');
    else
      execute immediate 'delete from sys.utl_recomp_compiled where obj# in (select object_id from sys.all_objects where owner
                        = :1 and object_type in (''PACKAGE'', ''PROCEDURE'', ''FUNCTION'', ''TYPE'', ''TRIGGER''))'
              using schema;
      execute immediate 'delete from sys.utl_recomp_errors where obj# in (select object_id from sys.all_objects where owner
                        = :1 and object_type in (''PACKAGE'', ''PROCEDURE'', ''FUNCTION'', ''TYPE'', ''TRIGGER''))'
              using schema;
    end if;
    dynamic_execute('truncate table sys.utl_recomp_sorted');
    drop_jobs();
  end;

  PROCEDURE COMPUTE_NUM_THREADS(threads PLS_INTEGER) AS
  begin
    num_threads := threads;
    if (num_threads is null or num_threads <= 0) then
      select (select nvl(min(TO_NUMBER(value)), 1) from  SYS.GV$OB_PARAMETERS where name = 'cpu_count')
            * (select nvl(min(TO_NUMBER(value)), 1) from SYS.GV$OB_PARAMETERS where name = 'cpu_quota_concurrency') num
      into num_threads from dual;
      if (num_threads is null or num_threads <= 0) then
        num_threads := 1;
      end if;
    end if;
  end;

  procedure collect_and_sort_object(schema varchar2) as
    type object_group is record (obj_cnt int, depth int);
    type object_groups is table of object_group;
    obj_gs object_groups;
    insert_str varchar(2000) :=
      'insert into sys.utl_recomp_sorted (obj#, owner, objname, edition_name, namespace)
        select o.object_id, o.owner, o.object_name, o.edition_name, o.namespace
          from sys.all_objects o
          where o.object_id not in
              (select c.OBJ# from sys.utl_recomp_compiled c
                union all
                select l.OBJ# from sys.utl_recomp_skip_list l)
            and o.object_type in (''PACKAGE'', ''PROCEDURE'', ''FUNCTION'', ''TYPE'', ''TRIGGER'')
            and o.object_id > 500000 ';

    update_depth_str varchar2(2000) :=
        'update sys.utl_recomp_sorted o set depth = :1
            where depth is null and
              not exists (select s.obj# from (select * from sys.ALL_VIRTUAL_TENANT_DEPENDENCY_REAL_AGENT where dep_obj_id != ref_obj_id) d, sys.utl_recomp_sorted s
                          where d.dep_obj_id = o.obj#
                            and d.ref_obj_id = s.obj#
                            and s.depth is null)';
    current_depth int := 0;
    min_batch_size int := 10;
    max_batch_size int := 50;
    batch_size int := 0;
  begin
    if (schema is null) then
      execute immediate insert_str;
    else
      execute immediate insert_str || 'and owner = :1' using schema;
    end if;
    commit;

    loop
      execute immediate update_depth_str using current_depth;
      current_depth := current_depth + 1;
      exit when SQL%ROWCOUNT = 0;
      commit;
    end loop;
    execute immediate 'update sys.utl_recomp_sorted set depth = :1 where depth is null' using current_depth;
    commit;

    execute immediate 'select count(obj#), depth from sys.utl_recomp_sorted group by depth order by depth'
        bulk collect into obj_gs;
    num_batch := 0;
    for i in 1 .. obj_gs.count() loop
      batch_size := least(max_batch_size, obj_gs(i).obj_cnt/num_threads);
      batch_size := greatest(min_batch_size, batch_size);
      execute immediate 'update sys.utl_recomp_sorted set batch# = floor((rownum-1)/(:1)) + :2
                          where depth = :3 and batch# is null'
              using batch_size, num_batch, obj_gs(i).depth;
      num_batch := num_batch + ceil(SQL%ROWCOUNT/batch_size);
      commit;
    end loop;
  end;


  procedure create_jobs as
  begin
    for i in 0 .. num_threads-1 loop
      dbms_scheduler.create_job(JOB_NAME => 'UTL_RECOMP_SLAVE_' || current_batch,
                                JOB_TYPE => 'PLSQL_BLOCK',
                                JOB_ACTION => 'SYS.UTL_RECOMP.PARALLEL_SLAVE(' || current_batch || ')',
                                START_DATE => systimestamp,
                                END_DATE => systimestamp + 1,
                                ENABLED => true,
                                AUTO_DROP => false,
                                MAX_RUN_DURATION => 7200);
      current_batch := current_batch + 1;
      exit when current_batch > num_batch;
    end loop;
  end;


  procedure wait_jobs as
    remain_job_cnt int;
  begin
    loop
      select count(*) into remain_job_cnt
        from sys.ALL_VIRTUAL_TENANT_SCHEDULER_JOB_REAL_AGENT
        where LAST_DATE is NULL and job > 0 and JOB_NAME LIKE 'UTL_RECOMP_SLAVE_%';
      exit when remain_job_cnt = 0;
      DBMS_LOCK.SLEEP(3);
    end loop;
  end;


  procedure recomp_parallel(threads PLS_INTEGER := NULL, schema varchar2 := NULL, flags PLS_INTEGER := 0) as
  begin
    current_batch := 0;
    check_privilege();
    prepare_table(skip_list_table, skip_list_table_ddl, flags);
    prepare_table(sorted_table, sorted_table_ddl, flags);
    prepare_table(compiled_table, compiled_table_ddl, flags);
    prepare_table(errors_table, errors_table_ddl, flags);

    init(schema);

    COMPUTE_NUM_THREADS(threads);
    collect_and_sort_object(schema);

    for i in 1 .. ceil(num_batch/num_threads) loop
      create_jobs();
      wait_jobs();
      drop_jobs();
    end loop;
  end;


  procedure recomp_serial(schema varchar2 := null, flags pls_integer := 0) is
  begin
    recomp_parallel(1, schema, flags);
  end;
end;
//
)sys_pack_del"
},
{
"xml_sequence_type.sql", // size = 81 bytes
R"sys_pack_del(CREATE OR REPLACE TYPE XMLSEQUENCE OID '300026'
 AS VARRAY(32767) OF xmltype;
//
)sys_pack_del"
},
};

} // namespace pl
} // namespace oceanbase
