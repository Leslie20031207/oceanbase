
// DO NOT EDIT. This file is automatically generated from `ob_errno.def'.

// Copyright 2016 Alibaba Inc. All Rights Reserved.
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// version 2 as published by the Free Software Foundation.
// ob_errno.h
//   Author:
//   Normalizer:

#define USING_LOG_PREFIX LIB_MYSQLC

// DO NOT DELETE `#include <iostream>` !!!
// fix: ob_error.cpp file requires at least 20g memory for release(-O2) compilation
// and will jam when asan turned on
// it can be solved by introducing <iostream> header file currently
// TODO: it is clang bug and the specific reason to be further located
// issue:
#include <iostream>

#include "ob_errno.h"
#ifndef __ERROR_CODE_PARSER_
#include "ob_define.h"
#include "lib/utility/ob_edit_distance.h"
#else
#define OB_LIKELY
#define OB_UNLIKELY
#include <string.h>
#endif
using namespace oceanbase::common;

struct _error {
  public:
    const char *error_name;
    const char *error_cause;
    const char *error_solution;
    int         mysql_errno;
    const char *sqlstate;
    const char *str_error;
    const char *str_user_error;
    int         oracle_errno;
    const char *oracle_str_error;
    const char *oracle_str_user_error;
};
static _error _error_default;
static _error const *_errors[OB_MAX_ERROR_CODE] = {NULL};

struct ObStrErrorInit
{
  ObStrErrorInit()
  {
    memset(&_error_default, 0, sizeof  _error_default);
    for (int i = 0; i < OB_MAX_ERROR_CODE; ++i) {
      _errors[i] = &_error_default;
    }

  }
};

inline const _error *get_error(int index)
{
  static ObStrErrorInit error_init;
  return _errors[index];
}

int get_oracle_errno(int index)
{
  return get_error(index)->oracle_errno;
}

int get_mysql_errno(int index)
{
  return get_error(index)->mysql_errno;
}

const char* get_oracle_str_error(int index)
{
  return get_error(index)->oracle_str_error;
}

const char* get_mysql_str_error(int index)
{
  return get_error(index)->str_error;
}

namespace oceanbase
{
namespace common
{
int g_all_ob_errnos[0] = {};
  const char *ob_error_name(const int err)
  {
    const char *ret = "Unknown error";
    if (OB_UNLIKELY(0 == err)) {
      ret = "OB_SUCCESS";
    } else if (OB_LIKELY(0 > err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->error_name;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0]))
      {
        ret = "Unknown Error";
      }
    }
    return ret;
  }
  const char *ob_error_cause(const int err)
  {
    const char *ret = "Internal Error";
    if (OB_UNLIKELY(0 == err)) {
      ret = "Not an Error";
    } else if (OB_LIKELY(0 > err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->error_cause;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0]))
      {
        ret = "Internal Error";
      }
    }
    return ret;
  }
  const char *ob_error_solution(const int err)
  {
    const char *ret = "Contact OceanBase Support";
    if (OB_UNLIKELY(0 == err)) {
      ret = "Contact OceanBase Support";
    } else if (OB_LIKELY(0 > err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->error_solution;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0]))
      {
        ret = "Contact OceanBase Support";
      }
    }
    return ret;
  }
  const char *ob_strerror(const int err)
  {
    const char *ret = "Unknown error";
    if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->str_error;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0]))
      {
        ret = "Unknown Error";
      }
    }
    return ret;
  }
  const char *ob_str_user_error(const int err)
  {
    const char *ret = NULL;
    if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->str_user_error;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0])) {
        ret = NULL;
      }
    }
    return ret;
  }
  const char *ob_sqlstate(const int err)
  {
    const char *ret = "HY000";
    if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->sqlstate;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0])) {
        ret = "HY000";
      }
    }
    return ret;
  }
  int ob_mysql_errno(const int err)
  {
    int ret = -1;
    if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->mysql_errno;
    }
    return ret;
  }
  int ob_mysql_errno_with_check(const int err)
  {
    int ret = (err > 0 ? err : ob_mysql_errno(err));
    if (ret < 0) {
      ret = -err;
    }
    return ret;
  }
  const char *ob_oracle_strerror(const int err)
  {
    const char *ret = "Unknown error";
    if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->oracle_str_error;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0]))
      {
        ret = "Unknown Error";
      }
    }
    return ret;
  }
  const char *ob_oracle_str_user_error(const int err)
  {
    const char *ret = NULL;
    if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->oracle_str_user_error;
      if (OB_UNLIKELY(NULL == ret || '\0' == ret[0])) {
        ret = NULL;
      }
    }
    return ret;
  }
  int ob_oracle_errno(const int err)
  {
    int ret = -1;
    if (OB_ERR_PROXY_REROUTE == err) {
      // Oracle Mode and MySQL mode should return same errcode for reroute sql
      // thus we make the specialization here
      ret = -1;
    } else if (err >= OB_MIN_RAISE_APPLICATION_ERROR && err <= OB_MAX_RAISE_APPLICATION_ERROR) {
      ret = err; // PL/SQL Raise Application Error
    } else if (OB_LIKELY(0 >= err && err > -OB_MAX_ERROR_CODE)) {
      ret = get_error(-err)->oracle_errno;
    }
    return ret;
  }
  int ob_oracle_errno_with_check(const int err)
  {
    int ret = ob_oracle_errno(err);
    if (ret < 0) {
      ret = -err;
    }
    return ret;
  }
  int ob_errpkt_errno(const int err, const bool is_oracle_mode)
  {
    return (is_oracle_mode ? ob_oracle_errno_with_check(err) : ob_mysql_errno_with_check(err));
  }
  const char *ob_errpkt_strerror(const int err, const bool is_oracle_mode)
  {
    return (is_oracle_mode ? ob_oracle_strerror(err) : ob_strerror(err));
  }
  const char *ob_errpkt_str_user_error(const int err, const bool is_oracle_mode)
  {
    return (is_oracle_mode ? ob_oracle_str_user_error(err) : ob_str_user_error(err));
  }

} // end namespace common
} // end namespace oceanbase
